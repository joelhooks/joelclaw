Implemented NUUM-2 in `src/inngest/functions/observe-parser.ts`.

### Changes made
- Added exported `DistilledSegment` interface with:
  - `narrative: string`
  - `facts: string[]`
  - (`src/inngest/functions/observe-parser.ts:8`)
- Added exported `parseSegments(observations: string): DistilledSegment[]` that:
  - Extracts all `<segment>...</segment>` blocks
  - Reads `<narrative>` and trims content
  - Reads `<facts>`, splits lines, trims each bullet, strips bullet markers (`-`, `*`, `â€¢`)
  - Returns `[]` when no segments are present
  - (`src/inngest/functions/observe-parser.ts:47`)

### Verification
- Ran `bunx tsc --noEmit` successfully (exit code `0`).


--- STDERR ---
OpenAI Codex v0.101.0 (research preview)
--------
workdir: /private/tmp/agent-loop/loop-mlo6625k-jfz7xc/packages/system-bus
model: gpt-5.3-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: none
reasoning summaries: auto
session id: 019c62e8-55a4-73c2-807f-c35bc8e5b038
--------
user


## Project File Listing

docker
prd-v3-recovery.json
prd-adr-0010.json
progress.txt
node_modules
prd-retro.json
bun.lock
README.md
__tests__
package.json
tsconfig.json
docker-compose.yml
prd-v2.json
index.ts
CONTINUATION.md
prd.json
CLAUDE.md
prd-cli-migration.json
src
CONTINUATION-ADR.md

# src/ files:
src/inngest/client.ts
src/serve.ts

## Project Instructions (CLAUDE.md)


## Agent Loop Architecture (ADR-0015)

This project runs automated coding loops with 5 separated roles:
- **Planner**: generates PRD from goal, picks next story
- **Test Writer**: writes acceptance tests BEFORE implementation (TDD)
- **Implementor**: writes code to pass the tests
- **Reviewer**: evaluates implementation with 4 questions (no test writing)
- **Judge**: mechanical gates + reviewer notes + LLM verdict

When working as an implementor: implement the story, don't write tests.
When working as a test writer: write tests from acceptance criteria only, don't read implementation.
Tests should verify observable behavior and public API â€” NOT internal structure.
Do NOT use source code string matching (indexOf, regex on source) to verify behavior.
Commit nothing â€” the harness handles git.

## Bun Runtime

Default to using Bun instead of Node.js.

- Use `bun <file>` instead of `node <file>` or `ts-node <file>`
- Use `bun test` instead of `jest` or `vitest`
- Use `bun build <file.html|file.ts|file.css>` instead of `webpack` or `esbuild`
- Use `bun install` instead of `npm install` or `yarn install` or `pnpm install`
- Use `bun run <script>` instead of `npm run <script>` or `yarn run <script>` or `pnpm run <script>`
- Use `bunx <package> <command>` instead of `npx <package> <command>`
- Bun automatically loads .env, so don't use dotenv.

## APIs

- `Bun.serve()` supports WebSockets, HTTPS, and routes. Don't use `express`.
- `bun:sqlite` for SQLite. Don't use `better-sqlite3`.
- `Bun.redis` for Redis. Don't use `ioredis`.
- `Bun.sql` for Postgres. Don't use `pg` or `postgres.js`.
- `WebSocket` is built-in. Don't use `ws`.
- Prefer `Bun.file` over `node:fs`'s readFile/writeFile
- Bun.$`ls` instead of execa.

## Testing

Use `bun test` to run tests.

```ts#index.test.ts
import { test, expect } from "bun:test";

test("hello world", () => {
  expect(1).toBe(1);
});
```

## Frontend

Use HTML imports with `Bun.serve()`. Don't use `vite`. HTML imports fully support React, C

---

## Story: Add DistilledSegment interface and parseSegments function (NUUM-2)

In src/inngest/functions/observe-parser.ts, add a new exported interface DistilledSegment with fields: narrative (string) and facts (string[]). Add a new exported function parseSegments(observations: string): DistilledSegment[] that extracts <segment> blocks from the observations text, parsing <narrative> content as the narrative string and <facts> bullet items as the facts array. Each bullet should be trimmed. If no <segment> tags are found, return an empty array.

## Acceptance Criteria
- observe-parser.ts exports DistilledSegment interface with narrative (string) and facts (string[])
- observe-parser.ts exports parseSegments function with signature (observations: string) => DistilledSegment[]
- parseSegments correctly extracts narrative and facts from <segment> blocks
- parseSegments returns empty array when no <segment> tags are present
- TypeScript compiles cleanly: bunx tsc --noEmit

## Instructions
Implement the story above. Do NOT write tests â€” a separate reviewer will handle testing.
Make clean, focused changes. Commit nothing â€” the harness handles git.
mcp startup: no servers
2026-02-15T20:05:19.463337Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c5eca-bff9-7772-83bf-5daab07b9959
2026-02-15T20:05:19.502815Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c5ffd-d51d-7a13-b1fa-342be02f164b
2026-02-15T20:05:19.554207Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c6275-d69e-7b53-bb28-583bfe07e70c
2026-02-15T20:05:19.575646Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c5d40-288c-78b2-af66-36e0fae54073
2026-02-15T20:05:19.633774Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c6031-b7fb-7120-85b5-8abf34324910
2026-02-15T20:05:19.682798Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c5fe2-872d-7e93-87a3-71d37d75a127
2026-02-15T20:05:19.739449Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c5e50-6bc5-7861-a0a0-f77d68ec073f
2026-02-15T20:05:19.804585Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c6022-8a12-7ba0-b7e8-9c265e8ec17e
2026-02-15T20:05:19.853777Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c5fbb-e145-7c40-9913-218548629e57
2026-02-15T20:05:19.897342Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c5e21-7a30-7ed1-b686-e02ac2da8157
2026-02-15T20:05:19.966393Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c5fed-5e04-78c0-9a4e-9fddc7af084e

thinking
**Inspecting file tree for parser**
codex
Implementing NUUM-2 by locating `src/inngest/functions/observe-parser.ts`, then Iâ€™ll add the new exported interface and parser function with focused changes and run `bunx tsc --noEmit` to verify compilation.
exec
/bin/zsh -lc 'ls -la src/inngest' in /private/tmp/agent-loop/loop-mlo6625k-jfz7xc/packages/system-busexec
/bin/zsh -lc 'rg --files' in /private/tmp/agent-loop/loop-mlo6625k-jfz7xc/packages/system-bus succeeded in 51ms:
total 24
drwxr-xr-x   4 joel  wheel    128 Feb 15 11:59 .
drwxr-xr-x   4 joel  wheel    128 Feb 15 11:59 ..
-rw-r--r--   1 joel  wheel  10081 Feb 15 11:59 client.ts
drwxr-xr-x  11 joel  wheel    352 Feb 15 12:03 functions
 succeeded in 51ms:
CONTINUATION-ADR.md
src/serve.ts
src/inngest/functions/transcript-process.ts
src/inngest/functions/index.ts
src/inngest/functions/video-download.ts
src/inngest/functions/summarize.ts
src/inngest/functions/observe-parser.ts
src/inngest/functions/system-logger.ts
src/inngest/functions/agent-loop/plan.ts
src/inngest/functions/agent-loop/llmEvaluate.test.ts
src/inngest/functions/agent-loop/judge.test.ts
src/inngest/functions/agent-loop/test-writer.test.ts
src/inngest/functions/agent-loop/test-writer.ts
src/inngest/functions/agent-loop/formatLoopDuration.test.ts
src/inngest/functions/agent-loop/review.test.ts
src/inngest/functions/agent-loop/index.ts
src/inngest/functions/agent-loop/getStoryDiff.test.ts
src/inngest/functions/agent-loop/parseClaudeOutput.test.ts
src/inngest/functions/agent-loop/review.ts
src/inngest/functions/agent-loop/utils.ts

thinking
**Reviewing parser and tests for failures**
codex
I found `observe-parser.ts` and related tests. Next Iâ€™m reading the parser file to add only the missing `DistilledSegment` and `parseSegments` exports without affecting existing behavior.
exec
/bin/zsh -lc "sed -n '1,240p' src/inngest/functions/observe-parser.ts" in /private/tmp/agent-loop/loop-mlo6625k-jfz7xc/packages/system-bus succeeded in 51ms:
export interface ObserverOutput {
  observations: string;
  currentTask: string | null;
  suggestedResponse: string | null;
  parsed: boolean;
}

export function optimizeForContext(observations: string): string {
  if (observations.trim().length === 0) {
    return "";
  }

  return observations
    .split(/\r?\n/)
    .filter((line) => {
      if (line.includes("ðŸŸ¡") || line.includes("ðŸŸ¢")) {
        return false;
      }

      return line.includes("ðŸ”´") || line.startsWith("Date:");

thinking
**Planning parsing approach and test review**
codex
Iâ€™m checking the existing NUUM-2 test expectations so the parser matches exact bullet parsing and tag handling on the first pass.
exec
/bin/zsh -lc "sed -n '1,260p' __tests__/nuum-2-parse-segments.test.ts" in /private/tmp/agent-loop/loop-mlo6625k-jfz7xc/packages/system-bus succeeded in 51ms:
import { describe, expect, test } from "bun:test";
import { mkdtemp, rm, writeFile } from "node:fs/promises";
import { join } from "node:path";
import { tmpdir } from "node:os";

async function loadObserveParserModule() {
  return import("../src/inngest/functions/observe-parser.ts");
}

describe("NUUM-2: observe-parser segment exports", () => {
  test("AC-1 and AC-2: exports DistilledSegment type contract and parseSegments function signature", async () => {
    const mod = await loadObserveParserModule();

    expect("parseSegments" in mod).toBe(true);
    expect(typeof mod.parseSegments).toBe("function");

    const tempDir = await mkdtemp(join(tmpdir(), "nuum-2-typecheck-"));
    try {
      const typecheckFile = join(tempDir, "distilled-segment-shape.ts");
      await writeFile(

thinking
**Designing robust bullet parsing**
codex
I confirmed the expected behavior: parse `<segment>` blocks, trim narrative text, and strip bullet markers from facts. Iâ€™m now patching `observe-parser.ts` with the new exported interface and function.
file update
M /private/tmp/agent-loop/loop-mlo6625k-jfz7xc/packages/system-bus/src/inngest/functions/observe-parser.ts
@@ -7,2 +7,7 @@
 
+export interface DistilledSegment {
+  narrative: string;
+  facts: string[];
+}
+
 export function optimizeForContext(observations: string): string {
@@ -41,2 +46,24 @@
 
+export function parseSegments(observations: string): DistilledSegment[] {
+  const segmentPattern = /<segment>([\s\S]*?)<\/segment>/gi;
+  const segments = observations.matchAll(segmentPattern);
+  const parsed: DistilledSegment[] = [];
+
+  for (const segmentMatch of segments) {
+    const segmentBody = segmentMatch[1] ?? "";
+    const narrative = (extractTagContent(segmentBody, "narrative") ?? "").trim();
+    const factsBody = extractTagContent(segmentBody, "facts") ?? "";
+    const facts = factsBody
+      .split(/\r?\n/)
+      .map((line) => line.trim())
+      .filter((line) => line.length > 0)
+      .map((line) => line.replace(/^[-*â€¢]\s*/, "").trim())
+      .filter((line) => line.length > 0);
+
+    parsed.push({ narrative, facts });
+  }
+
+  return parsed;
+}
+
 export function parseObserverOutput(raw: string): ObserverOutput {
apply_patch(auto_approved=true) exited 0 in 46ms:
Success. Updated the following files:
M /private/tmp/agent-loop/loop-mlo6625k-jfz7xc/packages/system-bus/src/inngest/functions/observe-parser.ts
file update:
diff --git a/packages/system-bus/src/inngest/functions/observe-parser.ts b/packages/system-bus/src/inngest/functions/observe-parser.ts
index 96dfefac98e41c1c19a4def78ab9ba7760e6a4cf..6f331f274f56efecde7998ac384e0623032526af
--- a/packages/system-bus/src/inngest/functions/observe-parser.ts
+++ b/packages/system-bus/src/inngest/functions/observe-parser.ts
@@ -5,6 +5,11 @@
   parsed: boolean;
 }
 
+export interface DistilledSegment {
+  narrative: string;
+  facts: string[];
+}
+
 export function optimizeForContext(observations: string): string {
   if (observations.trim().length === 0) {
     return "";
@@ -39,6 +44,28 @@
     .some((line) => line.includes("ðŸ”´") || line.includes("ðŸŸ¡") || line.includes("ðŸŸ¢"));
 }
 
+export function parseSegments(observations: string): DistilledSegment[] {
+  const segmentPattern = /<segment>([\s\S]*?)<\/segment>/gi;
+  const segments = observations.matchAll(segmentPattern);
+  const parsed: DistilledSegment[] = [];
+
+  for (const segmentMatch of segments) {
+    const segmentBody = segmentMatch[1] ?? "";
+    const narrative = (extractTagContent(segmentBody, "narrative") ?? "").trim();
+    const factsBody = extractTagContent(segmentBody, "facts") ?? "";
+    const facts = factsBody
+      .split(/\r?\n/)
+      .map((line) => line.trim())
+      .filter((line) => line.length > 0)
+      .map((line) => line.replace(/^[-*â€¢]\s*/, "").trim())
+      .filter((line) => line.length > 0);
+
+    parsed.push({ narrative, facts });
+  }
+
+  return parsed;
+}
+
 export function parseObserverOutput(raw: string): ObserverOutput {
   const trimmed = raw.trim();
   if (trimmed.length === 0) {

file update:
diff --git a/packages/system-bus/src/inngest/functions/observe-parser.ts b/packages/system-bus/src/inngest/functions/observe-parser.ts
index 96dfefac98e41c1c19a4def78ab9ba7760e6a4cf..6f331f274f56efecde7998ac384e0623032526af
--- a/packages/system-bus/src/inngest/functions/observe-parser.ts
+++ b/packages/system-bus/src/inngest/functions/observe-parser.ts
@@ -5,6 +5,11 @@
   parsed: boolean;
 }
 
+export interface DistilledSegment {
+  narrative: string;
+  facts: string[];
+}
+
 export function optimizeForContext(observations: string): string {
   if (observations.trim().length === 0) {
     return "";
@@ -39,6 +44,28 @@
     .some((line) => line.includes("ðŸ”´") || line.includes("ðŸŸ¡") || line.includes("ðŸŸ¢"));
 }
 
+export function parseSegments(observations: string): DistilledSegment[] {
+  const segmentPattern = /<segment>([\s\S]*?)<\/segment>/gi;
+  const segments = observations.matchAll(segmentPattern);
+  const parsed: DistilledSegment[] = [];
+
+  for (const segmentMatch of segments) {
+    const segmentBody = segmentMatch[1] ?? "";
+    const narrative = (extractTagContent(segmentBody, "narrative") ?? "").trim();
+    const factsBody = extractTagContent(segmentBody, "facts") ?? "";
+    const facts = factsBody
+      .split(/\r?\n/)
+      .map((line) => line.trim())
+      .filter((line) => line.length > 0)
+      .map((line) => line.replace(/^[-*â€¢]\s*/, "").trim())
+      .filter((line) => line.length > 0);
+
+    parsed.push({ narrative, facts });
+  }
+
+  return parsed;
+}
+
 export function parseObserverOutput(raw: string): ObserverOutput {
   const trimmed = raw.trim();
   if (trimmed.length === 0) {

codex
The code changes are in place. Iâ€™m running the TypeScript compile gate now (`bunx tsc --noEmit`) to verify AC-5.
exec
/bin/zsh -lc 'bunx tsc --noEmit' in /private/tmp/agent-loop/loop-mlo6625k-jfz7xc/packages/system-bus succeeded in 741ms:

file update:
diff --git a/packages/system-bus/src/inngest/functions/observe-parser.ts b/packages/system-bus/src/inngest/functions/observe-parser.ts
index 96dfefac98e41c1c19a4def78ab9ba7760e6a4cf..6f331f274f56efecde7998ac384e0623032526af
--- a/packages/system-bus/src/inngest/functions/observe-parser.ts
+++ b/packages/system-bus/src/inngest/functions/observe-parser.ts
@@ -5,6 +5,11 @@
   parsed: boolean;
 }
 
+export interface DistilledSegment {
+  narrative: string;
+  facts: string[];
+}
+
 export function optimizeForContext(observations: string): string {
   if (observations.trim().length === 0) {
     return "";
@@ -39,6 +44,28 @@
     .some((line) => line.includes("ðŸ”´") || line.includes("ðŸŸ¡") || line.includes("ðŸŸ¢"));
 }
 
+export function parseSegments(observations: string): DistilledSegment[] {
+  const segmentPattern = /<segment>([\s\S]*?)<\/segment>/gi;
+  const segments = observations.matchAll(segmentPattern);
+  const parsed: DistilledSegment[] = [];
+
+  for (const segmentMatch of segments) {
+    const segmentBody = segmentMatch[1] ?? "";
+    const narrative = (extractTagContent(segmentBody, "narrative") ?? "").trim();
+    const factsBody = extractTagContent(segmentBody, "facts") ?? "";
+    const facts = factsBody
+      .split(/\r?\n/)
+      .map((line) => line.trim())
+      .filter((line) => line.length > 0)
+      .map((line) => line.replace(/^[-*â€¢]\s*/, "").trim())
+      .filter((line) => line.length > 0);
+
+    parsed.push({ narrative, facts });
+  }
+
+  return parsed;
+}
+
 export function parseObserverOutput(raw: string): ObserverOutput {
   const trimmed = raw.trim();
   if (trimmed.length === 0) {

exec
/bin/zsh -lc "nl -ba src/inngest/functions/observe-parser.ts | sed -n '1,220p'" in /private/tmp/agent-loop/loop-mlo6625k-jfz7xc/packages/system-bus succeeded in 52ms:
     1	export interface ObserverOutput {
     2	  observations: string;
     3	  currentTask: string | null;
     4	  suggestedResponse: string | null;
     5	  parsed: boolean;
     6	}
     7	
     8	export interface DistilledSegment {
     9	  narrative: string;
    10	  facts: string[];
    11	}
    12	
    13	export function optimizeForContext(observations: string): string {
    14	  if (observations.trim().length === 0) {
    15	    return "";
    16	  }
    17	
    18	  return observations
    19	    .split(/\r?\n/)
    20	    .filter((line) => {
file update:
diff --git a/packages/system-bus/src/inngest/functions/observe-parser.ts b/packages/system-bus/src/inngest/functions/observe-parser.ts
index 96dfefac98e41c1c19a4def78ab9ba7760e6a4cf..6f331f274f56efecde7998ac384e0623032526af
--- a/packages/system-bus/src/inngest/functions/observe-parser.ts
+++ b/packages/system-bus/src/inngest/functions/observe-parser.ts
@@ -5,6 +5,11 @@
   parsed: boolean;
 }
 
+export interface DistilledSegment {
+  narrative: string;
+  facts: string[];
+}
+
 export function optimizeForContext(observations: string): string {
   if (observations.trim().length === 0) {
     return "";
@@ -39,6 +44,28 @@
     .some((line) => line.includes("ðŸ”´") || line.includes("ðŸŸ¡") || line.includes("ðŸŸ¢"));
 }
 
+export function parseSegments(observations: string): DistilledSegment[] {
+  const segmentPattern = /<segment>([\s\S]*?)<\/segment>/gi;
+  const segments = observations.matchAll(segmentPattern);
+  const parsed: DistilledSegment[] = [];
+
+  for (const segmentMatch of segments) {
+    const segmentBody = segmentMatch[1] ?? "";
+    const narrative = (extractTagContent(segmentBody, "narrative") ?? "").trim();
+    const factsBody = extractTagContent(segmentBody, "facts") ?? "";
+    const facts = factsBody
+      .split(/\r?\n/)
+      .map((line) => line.trim())
+      .filter((line) => line.length > 0)
+      .map((line) => line.replace(/^[-*â€¢]\s*/, "").trim())
+      .filter((line) => line.length > 0);
+
+    parsed.push({ narrative, facts });
+  }
+
+  return parsed;
+}
+
 export function parseObserverOutput(raw: string): ObserverOutput {
   const trimmed = raw.trim();
   if (trimmed.length === 0) {

codex
Implemented NUUM-2 in `src/inngest/functions/observe-parser.ts`.

### Changes made
- Added exported `DistilledSegment` interface with:
  - `narrative: string`
  - `facts: string[]`
  - (`src/inngest/functions/observe-parser.ts:8`)
- Added exported `parseSegments(observations: string): DistilledSegment[]` that:
  - Extracts all `<segment>...</segment>` blocks
  - Reads `<narrative>` and trims content
  - Reads `<facts>`, splits lines, trims each bullet, strips bullet markers (`-`, `*`, `â€¢`)
  - Returns `[]` when no segments are present
  - (`src/inngest/functions/observe-parser.ts:47`)

### Verification
- Ran `bunx tsc --noEmit` successfully (exit code `0`).
file update:
diff --git a/packages/system-bus/src/inngest/functions/observe-parser.ts b/packages/system-bus/src/inngest/functions/observe-parser.ts
index 96dfefac98e41c1c19a4def78ab9ba7760e6a4cf..6f331f274f56efecde7998ac384e0623032526af
--- a/packages/system-bus/src/inngest/functions/observe-parser.ts
+++ b/packages/system-bus/src/inngest/functions/observe-parser.ts
@@ -5,6 +5,11 @@
   parsed: boolean;
 }
 
+export interface DistilledSegment {
+  narrative: string;
+  facts: string[];
+}
+
 export function optimizeForContext(observations: string): string {
   if (observations.trim().length === 0) {
     return "";
@@ -39,6 +44,28 @@
     .some((line) => line.includes("ðŸ”´") || line.includes("ðŸŸ¡") || line.includes("ðŸŸ¢"));
 }
 
+export function parseSegments(observations: string): DistilledSegment[] {
+  const segmentPattern = /<segment>([\s\S]*?)<\/segment>/gi;
+  const segments = observations.matchAll(segmentPattern);
+  const parsed: DistilledSegment[] = [];
+
+  for (const segmentMatch of segments) {
+    const segmentBody = segmentMatch[1] ?? "";
+    const narrative = (extractTagContent(segmentBody, "narrative") ?? "").trim();
+    const factsBody = extractTagContent(segmentBody, "facts") ?? "";
+    const facts = factsBody
+      .split(/\r?\n/)
+      .map((line) => line.trim())
+      .filter((line) => line.length > 0)
+      .map((line) => line.replace(/^[-*â€¢]\s*/, "").trim())
+      .filter((line) => line.length > 0);
+
+    parsed.push({ narrative, facts });
+  }
+
+  return parsed;
+}
+
 export function parseObserverOutput(raw: string): ObserverOutput {
   const trimmed = raw.trim();
   if (trimmed.length === 0) {

tokens used
23,031
