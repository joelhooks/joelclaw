---
title: "Why I Built My Own AI System Instead of Deploying OpenClaw"
date: "2026-02-14"
description: "OpenClaw is impressive â€” 100+ skills, multi-channel messaging, built-in memory. But after building the infrastructure, I realized I'd already gone deeper than what it provides."
---

There's a moment in every infrastructure project where you stop and ask: _do I still need the thing I thought I was building toward?_

For me, that thing was [OpenClaw](https://github.com/openclaw/openclaw) â€” Peter Steinberger's self-hosted AI assistant framework. The vision is compelling: an agent-as-OS with messaging integration, 100+ skills, and a unified gateway. I was planning to deploy it as the orchestration layer for my personal AI system.

Then I looked at what I'd already built. And I kind of laughed. ðŸ˜…

## The infrastructure I didn't plan

Six sessions of "just setting up infrastructure" produced something I wasn't expecting. Not a deployment target for OpenClaw â€” a system that had already gone deeper in every overlapping layer:

| Layer             | What I built                                                       | What OpenClaw provides  |
| ----------------- | ------------------------------------------------------------------ | ----------------------- |
| **Event bus**     | Inngest â€” durable workflows, event chains, step functions, retries | Basic job queue         |
| **Search**        | Qdrant â€” hybrid dense + sparse + BM25, RRF fusion                 | SQLite + vectors        |
| **State**         | Redis â€” persistent cache, dedup, pub/sub                           | No equivalent           |
| **Observability** | slog + igs â€” Effect CLIs, HATEOAS JSON                             | JSONL transcripts       |
| **Network**       | Tailscale mesh + Caddy HTTPS                                       | localhost + SSH tunnels |
| **Pipelines**     | Video download â†’ transcript â†’ summarize (event chain)              | No media pipeline       |

The gap wasn't "I need to catch up to OpenClaw." It was "deploying OpenClaw would mean running two of everything."

That's not a path. That's a mess.

## When your tools go blind

OpenClaw's Gateway owns the agent loop. When something breaks, you're reading _their_ code, not yours. And here's the thing â€” every layer should be inspectable with tools you built. That's the whole fucking point of self-hosting.

My observability tools (`slog`, `igs`) are designed for _my_ infrastructure. Adding someone else's orchestrator means those tools go blind in the most critical layer. I can't see what the agent is doing. I can't debug why a step failed. I'm back to reading someone else's logs and hoping.

I've done that dance enough times to know how it ends.

## Memory is the moat

The real differentiator isn't the infrastructure. It's the memory architecture.

OpenClaw has `MEMORY.md` and basic vector search. That's a starting point. What I designed is a 4-layer system:

1. **Session recall** (kuato-style) â€” what happened in recent conversations
2. **Playbook** (lamarck-style) â€” patterns extracted from repeated work
3. **Timeline** (andy-style) â€” narrative history of what was built and why
4. **Soul** â€” identity, values, personality that persists across everything

Each layer is backed by Qdrant hybrid search (dense + BM25 + RRF). Each layer writes to the PDS as typed records. None of this fits inside OpenClaw's memory model â€” and frankly, **memory is the thing that makes an AI system _yours_**. It's not something I want to cram into someone else's abstraction.

## Credit where it's due

OpenClaw shaped the vision. The idea of a self-hosted agent-as-OS with messaging as the primary interface â€” that's Peter Steinberger's contribution, and it's the right vision. I wouldn't be building what I'm building without seeing what he put together.

The implementation is mine. That's not a criticism. It's an architectural decision.

Sometimes you learn the most from the thing you almost used. ðŸ”¥

---

_This is the first in a series about building a personal AI operating system from scratch. Next: [AT Protocol as the bedrock for personal AI](/at-protocol-as-bedrock)._
