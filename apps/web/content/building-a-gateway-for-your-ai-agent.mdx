---
title: "Building a Gateway for Your AI Agent"
date: "2026-02-18"
description: "From ephemeral terminal sessions to an always-on gateway. Event routing, heartbeat monitoring, failure detection, and Telegram access â€” for an AI agent running on your Mac."
---

## Set it up

**Prerequisite:** [Self-hosted Inngest](/self-hosting-inngest-background-tasks) + Redis.

**For agents** â€” install the skill and it walks through the full build adapted to your machine and intent:

```bash
npx skills add joelhooks/joelclaw --skill gateway-setup --yes --global
```

The skill contains the compressed ADR chain with all tradeoffs â€” [ADR-0018](/adrs/0018-pi-native-gateway-redis-event-bridge) through [ADR-0038](/adrs/0038-embedded-pi-gateway-daemon) â€” so your agent has the full reasoning context.

**Or curl the setup script:**

```bash
curl -fsSL https://joelclaw.com/scripts/gateway-setup.sh | bash
```

{/* TODO: Video â€” "Building an Agent Gateway on macOS"
Pitch: Screen recording. Show the problem first â€” close terminal, events pile up in Redis with nobody listening. Then build the solution live:
1. Install the gateway extension, restart pi, show ğŸ”— status
2. Push a test event via redis-cli, watch it appear in the session
3. Start a second pi session (satellite), show heartbeats only go to central
4. Kill the Inngest worker, wait 30 min (timelapse), show watchdog alarm fire
5. Send a message from Telegram, get a response from the agent
6. Show the full event flow: Inngest â†’ Redis â†’ gateway extension â†’ pi session â†’ response â†’ Telegram
Runtime: ~12-15 minutes. Terminal + Telegram side-by-side for the mobile demo.
Split into chapters with timestamps.
*/}

---

## The problem

Close the terminal and your agent disappears.

Not because the work stopped. Because your only control plane just evaporated. Background jobs finish. Loops complete. But nothing can tap you on the shoulder and say your shit is done.<Sidenote id="sn-context-budget">This burns context budget too. Every interrupt eats tokens from whatever the agent was actually working on. The gateway solves routing â€” only the right session gets the message.</Sidenote>

I wanted three things: an **always-on session** that handles system heartbeats, **targeted notifications** back to whichever session started a task, and **phone access** when I'm away from the keyboard.

## What it is

A Redis event bridge between your background infrastructure ([Inngest](/self-hosting-inngest-background-tasks), cron, webhooks) and your AI agent's session. Events route to the right session. Failures get detected. Responses go back through the channel that asked.

```
Inngest functions â”€â”€â†’ Redis â”€â”€â†’ pi extension â”€â”€â†’ agent session
                                     â†‘
                              pub/sub notify
```

## The evolution (4 iterations)

I didn't design this upfront. Each iteration solved a real problem.

### v1: Redis bridge

Inngest functions push events to a Redis list. A pi extension subscribes to a pub/sub channel and drains the list into the session as a user message.<Sidenote id="sn-redis-choice">Why Redis and not a proper message queue? Because it was already running for caching, the pub/sub semantics are good enough for single-machine fan-out, and adding RabbitMQ or NATS for one consumer felt like architecture theater.</Sidenote> ~100 lines of TypeScript.

**Solved:** background jobs can notify the agent.

### v2: Multi-session routing

Problem: I run 3-5 pi sessions simultaneously. Heartbeats were interrupting coding sessions.

Solution: one **central** session (gets all events) + **satellite** sessions (get only events they started). Sessions register in a Redis set. Events fan out based on `originSession` tracking.

```
GATEWAY_ROLE=central pi  â†’  gets heartbeats, alerts, everything
pi                       â†’  gets only its own loop completions, downloads
```

**Solved:** context budgets aren't wasted on irrelevant notifications.

### v3: Heartbeat + watchdog

An Inngest cron fires every 15 minutes. The gateway extension tracks when the last heartbeat arrived. If 30 minutes pass with nothing â€” inject an alarm with triage steps.

Three independent failure detection layers: extension watchdog catches Inngest/worker failures. A launchd tripwire catches pi crashes. The heartbeat prompt itself runs system health checks.<Sidenote id="sn-watchmen">The "who watches the watchmen" problem is real. Each layer fails independently: Inngest can crash, the worker can hang, the extension can lose Redis, launchd can restart too aggressively. Three uncorrelated monitors is the minimum.</Sidenote>

**Solved:** "who watches the watchmen" â€” more than one watcher.

### v4: Gateway middleware SDK

Every Inngest function gets `gateway.progress()`, `gateway.notify()`, and `gateway.alert()` injected via middleware. Functions don't need to know about Redis or routing.

```typescript
async ({ event, step, gateway }) => {
  gateway.progress("Story 3/8 started: implement auth");
  // ... do work ...
  gateway.notify("loop.complete", { stories: 8, passed: 7 });
}
```

**Solved:** functions push status updates without coupling to the delivery mechanism.

## What's next: embedded daemon + Telegram

The extension gets me far. The next step is a standalone daemon that embeds pi as a library â€” no terminal needed.<MarginNote id="mn-daemon">This is done now. The daemon runs via launchd with `KeepAlive: true`. `joelclaw gateway restart` rolls the session cleanly.</MarginNote> Telegram as the first external channel. WebSocket for remote TUI. All inputs serialize through one command queue into one session.

Talk to the agent from your phone. Get responses back in the same thread.

## The full stack

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Inngest server  â”‚  cron heartbeat, durable functions
â”‚  (k8s/Docker)    â”‚  every 15 min + event-driven
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚ step.run â†’ pushGatewayEvent()
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     Redis        â”‚  event lists, pub/sub, session registry
â”‚  (k8s/Docker)    â”‚  joelclaw:events:*, joelclaw:notify:*
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚ subscribe + drain
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  pi extension    â”‚  central/satellite routing
â”‚  (gateway)       â”‚  watchdog, dedup, prompt injection
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚ sendUserMessage()
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  pi session      â”‚  LLM conversation
â”‚  (agent)         â”‚  tools, memory, skills
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## For humans

The deeper architecture narrative is in [Inngest is the Nervous System](/inngest-is-the-nervous-system). For the k8s foundation: [The One Where Joel Deploys Kubernetes... Again](/joel-deploys-k8s).

---

*This is a living document. Updated as the system evolves.*
