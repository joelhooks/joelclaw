{
  "title": "ADR-0016: Idempotency guards for loop event chain",
  "adr": "0016-loop-idempotency-guards.md",
  "stories": [
    {
      "id": "GUARD-1",
      "title": "seedPrd NX guard — prevent state clobber on duplicate start",
      "description": "Change seedPrd() in utils.ts to use Redis SET NX (set-if-not-exists). If the key already exists, read and return the existing PRD instead of overwriting. This prevents a duplicate agent/loop.start event from clobbering passed/skipped state from an in-flight loop.",
      "acceptance_criteria": [
        "seedPrd uses SET NX EX (not unconditional SET) when writing to Redis",
        "If key already exists, seedPrd returns the existing PRD from Redis (not disk)",
        "Existing behavior preserved: first call seeds from disk, sets 7-day TTL",
        "TypeScript compiles cleanly: bunx tsc --noEmit"
      ],
      "priority": 1,
      "passes": false
    },
    {
      "id": "GUARD-2",
      "title": "Add claimStory/guardStory/renewLease/releaseClaim helpers to utils.ts",
      "description": "Add four new functions to utils.ts: (1) claimStory(loopId, storyId, runToken) — uses Redis SET NX EX to atomically claim a story. Returns token if claimed, null if already claimed. Key: agent-loop:claim:{loopId}:{storyId}, TTL 1800s. (2) guardStory(loopId, storyId, runToken) — reads claim key and PRD, returns {ok:true} if we still hold the lease and story isn't passed, or {ok:false, reason} otherwise. (3) renewLease(loopId, storyId, runToken) — refreshes TTL if we still own the key. (4) releaseClaim(loopId, storyId) — deletes the claim key.",
      "acceptance_criteria": [
        "claimStory uses SET NX EX with 1800s TTL",
        "claimStory returns runToken on success, null if key already exists",
        "guardStory returns {ok:false, reason:'already_claimed'} if different token holds the key",
        "guardStory returns {ok:false, reason:'already_passed'} if story.passes is true in Redis PRD",
        "guardStory returns {ok:false, reason:'lease_expired'} if claim key doesn't exist",
        "renewLease refreshes TTL only if current token matches",
        "releaseClaim deletes the claim key",
        "All functions exported from utils.ts",
        "TypeScript compiles cleanly: bunx tsc --noEmit"
      ],
      "priority": 2,
      "passes": false
    },
    {
      "id": "GUARD-3",
      "title": "Wire claimStory into plan.ts",
      "description": "In plan.ts, after selecting the next story and before emitting agent/loop.test, call claimStory(loopId, storyId, runToken) where runToken is a generated ULID. If claim fails (returns null), skip this story and try the next pending one. If no stories can be claimed, emit agent/loop.complete. Pass the runToken through the event data so downstream functions can use guardStory.",
      "acceptance_criteria": [
        "plan.ts calls claimStory before emitting agent/loop.test",
        "If claimStory returns null, plan skips to next pending story",
        "If no stories can be claimed, plan emits agent/loop.complete",
        "runToken is included in the emitted event data",
        "Existing cancellation and maxIterations logic preserved",
        "TypeScript compiles cleanly: bunx tsc --noEmit"
      ],
      "priority": 3,
      "passes": false
    },
    {
      "id": "GUARD-4",
      "title": "Wire guardStory into implement.ts, test-writer.ts, review.ts, judge.ts",
      "description": "Add guardStory checks at key side-effect boundaries in all downstream functions: (1) test-writer.ts: guard before spawning tool, (2) implement.ts: guard before spawning tool AND before git commit AND before emitting review, (3) review.ts: guard before evaluation, (4) judge.ts: guard before writing verdict. Each guard reads runToken from event.data. If guard fails, return early with status indicating why (already_claimed, already_passed, lease_expired). Also call renewLease after each successful step to prevent TTL expiry during long runs.",
      "acceptance_criteria": [
        "test-writer.ts calls guardStory before spawning tool",
        "implement.ts calls guardStory before tool spawn, before commit, and before emit",
        "review.ts calls guardStory before evaluation",
        "judge.ts calls guardStory before writing verdict",
        "All functions read runToken from event.data",
        "All functions call renewLease after successful steps",
        "Guard failure returns early with descriptive status object",
        "TypeScript compiles cleanly: bunx tsc --noEmit"
      ],
      "priority": 4,
      "passes": false
    },
    {
      "id": "GUARD-5",
      "title": "Wire releaseClaim into judge.ts on pass/skip",
      "description": "In judge.ts, after marking a story as passed (updateStoryPass) or skipped (markStorySkipped), call releaseClaim(loopId, storyId) to free the lease. This allows retried or parallel chains to detect the story is done via guardStory (which checks PRD passes status).",
      "acceptance_criteria": [
        "judge.ts calls releaseClaim after updateStoryPass",
        "judge.ts calls releaseClaim after markStorySkipped",
        "releaseClaim is called before emitting agent/loop.plan for next story",
        "Existing retry ladder and skip logic preserved",
        "TypeScript compiles cleanly: bunx tsc --noEmit"
      ],
      "priority": 5,
      "passes": false
    }
  ]
}
