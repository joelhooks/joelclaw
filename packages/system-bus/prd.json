{
  "title": "ADR-0021 Phase 1 Loop A: Memory Event Types + Observer Prompt + Parser",
  "stories": [
    {
      "id": "MEM-1",
      "title": "Add memory event types to client.ts",
      "description": "Add 4 new memory event types to the Events type in src/inngest/client.ts, following the existing pattern for event type declarations. Add these events:\n\n1. \"memory/session.compaction.pending\" with data: { sessionId: string, dedupeKey: string, trigger: \"compaction\", messages: string, messageCount: number, tokensBefore: number, filesRead: string[], filesModified: string[], capturedAt: string, schemaVersion: 1 }\n\n2. \"memory/session.ended\" with data: { sessionId: string, dedupeKey: string, trigger: \"shutdown\", messages: string, messageCount: number, userMessageCount: number, duration: number, sessionName?: string, filesRead: string[], filesModified: string[], capturedAt: string, schemaVersion: 1 }\n\n3. \"memory/observations.accumulated\" with data: { date: string, totalTokens: number, observationCount: number, capturedAt: string }\n\n4. \"memory/observations.reflected\" with data: { date: string, inputTokens: number, outputTokens: number, compressionRatio: number, proposalCount: number, capturedAt: string }\n\nThe schemaVersion fields on the session events must be literal type 1 (not number). Follow the exact naming and structure conventions already used in the file.",
      "acceptance_criteria": [
        "src/inngest/client.ts exports Events type containing 'memory/session.compaction.pending' with all specified data fields",
        "src/inngest/client.ts exports Events type containing 'memory/session.ended' with all specified data fields including optional sessionName",
        "src/inngest/client.ts exports Events type containing 'memory/observations.accumulated' with all specified data fields",
        "src/inngest/client.ts exports Events type containing 'memory/observations.reflected' with all specified data fields",
        "schemaVersion fields on session events are literal type 1, not number",
        "TypeScript compiles cleanly: bunx tsc --noEmit"
      ],
      "priority": 1,
      "passes": true
    },
    {
      "id": "MEM-2",
      "title": "Create observer system prompt constant",
      "description": "Create src/inngest/functions/observe-prompt.ts exporting OBSERVER_SYSTEM_PROMPT as a string constant. The prompt instructs an LLM to act as a session observer that extracts structured observations from Claude Code session transcripts. The prompt must specify:\n\n- Role: silent observer extracting reusable knowledge from session transcripts\n- Priority markers: ðŸ”´ (high â€” corrections, user preferences, system facts), ðŸŸ¡ (medium â€” patterns, repeated actions), ðŸŸ¢ (low â€” minor notes)\n- Temporal anchoring: each observation group prefixed with 'Date: YYYY-MM-DD'\n- Output format: XML with three tags:\n  - <observations> (required) â€” the extracted observations with priority emoji markers, one per line\n  - <current-task> (optional) â€” what the user is currently working on\n  - <suggested-response> (optional) â€” a suggested greeting/context for next session\n- Instructions to focus on facts over opinions, prefer specific over vague, and deduplicate\n\nThis file should have no dependencies beyond standard TypeScript.",
      "acceptance_criteria": [
        "src/inngest/functions/observe-prompt.ts exists and exports OBSERVER_SYSTEM_PROMPT as a string constant",
        "OBSERVER_SYSTEM_PROMPT contains instructions for ðŸ”´ high, ðŸŸ¡ medium, ðŸŸ¢ low priority markers",
        "OBSERVER_SYSTEM_PROMPT specifies XML output format with <observations>, <current-task>, <suggested-response> tags",
        "OBSERVER_SYSTEM_PROMPT includes temporal anchoring with 'Date: YYYY-MM-DD' instruction",
        "TypeScript compiles cleanly: bunx tsc --noEmit"
      ],
      "priority": 2,
      "passes": true
    },
    {
      "id": "MEM-3",
      "title": "Create observer user prompt function",
      "description": "In src/inngest/functions/observe-prompt.ts, add and export OBSERVER_USER_PROMPT as a function with signature: (messages: string, trigger: string, sessionName?: string) => string.\n\nThe function should return a prompt that:\n- Includes the trigger type (e.g., 'compaction' or 'shutdown') so the observer knows context\n- Includes the optional sessionName if provided\n- Embeds the messages string as the transcript to analyze\n- Asks the observer to extract observations following the system prompt format\n\nKeep the template simple and clear. The messages parameter contains the raw session transcript.",
      "acceptance_criteria": [
        "src/inngest/functions/observe-prompt.ts exports OBSERVER_USER_PROMPT as a function",
        "OBSERVER_USER_PROMPT accepts (messages: string, trigger: string, sessionName?: string) and returns string",
        "Returned string includes the trigger value",
        "Returned string includes sessionName when provided",
        "Returned string embeds the messages content",
        "TypeScript compiles cleanly: bunx tsc --noEmit"
      ],
      "priority": 3,
      "passes": true
    },
    {
      "id": "MEM-4",
      "title": "Create ObserverOutput interface and parseObserverOutput function",
      "description": "Create src/inngest/functions/observe-parser.ts exporting:\n\n1. interface ObserverOutput { observations: string; currentTask: string | null; suggestedResponse: string | null; parsed: boolean }\n\n2. parseObserverOutput(raw: string): ObserverOutput â€” Parses LLM output that may contain XML tags. Logic:\n   - Try to extract content from <observations>...</observations>, <current-task>...</current-task>, <suggested-response>...</suggested-response> XML tags\n   - If <observations> tag is found, set parsed=true and extract available tags (currentTask and suggestedResponse may be absent)\n   - If no XML tags found, fall back: check if lines contain ðŸ”´, ðŸŸ¡, or ðŸŸ¢ emoji markers. If so, use the full raw text as observations, set parsed=true\n   - If nothing matches (malformed/random text), return { observations: raw, currentTask: null, suggestedResponse: null, parsed: false }\n   - Empty/whitespace input returns { observations: '', currentTask: null, suggestedResponse: null, parsed: false }\n   - Trim whitespace from extracted content",
      "acceptance_criteria": [
        "src/inngest/functions/observe-parser.ts exports ObserverOutput interface with observations (string), currentTask (string | null), suggestedResponse (string | null), parsed (boolean)",
        "src/inngest/functions/observe-parser.ts exports parseObserverOutput function",
        "parseObserverOutput extracts content from XML tags when present",
        "parseObserverOutput falls back to emoji-marker detection when no XML tags found",
        "parseObserverOutput returns raw text with parsed=false for unrecognized input",
        "parseObserverOutput returns empty observations with parsed=false for empty input",
        "TypeScript compiles cleanly: bunx tsc --noEmit"
      ],
      "priority": 4,
      "passes": true
    },
    {
      "id": "MEM-5",
      "title": "Create optimizeForContext function",
      "description": "In src/inngest/functions/observe-parser.ts, add and export:\n\noptimizeForContext(observations: string): string â€” Filters observation text to keep only high-priority items for context-window efficiency. Logic:\n- Split input into lines\n- Keep only lines that start with or contain ðŸ”´ (high priority marker) OR lines that start with 'Date:' (temporal headers)\n- Discard all lines with ðŸŸ¡ or ðŸŸ¢ markers and any other lines\n- Join remaining lines with newline\n- Trim the result\n- Empty input returns empty string",
      "acceptance_criteria": [
        "src/inngest/functions/observe-parser.ts exports optimizeForContext function",
        "optimizeForContext keeps lines containing ðŸ”´ emoji",
        "optimizeForContext keeps lines starting with 'Date:'",
        "optimizeForContext removes lines containing ðŸŸ¡ or ðŸŸ¢",
        "optimizeForContext returns empty string for empty input",
        "TypeScript compiles cleanly: bunx tsc --noEmit"
      ],
      "priority": 5,
      "passes": true
    },
    {
      "id": "MEM-6",
      "title": "Write tests for observe-parser",
      "description": "Create src/inngest/functions/observe-parser.test.ts with tests using bun:test (import { test, expect, describe } from 'bun:test'). Test cases:\n\n1. parseObserverOutput â€” XML extraction: input with all 3 XML tags (<observations>, <current-task>, <suggested-response>) returns parsed=true with all fields extracted and trimmed\n2. parseObserverOutput â€” Partial XML: input with only <observations> tag returns parsed=true, currentTask=null, suggestedResponse=null\n3. parseObserverOutput â€” Fallback: input with no XML but lines containing ðŸ”´ðŸŸ¡ðŸŸ¢ markers returns parsed=true, observations=raw text\n4. parseObserverOutput â€” Malformed: random text with no markers returns parsed=false, observations=raw text\n5. parseObserverOutput â€” Empty input: returns observations='', currentTask=null, suggestedResponse=null, parsed=false\n6. optimizeForContext â€” Mixed priorities: input with ðŸ”´, ðŸŸ¡, ðŸŸ¢ lines and Date: headers â†’ only ðŸ”´ and Date: lines survive\n7. optimizeForContext â€” Empty input: returns empty string\n\nAll tests must pass with: bun test src/inngest/functions/observe-parser.test.ts",
      "acceptance_criteria": [
        "src/inngest/functions/observe-parser.test.ts exists with all 7 test cases",
        "Tests import from ./observe-parser (relative import)",
        "Tests use bun:test (import { test, expect, describe } from 'bun:test')",
        "All tests pass: bun test src/inngest/functions/observe-parser.test.ts",
        "Tests verify observable behavior, not implementation details",
        "TypeScript compiles cleanly: bunx tsc --noEmit"
      ],
      "priority": 6,
      "passes": false
    }
  ]
}
