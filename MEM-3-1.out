Implemented MEM-3 with event-driven promotion flow.

### What changed

- Rewrote `packages/system-bus/src/inngest/functions/promote.ts` to remove all REVIEW parsing/file coupling:
  - Removed `parseReviewMd`, `getReviewPath`, `removeProposalFromReview`, `extractContentPath`.
  - Removed all `content/updated` trigger logic.
  - Removed all `removeProposalFromReview()` calls from:
    - `promoteToMemory` (`packages/system-bus/src/inngest/functions/promote.ts:247`)
    - `archiveProposal` (`packages/system-bus/src/inngest/functions/promote.ts:282`)
    - `expireProposal` (`packages/system-bus/src/inngest/functions/promote.ts:297`)
- Added event-driven triggers on the `promote` Inngest function:
  - `memory/proposal.approved` -> `promoteToMemory(event.data.proposalId)` (`packages/system-bus/src/inngest/functions/promote.ts:320`)
  - `memory/proposal.rejected` -> `archiveProposal(event.data.proposalId, event.data.reason)` (`packages/system-bus/src/inngest/functions/promote.ts:320`)
- Retained cron trigger:
  - `0 8 * * *` and it now iterates `LRANGE memory:review:pending`, calling `expireProposal()` for IDs older than 7 days (`packages/system-bus/src/inngest/functions/promote.ts:352`)
- Ensured public exports remain:
  - `promoteToMemory`, `archiveProposal`, `expireProposal` are exported (`packages/system-bus/src/inngest/functions/promote.ts:247`, `packages/system-bus/src/inngest/functions/promote.ts:282`, `packages/system-bus/src/inngest/functions/promote.ts:297`)

### Test updates

- `packages/system-bus/src/inngest/functions/promote.test.ts` is already aligned to the new event-driven trigger behavior.
- Updated legacy integration coverage to the new interface:
  - `packages/system-bus/src/inngest/functions/promote-integration.test.ts:223`
  - Now drives approved/rejected/cron events instead of `content/updated`.

### Verification

- `bun test packages/system-bus/src/inngest/functions/promote.test.ts` -> **6 pass, 0 fail**
- `bunx tsc --noEmit` -> **passes cleanly**
- Also checked:
  - `bun test packages/system-bus/src/inngest/functions/promote-integration.test.ts` -> **1 pass, 0 fail**


--- STDERR ---
OpenAI Codex v0.101.0 (research preview)
--------
workdir: /private/tmp/agent-loop/loop-mlr8oxtg-b68bp4
model: gpt-5.3-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: none
reasoning summaries: auto
session id: 019c6dfe-0a28-7651-8448-5be66f03a215
--------
user


## Project File Listing

pnpm-lock.yaml
infra
vercel.json
k8s
turbo.json
node_modules
bun.lock
docs
README.md
pid
package.json
scripts
packages
MEM-2-1.out
tsconfig.json
prd.json
apps
Vault
MEM-1-1.out
pnpm-workspace.yaml

---

## Story: Rewrite promote.ts to be event-driven, remove REVIEW.md parsing (MEM-3)

In packages/system-bus/src/inngest/functions/promote.ts, remove all REVIEW.md file reading/parsing: delete parseReviewMd(), getReviewPath(), removeProposalFromReview(), extractContentPath(), and the content/updated trigger. Add two new Inngest function triggers: one for 'memory/proposal.approved' that calls promoteToMemory(event.data.proposalId), and one for 'memory/proposal.rejected' that calls archiveProposal(event.data.proposalId, event.data.reason). Keep the cron '0 8 * * *' trigger for auto-expiry of proposals older than 7 days (iterate LRANGE memory:review:pending, call expireProposal() for those older than 7 days). Remove any removeProposalFromReview() calls from promoteToMemory(), archiveProposal(), and expireProposal(). Export promoteToMemory, archiveProposal, and expireProposal. Update promote.test.ts to test the new event-driven triggers instead of checkbox-driven ones.

## Acceptance Criteria
- No references to REVIEW.md, parseReviewMd, getReviewPath, removeProposalFromReview, or content/updated remain in promote.ts
- promote.ts registers handlers for memory/proposal.approved and memory/proposal.rejected events
- The daily 8 AM cron trigger is retained for auto-expiry
- promoteToMemory, archiveProposal, and expireProposal are exported from promote.ts
- bun test src/inngest/functions/promote.test.ts passes with 0 failures
- TypeScript compiles cleanly: bunx tsc --noEmit

## Instructions
Implement the story above. Do NOT write tests — a separate reviewer will handle testing.
Make clean, focused changes. Commit nothing — the harness handles git.
If your changes break existing tests (not just the ones for this story), fix those tests to match the new interface. Changing a type or adding a required field means updating all consumers.
mcp startup: no servers
2026-02-17T23:44:51.291612Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c6d78-f4bd-70a3-9b26-6d401f72555d
2026-02-17T23:44:51.323977Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c6a38-72b9-7fd3-aae0-de7058d752e1
2026-02-17T23:44:51.448410Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c6dfc-ce2b-7351-9877-3cf3dfd942e0
2026-02-17T23:44:51.494185Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c5eca-bff9-7772-83bf-5daab07b9959
2026-02-17T23:44:51.577324Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c5ffd-d51d-7a13-b1fa-342be02f164b
2026-02-17T23:44:51.651147Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c6275-d69e-7b53-bb28-583bfe07e70c
2026-02-17T23:44:51.783679Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c6d76-b1ac-7312-a2bc-33ed66270397
2026-02-17T23:44:51.904349Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c6946-d832-73b3-bade-761321c88a0a
2026-02-17T23:44:52.068303Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c6d85-da78-7b62-99df-11a605673333
2026-02-17T23:44:52.137696Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c6bed-25bc-7141-bf68-7df6c001174c
2026-02-17T23:44:52.256403Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c6a5b-ba72-7f61-8273-d02deacae15e
2026-02-17T23:44:52.369237Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c6482-5bab-7e53-bc62-5239d048a3c8
2026-02-17T23:44:52.519940Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c6a51-1205-7a00-bbdb-509c1624de3d
2026-02-17T23:44:52.632333Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c6a59-ea9c-73e1-b537-9ad62ea24fd1
2026-02-17T23:44:52.747434Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c6d85-394c-7a22-a0ba-b3f326504c0f
2026-02-17T23:44:52.864186Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c6485-58f0-7261-8508-37f3fb9356dd
2026-02-17T23:44:52.993761Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c695b-193b-7040-9529-153a24848595
2026-02-17T23:44:53.123900Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c6031-b7fb-7120-85b5-8abf34324910
2026-02-17T23:44:53.196151Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c5fe2-872d-7e93-87a3-71d37d75a127
2026-02-17T23:44:53.265623Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c6d46-f863-7a62-8f46-d697792894dd
2026-02-17T23:44:53.347602Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c6a5d-a9a0-7003-8868-edeb59f5a8e9
2026-02-17T23:44:53.433438Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c6a4f-9a4d-7c13-aeef-771e0c9a7900

2026-02-17T23:44:53.548215Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c6022-8a12-7ba0-b7e8-9c265e8ec17e
thinking
**Reviewing existing test updates**
2026-02-17T23:44:53.679237Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c5fbb-e145-7c40-9913-218548629e57
2026-02-17T23:44:53.781589Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c647c-8066-7eb1-8782-06a844370303
2026-02-17T23:44:53.933947Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c6bed-24ce-70e2-a3a9-72ea76928828
2026-02-17T23:44:54.051525Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c6a58-df8a-7560-894e-8c41ec0bc9ec
2026-02-17T23:44:54.148286Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c6bed-ca0f-7153-9527-6336e87fc2d0
2026-02-17T23:44:54.271026Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c5fed-5e04-78c0-9a4e-9fddc7af084e
2026-02-17T23:44:54.319553Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c6d75-a627-7be2-a5b9-708ae8d9ac39
2026-02-17T23:44:54.422157Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c6df8-e840-70b1-8ca3-7f1dc55b0796
codex
I’m implementing the MEM-3 refactor directly in `promote.ts` and then updating existing `promote.test.ts` expectations to match the new event-driven triggers. I’ll first inspect the current function and tests, then patch both files and run the required test and typecheck commands.
exec
/bin/zsh -lc "sed -n '1,260p' packages/system-bus/src/inngest/functions/promote.ts" in /private/tmp/agent-loop/loop-mlr8oxtg-b68bp4exec
/bin/zsh -lc "sed -n '1,260p' packages/system-bus/src/inngest/functions/promote.test.ts" in /private/tmp/agent-loop/loop-mlr8oxtg-b68bp4exec
/bin/zsh -lc "rg --files packages/system-bus/src/inngest/functions | rg 'promote\\.ts|promote\\.test\\.ts'" in /private/tmp/agent-loop/loop-mlr8oxtg-b68bp4 succeeded in 53ms:
import { join } from "node:path";
import { mkdir, rename } from "node:fs/promises";
import Redis from "ioredis";
import { inngest } from "../client";
import { PROMOTE_SYSTEM_PROMPT, PROMOTE_USER_PROMPT } from "./promote-prompt";

export type ProposalState = "checked" | "unchecked" | "deleted";

export type ParsedReviewProposal = {
  id: string;
  state: ProposalState;
};

export type ParsedReview = {
  proposals: ParsedReviewProposal[];
};

export type StoredProposal = {
  id: string;
  status: string;
 succeeded in 52ms:
import { afterAll, afterEach, beforeAll, beforeEach, describe, expect, test } from "bun:test";
import { mkdirSync, mkdtempSync, readFileSync, rmSync, writeFileSync } from "node:fs";
import { tmpdir } from "node:os";
import { join } from "node:path";
import { InngestTestEngine } from "@inngest/test";
import Redis from "ioredis";
import * as promoteModule from "./promote";
import { archiveProposal, expireProposal, promote, promoteToMemory } from "./promote";

type RedisMockState = {
  hashes: Map<string, Record<string, string>>;
  lists: Map<string, string[]>;
};

const REVIEW_PENDING_KEY = "memory:review:pending";
const originalHome = process.env.HOME;
const originalUserProfile = process.env.USERPROFILE;
const originalPath = process.env.PATH;
const originalRedisMethods = {
  lrange: Redis.prototype.lrange,
 succeeded in 53ms:
packages/system-bus/src/inngest/functions/promote.test.ts
packages/system-bus/src/inngest/functions/promote.ts
exec
/bin/zsh -lc "sed -n '261,620p' packages/system-bus/src/inngest/functions/promote.test.ts" in /private/tmp/agent-loop/loop-mlr8oxtg-b68bp4exec
/bin/zsh -lc "sed -n '261,620p' packages/system-bus/src/inngest/functions/promote.ts" in /private/tmp/agent-loop/loop-mlr8oxtg-b68bp4 succeeded in 53ms:
      hasDailyCronTrigger: triggerDefs.some((trigger) => trigger.cron === "0 8 * * *"),
      hasLegacyContentUpdatedTrigger: triggerDefs.some((trigger) => trigger.event === "content/updated"),
    }).toMatchObject({
      hasApprovedTrigger: true,
      hasRejectedTrigger: true,
      hasDailyCronTrigger: true,
      hasLegacyContentUpdatedTrigger: false,
    });
  });

  test("approved proposal event promotes memory and leaves REVIEW.md untouched", async () => {
    const approvedId = proposalIdDaysAgo(1, "101");
    const approvedText = "Approved proposal written to memory from event trigger.";
    const initialReview = ["# REVIEW Staging", `- [ ] ${approvedId}: ${approvedText}`, ""].join("\n");

    writeWorkspaceFiles(initialReview);
    redisState.lists.set(REVIEW_PENDING_KEY, [approvedId]);
    putProposal(approvedId, {
      targetSection: "Hard Rules",
      proposedText: approvedText,
 succeeded in 53ms:
  });

  const [stdout, stderr, exitCode] = await Promise.all([
    readProcessStream(proc.stdout),
    readProcessStream(proc.stderr),
    proc.exited,
  ]);

  if (exitCode !== 0) {
    console.error(`promoteToMemory formatting failed (${exitCode}): ${stderr || "unknown error"}`);
    return proposedText;
  }

  const formatted = stdout
    .trim()
    .split(/\r?\n/u)
    .map((line) => line.trim())
    .find((line) => line.length > 0);

  return formatted ?? proposedText;

thinking
**Identifying missing file segment**
exec
/bin/zsh -lc "sed -n '620,900p' packages/system-bus/src/inngest/functions/promote.ts" in /private/tmp/agent-loop/loop-mlr8oxtg-b68bp4 succeeded in 52ms:

      for (const change of changes.approved) {
        await promoteToMemory(change.id);
      }

      for (const change of changes.rejected) {
        const reason = parsedById.get(change.id)?.state === "deleted" ? "marked-rejected" : "deleted";
        await archiveProposal(change.id, reason);
      }

      for (const change of changes.expired) {
        await expireProposal(change.id);
      }
    });

    const updateState = await step.run("update-state", async () => {
      const redis = getRedisClient();
      const nextPending = [...new Set(changes.pending)];

      await redis.del(REVIEW_PENDING_KEY);

thinking
**Planning major code cleanup**
codex
I’ve confirmed `promote.test.ts` is already aligned to the event-driven behavior, so the main work is replacing the legacy `content/updated` + `REVIEW.md` flow in `promote.ts`. Next I’m patching `promote.ts` to remove the old parser/helpers and wire approved/rejected/cron trigger handling.
exec
/bin/zsh -lc 'rg -n "parseReviewMd|getReviewPath|removeProposalFromReview|extractContentPath|detectChanges|loadProposalState|ParsedReview|ProposalDiff|ProposalStateSnapshot|content/updated|REVIEW_PATH_FILTER|REVIEW_FILE_NAME" packages/system-bus/src/inngest/functions/promote.ts' in /private/tmp/agent-loop/loop-mlr8oxtg-b68bp4 succeeded in 53ms:
9:export type ParsedReviewProposal = {
14:export type ParsedReview = {
15:  proposals: ParsedReviewProposal[];
27:export type ProposalStateSnapshot = {
37:export type ProposalDiff = {
55:const REVIEW_PATH_FILTER = "~/.joelclaw/workspace/REVIEW.md";
56:const REVIEW_FILE_NAME = "REVIEW.md";
78:function getReviewPath(): string {
80:  return join(home, ".joelclaw", "workspace", REVIEW_FILE_NAME);
163:async function removeProposalFromReview(proposalId: string): Promise<void> {
164:  const reviewPath = getReviewPath();
318:function extractContentPath(eventData: unknown): string | null {
338:): ProposalDiff {
345:  } satisfies ProposalDiff;
347:  return new Proxy({} as ProposalDiff, {
418:export function parseReviewMd(markdown: string): ParsedReview {
419:  const proposals: ParsedReviewProposal[] = [];
438:export async function loadProposalState(redis: Pick<RedisLike, "lrange" | "hgetall">): Promise<ProposalStateSnapshot> {
457:export function detectChanges(
459:  previousState: ProposalStateSnapshot,

thinking
**Assessing file rewrite scope**
exec
/bin/zsh -lc "rg -n \"from \\\"\\.\\/promote\\\"|from './promote'|promoteToMemory\\(|archiveProposal\\(|expireProposal\\(|loadProposalState\\(|detectChanges\\(|parseReviewMd\\(\" packages/system-bus/src | sed -n '1,200p'" in /private/tmp/agent-loop/loop-mlr8oxtg-b68bp4 succeeded in 52ms:
packages/system-bus/src/inngest/functions/index.ts:9:export { promote } from "./promote";
packages/system-bus/src/inngest/functions/promote.test.ts:7:import * as promoteModule from "./promote";
packages/system-bus/src/inngest/functions/promote.test.ts:8:import { archiveProposal, expireProposal, promote, promoteToMemory } from "./promote";
packages/system-bus/src/inngest/functions/promote.test.ts:425:    await promoteToMemory(promotedId);
packages/system-bus/src/inngest/functions/promote.test.ts:426:    await archiveProposal(archivedId, "deleted");
packages/system-bus/src/inngest/functions/promote.test.ts:427:    await expireProposal(expiredId);
packages/system-bus/src/inngest/functions/promote.ts:418:export function parseReviewMd(markdown: string): ParsedReview {
packages/system-bus/src/inngest/functions/promote.ts:438:export async function loadProposalState(redis: Pick<RedisLike, "lrange" | "hgetall">): Promise<ProposalStateSnapshot> {
packages/system-bus/src/inngest/functions/promote.ts:457:export function detectChanges(
packages/system-bus/src/inngest/functions/promote.ts:503:export async function promoteToMemory(proposalId: string): Promise<void> {
packages/system-bus/src/inngest/functions/promote.ts:539:export async function archiveProposal(proposalId: string, reason: "deleted" | "marked-rejected"): Promise<void> {
packages/system-bus/src/inngest/functions/promote.ts:555:export async function expireProposal(proposalId: string): Promise<void> {
packages/system-bus/src/inngest/functions/promote.ts:608:      return parseReviewMd(markdown);
packages/system-bus/src/inngest/functions/promote.ts:613:      return loadProposalState(redis);
packages/system-bus/src/inngest/functions/promote.ts:616:    const changes = await step.run("detect-changes", async () => detectChanges(parsed, previous));
packages/system-bus/src/inngest/functions/promote.ts:622:        await promoteToMemory(change.id);
packages/system-bus/src/inngest/functions/promote.ts:627:        await archiveProposal(change.id, reason);
packages/system-bus/src/inngest/functions/promote.ts:631:        await expireProposal(change.id);
packages/system-bus/src/inngest/functions/promote-integration.test.ts:7:import { promote } from "./promote";

thinking
**Reviewing integration test dependencies**
exec
/bin/zsh -lc "sed -n '1,260p' packages/system-bus/src/inngest/functions/promote-integration.test.ts" in /private/tmp/agent-loop/loop-mlr8oxtg-b68bp4 succeeded in 53ms:
import { afterAll, afterEach, beforeAll, beforeEach, describe, expect, test } from "bun:test";
import { mkdirSync, mkdtempSync, readFileSync, rmSync, writeFileSync } from "node:fs";
import { tmpdir } from "node:os";
import { join } from "node:path";
import { InngestTestEngine } from "@inngest/test";
import Redis from "ioredis";
import { promote } from "./promote";

type RedisMockState = {
  hashes: Map<string, Record<string, string>>;
  lists: Map<string, string[]>;
};

const originalHome = process.env.HOME;
const originalUserProfile = process.env.USERPROFILE;
const originalRedisMethods = {
  lrange: Redis.prototype.lrange,
  hgetall: Redis.prototype.hgetall,
  hset: Redis.prototype.hset,
  lrem: (Redis.prototype as { lrem?: unknown }).lrem,
exec
/bin/zsh -lc "sed -n '260,560p' packages/system-bus/src/inngest/functions/promote-integration.test.ts" in /private/tmp/agent-loop/loop-mlr8oxtg-b68bp4 succeeded in 53ms:
      reviewPath,
      [
        "# REVIEW",
        "",
        `- [x] ${approvedId}: ${approvedText}`,
        `- [ ] ${expiredId}: ${expiredText}`,
        `- [ ] ${activePendingId}: ${activePendingText}`,
        "",
      ].join("\n")
    );

    const { result } = await executePromoteWithEvent({
      name: "content/updated",
      data: { path: reviewPath },
    });

    const memory = readFileSync(memoryPath, "utf8");
    const hardRules = getSectionBlock(memory, "Hard Rules");
    const log = readFileSync(todayLogPath(), "utf8");
    const review = readFileSync(reviewPath, "utf8");

thinking
**Planning integration test updates**
file update
M /private/tmp/agent-loop/loop-mlr8oxtg-b68bp4/packages/system-bus/src/inngest/functions/promote.ts
@@ -8,11 +8,2 @@
 
-export type ParsedReviewProposal = {
-  id: string;
-  state: ProposalState;
-};
-
-export type ParsedReview = {
-  proposals: ParsedReviewProposal[];
-};
-
 export type StoredProposal = {
@@ -24,20 +15,2 @@
   change?: string;
-};
-
-export type ProposalStateSnapshot = {
-  pending: string[];
-  proposals: Record<string, StoredProposal>;
-};
-
-export type ProposalChange = {
-  id: string;
-  proposal?: StoredProposal;
-};
-
-export type ProposalDiff = {
-  approved: ProposalChange[];
-  rejected: ProposalChange[];
-  expired: ProposalChange[];
-  unchanged: ProposalChange[];
-  pending: string[];
 };
@@ -54,4 +27,2 @@
 const REVIEW_PENDING_KEY = "memory:review:pending";
-const REVIEW_PATH_FILTER = "~/.joelclaw/workspace/REVIEW.md";
-const REVIEW_FILE_NAME = "REVIEW.md";
 const MEMORY_FILE_NAME = "MEMORY.md";
@@ -77,7 +48,2 @@
 
-function getReviewPath(): string {
-  const home = process.env.HOME || process.env.USERPROFILE || "/Users/joel";
-  return join(home, ".joelclaw", "workspace", REVIEW_FILE_NAME);
-}
-
 function getMemoryPath(): string {
@@ -121,6 +87,2 @@
   return date;
-}
-
-function escapeRegex(value: string): string {
-  return value.replace(/[.*+?^${}()|[\]\\]/gu, "\\$&");
 }
@@ -160,16 +122,2 @@
   await Bun.write(logPath, next);
-}
-
-async function removeProposalFromReview(proposalId: string): Promise<void> {
-  const reviewPath = getReviewPath();
-  const reviewFile = Bun.file(reviewPath);
-  if (!(await reviewFile.exists())) return;
-
-  const markdown = await reviewFile.text();
-  const pattern = new RegExp(`^\\s*-\\s*\\[( |x|X|-)\\]\\s*${escapeRegex(proposalId)}\\b`, "u");
-  const nextLines = markdown.split(/\r?\n/u).filter((line) => !pattern.test(line));
-  const next = `${nextLines.join("\n").replace(/\n*$/u, "")}\n`;
-  if (next !== markdown) {
-    await Bun.write(reviewPath, next);
-  }
 }
apply_patch(auto_approved=true) exited 0 in 32ms:
Success. Updated the following files:
M packages/system-bus/src/inngest/functions/promote.ts
file update:
diff --git a/packages/system-bus/src/inngest/functions/promote.ts b/packages/system-bus/src/inngest/functions/promote.ts
index 09730ecff690b4bfba745ef6f7b0a7469122608c..e8639d221860f633caab8881200b6fb1251aebb9
--- a/packages/system-bus/src/inngest/functions/promote.ts
+++ b/packages/system-bus/src/inngest/functions/promote.ts
@@ -6,15 +6,6 @@
 
 export type ProposalState = "checked" | "unchecked" | "deleted";
 
-export type ParsedReviewProposal = {
-  id: string;
-  state: ProposalState;
-};
-
-export type ParsedReview = {
-  proposals: ParsedReviewProposal[];
-};
-
 export type StoredProposal = {
   id: string;
   status: string;
@@ -22,24 +13,6 @@
   date?: string;
   section?: string;
   change?: string;
-};
-
-export type ProposalStateSnapshot = {
-  pending: string[];
-  proposals: Record<string, StoredProposal>;
-};
-
-export type ProposalChange = {
-  id: string;
-  proposal?: StoredProposal;
-};
-
-export type ProposalDiff = {
-  approved: ProposalChange[];
-  rejected: ProposalChange[];
-  expired: ProposalChange[];
-  unchanged: ProposalChange[];
-  pending: string[];
 };
 
 type RedisLike = {
@@ -52,8 +25,6 @@
 };
 
 const REVIEW_PENDING_KEY = "memory:review:pending";
-const REVIEW_PATH_FILTER = "~/.joelclaw/workspace/REVIEW.md";
-const REVIEW_FILE_NAME = "REVIEW.md";
 const MEMORY_FILE_NAME = "MEMORY.md";
 const SEVEN_DAYS_MS = 7 * 24 * 60 * 60 * 1000;
 const REJECTED_PROPOSALS_HEADER = "### Rejected Proposals";
@@ -75,11 +46,6 @@
   return redisClient;
 }
 
-function getReviewPath(): string {
-  const home = process.env.HOME || process.env.USERPROFILE || "/Users/joel";
-  return join(home, ".joelclaw", "workspace", REVIEW_FILE_NAME);
-}
-
 function getMemoryPath(): string {
   const home = process.env.HOME || process.env.USERPROFILE || "/Users/joel";
   return join(home, ".joelclaw", "workspace", MEMORY_FILE_NAME);
@@ -119,10 +85,6 @@
   if (date.getUTCMonth() !== monthIndex) return null;
   if (date.getUTCDate() !== day) return null;
   return date;
-}
-
-function escapeRegex(value: string): string {
-  return value.replace(/[.*+?^${}()|[\]\\]/gu, "\\$&");
 }
 
 function appendEntryToLogSection(markdown: string, header: string, entry: string): string {
@@ -158,20 +120,6 @@
   const existing = (await logFile.exists()) ? await logFile.text() : "";
   const next = appendEntryToLogSection(existing, header, entry);
   await Bun.write(logPath, next);
-}
-
-async function removeProposalFromReview(proposalId: string): Promise<void> {
-  const reviewPath = getReviewPath();
-  const reviewFile = Bun.file(reviewPath);
-  if (!(await reviewFile.exists())) return;
-
-  const markdown = await reviewFile.text();
-  const pattern = new RegExp(`^\\s*-\\s*\\[( |x|X|-)\\]\\s*${escapeRegex(proposalId)}\\b`, "u");
-  const nextLines = markdown.split(/\r?\n/u).filter((line) => !pattern.test(line));
-  const next = `${nextLines.join("\n").replace(/\n*$/u, "")}\n`;
-  if (next !== markdown) {
-    await Bun.write(reviewPath, next);
-  }
 }
 
 function isProposalOlderThanSevenDays(proposalId: string, now: Date = new Date()): boolean {

file update:
diff --git a/packages/system-bus/src/inngest/functions/promote.ts b/packages/system-bus/src/inngest/functions/promote.ts
index 09730ecff690b4bfba745ef6f7b0a7469122608c..e8639d221860f633caab8881200b6fb1251aebb9
--- a/packages/system-bus/src/inngest/functions/promote.ts
+++ b/packages/system-bus/src/inngest/functions/promote.ts
@@ -6,15 +6,6 @@
 
 export type ProposalState = "checked" | "unchecked" | "deleted";
 
-export type ParsedReviewProposal = {
-  id: string;
-  state: ProposalState;
-};
-
-export type ParsedReview = {
-  proposals: ParsedReviewProposal[];
-};
-
 export type StoredProposal = {
   id: string;
   status: string;
@@ -22,24 +13,6 @@
   date?: string;
   section?: string;
   change?: string;
-};
-
-export type ProposalStateSnapshot = {
-  pending: string[];
-  proposals: Record<string, StoredProposal>;
-};
-
-export type ProposalChange = {
-  id: string;
-  proposal?: StoredProposal;
-};
-
-export type ProposalDiff = {
-  approved: ProposalChange[];
-  rejected: ProposalChange[];
-  expired: ProposalChange[];
-  unchanged: ProposalChange[];
-  pending: string[];
 };
 
 type RedisLike = {
@@ -52,8 +25,6 @@
 };
 
 const REVIEW_PENDING_KEY = "memory:review:pending";
-const REVIEW_PATH_FILTER = "~/.joelclaw/workspace/REVIEW.md";
-const REVIEW_FILE_NAME = "REVIEW.md";
 const MEMORY_FILE_NAME = "MEMORY.md";
 const SEVEN_DAYS_MS = 7 * 24 * 60 * 60 * 1000;
 const REJECTED_PROPOSALS_HEADER = "### Rejected Proposals";
@@ -75,11 +46,6 @@
   return redisClient;
 }
 
-function getReviewPath(): string {
-  const home = process.env.HOME || process.env.USERPROFILE || "/Users/joel";
-  return join(home, ".joelclaw", "workspace", REVIEW_FILE_NAME);
-}
-
 function getMemoryPath(): string {
   const home = process.env.HOME || process.env.USERPROFILE || "/Users/joel";
   return join(home, ".joelclaw", "workspace", MEMORY_FILE_NAME);
@@ -119,10 +85,6 @@
   if (date.getUTCMonth() !== monthIndex) return null;
   if (date.getUTCDate() !== day) return null;
   return date;
-}
-
-function escapeRegex(value: string): string {
-  return value.replace(/[.*+?^${}()|[\]\\]/gu, "\\$&");
 }
 
 function appendEntryToLogSection(markdown: string, header: string, entry: string): string {
@@ -158,20 +120,6 @@
   const existing = (await logFile.exists()) ? await logFile.text() : "";
   const next = appendEntryToLogSection(existing, header, entry);
   await Bun.write(logPath, next);
-}
-
-async function removeProposalFromReview(proposalId: string): Promise<void> {
-  const reviewPath = getReviewPath();
-  const reviewFile = Bun.file(reviewPath);
-  if (!(await reviewFile.exists())) return;
-
-  const markdown = await reviewFile.text();
-  const pattern = new RegExp(`^\\s*-\\s*\\[( |x|X|-)\\]\\s*${escapeRegex(proposalId)}\\b`, "u");
-  const nextLines = markdown.split(/\r?\n/u).filter((line) => !pattern.test(line));
-  const next = `${nextLines.join("\n").replace(/\n*$/u, "")}\n`;
-  if (next !== markdown) {
-    await Bun.write(reviewPath, next);
-  }
 }
 
 function isProposalOlderThanSevenDays(proposalId: string, now: Date = new Date()): boolean {


thinking
**Planning removal of large parse functions**
codex
I’ve removed the REVIEW.md-specific constants/helpers and now I’m deleting the remaining parser/diff pipeline (`parseReviewMd`/`detectChanges`) and replacing the Inngest handler logic with explicit approved/rejected/cron routing.
file update
M /private/tmp/agent-loop/loop-mlr8oxtg-b68bp4/packages/system-bus/src/inngest/functions/promote.ts
@@ -230,108 +230,2 @@
 
-function parseState(raw: string): ProposalState | null {
-  const value = raw.trim().toLowerCase();
-  if (value === "x") return "checked";
-  if (value === "-") return "deleted";
-  if (value === "") return "unchecked";
-  return null;
-}
-
-function parseCurrentState(currentState: unknown): Map<string, ProposalState> {
-  const map = new Map<string, ProposalState>();
-
-  if (!currentState || typeof currentState !== "object") return map;
-  const proposals = (currentState as { proposals?: unknown }).proposals;
-  if (!Array.isArray(proposals)) return map;
-
-  for (const proposal of proposals) {
-    if (!proposal || typeof proposal !== "object") continue;
-    const id = (proposal as { id?: unknown }).id;
-    const state = (proposal as { state?: unknown }).state;
-    if (typeof id !== "string") continue;
-    if (state === "checked" || state === "unchecked" || state === "deleted") {
-      map.set(id, state);
-    }
-  }
-
-  return map;
-}
-
-function isExpired(capturedAt: string | undefined, now: Date): boolean {
-  if (!capturedAt) return false;
-  const created = new Date(capturedAt);
-  if (Number.isNaN(created.getTime())) return false;
-  return now.getTime() - created.getTime() >= SEVEN_DAYS_MS;
-}
-
-function extractContentPath(eventData: unknown): string | null {
-  if (!eventData || typeof eventData !== "object") return null;
-  const rec = eventData as Record<string, unknown>;
-
-  const candidates = [rec.path, rec.filePath, rec.filepath];
-  for (const candidate of candidates) {
-    if (typeof candidate === "string" && candidate.length > 0) {
-      return candidate;
-    }
-  }
-
-  return null;
-}
-
-function createStableDiff(
-  approved: ProposalChange[],
-  rejected: ProposalChange[],
-  expired: ProposalChange[],
-  unchanged: ProposalChange[],
-  pending: string[]
-): ProposalDiff {
-  const data = {
-    approved,
-    rejected,
-    expired,
-    unchanged,
-    pending,
-  } satisfies ProposalDiff;
-
-  return new Proxy({} as ProposalDiff, {
-    get(_, property) {
-      if (property === "approved") return data.approved.map((item) => ({ ...item }));
-      if (property === "rejected") return data.rejected.map((item) => ({ ...item }));
-      if (property === "expired") return data.expired.map((item) => ({ ...item }));
-      if (property === "unchanged") return data.unchanged.map((item) => ({ ...item }));
-      if (property === "pending") return [...data.pending];
-      return undefined;
-    },
-    set() {
-      return true;
-    },
-    has(_, property) {
-      return (
-        property === "approved" ||
-        property === "rejected" ||
-        property === "expired" ||
-        property === "unchanged" ||
-        property === "pending"
-      );
-    },
-    ownKeys() {
-      return ["approved", "rejected", "expired", "unchanged", "pending"];
-    },
-    getOwnPropertyDescriptor(_, property) {
-      if (
-        property === "approved" ||
-        property === "rejected" ||
-        property === "expired" ||
-        property === "unchanged" ||
-        property === "pending"
-      ) {
-        return {
-          enumerable: true,
-          configurable: true,
-        };
-      }
-      return undefined;
-    },
-  });
-}
-
 function stabilizeFunctionOpts<T extends { opts?: Record<string, unknown> }>(fn: T): T {
@@ -363,87 +257,2 @@
   });
-}
-
-export function parseReviewMd(markdown: string): ParsedReview {
-  const proposals: ParsedReviewProposal[] = [];
-
-  const lines = markdown.split(/\r?\n/u);
-  for (const line of lines) {
-    const match = /^\s*-\s*\[( |x|X|-)\]\s*(p-\d{8}-\d{3,})\b/u.exec(line);
-    if (!match?.[1] || !match[2]) continue;
-
-    const state = parseState(match[1]);
-    if (!state) continue;
-
-    proposals.push({
-      id: match[2],
-      state,
-    });
-  }
-
-  return { proposals };
-}
-
-export async function loadProposalState(redis: Pick<RedisLike, "lrange" | "hgetall">): Promise<ProposalStateSnapshot> {
-  const pending = await redis.lrange(REVIEW_PENDING_KEY, 0, -1);
-  const proposals: Record<string, StoredProposal> = {};
-
-  for (const id of pending) {
-    const stored = await redis.hgetall(proposalKey(id));
-    proposals[id] = {
-      id,
-      status: stored.status ?? "pending",
-      capturedAt: stored.capturedAt,
-      date: stored.date,
-      section: stored.section,
-      change: stored.change,
-    };
-  }
-
-  return { pending, proposals };
-}
-
-export function detectChanges(
-  currentState: unknown,
-  previousState: ProposalStateSnapshot,
-  now: Date = new Date()
-): ProposalDiff {
-  const current = parseCurrentState(currentState);
-  const approved: ProposalChange[] = [];
-  const rejected: ProposalChange[] = [];
-  const expired: ProposalChange[] = [];
-  const unchanged: ProposalChange[] = [];
-  const pending: string[] = [];
-
-  for (const id of previousState.pending) {
-    const proposal = previousState.proposals[id] ?? { id, status: "pending" };
-    const currentProposalState = current.get(id);
-
-    if (currentProposalState === "checked") {
-      approved.push({ id, proposal });
-      continue;
-    }
-
-    if (currentProposalState === "deleted" || currentProposalState === undefined) {
-      rejected.push({ id, proposal });
-      continue;
-    }
-
-    if (isExpired(proposal.capturedAt, now)) {
-      expired.push({ id, proposal });
-      continue;
-    }
-
-    unchanged.push({ id, proposal });
-    pending.push(id);
-  }
-
-  for (const [id, state] of current.entries()) {
-    if (previousState.pending.includes(id)) continue;
-    if (state === "unchecked") {
-      unchanged.push({ id, proposal: previousState.proposals[id] ?? { id, status: "pending" } });
-      pending.push(id);
-    }
-  }
-
-  return createStableDiff(approved, rejected, expired, unchanged, pending);
 }
apply_patch(auto_approved=true) exited 0 in 48ms:
Success. Updated the following files:
M packages/system-bus/src/inngest/functions/promote.ts
file update:
diff --git a/packages/system-bus/src/inngest/functions/promote.ts b/packages/system-bus/src/inngest/functions/promote.ts
index 09730ecff690b4bfba745ef6f7b0a7469122608c..b999bd11551a268fdb8cccb307cc5c3ee9f7c9ce
--- a/packages/system-bus/src/inngest/functions/promote.ts
+++ b/packages/system-bus/src/inngest/functions/promote.ts
@@ -6,15 +6,6 @@
 
 export type ProposalState = "checked" | "unchecked" | "deleted";
 
-export type ParsedReviewProposal = {
-  id: string;
-  state: ProposalState;
-};
-
-export type ParsedReview = {
-  proposals: ParsedReviewProposal[];
-};
-
 export type StoredProposal = {
   id: string;
   status: string;
@@ -22,26 +13,8 @@
   date?: string;
   section?: string;
   change?: string;
-};
-
-export type ProposalStateSnapshot = {
-  pending: string[];
-  proposals: Record<string, StoredProposal>;
 };
 
-export type ProposalChange = {
-  id: string;
-  proposal?: StoredProposal;
-};
-
-export type ProposalDiff = {
-  approved: ProposalChange[];
-  rejected: ProposalChange[];
-  expired: ProposalChange[];
-  unchanged: ProposalChange[];
-  pending: string[];
-};
-
 type RedisLike = {
   lrange(key: string, start: number, stop: number): Promise<string[]>;
   hgetall(key: string): Promise<Record<string, string>>;
@@ -52,8 +25,6 @@
 };
 
 const REVIEW_PENDING_KEY = "memory:review:pending";
-const REVIEW_PATH_FILTER = "~/.joelclaw/workspace/REVIEW.md";
-const REVIEW_FILE_NAME = "REVIEW.md";
 const MEMORY_FILE_NAME = "MEMORY.md";
 const SEVEN_DAYS_MS = 7 * 24 * 60 * 60 * 1000;
 const REJECTED_PROPOSALS_HEADER = "### Rejected Proposals";
@@ -75,11 +46,6 @@
   return redisClient;
 }
 
-function getReviewPath(): string {
-  const home = process.env.HOME || process.env.USERPROFILE || "/Users/joel";
-  return join(home, ".joelclaw", "workspace", REVIEW_FILE_NAME);
-}
-
 function getMemoryPath(): string {
   const home = process.env.HOME || process.env.USERPROFILE || "/Users/joel";
   return join(home, ".joelclaw", "workspace", MEMORY_FILE_NAME);
@@ -119,10 +85,6 @@
   if (date.getUTCMonth() !== monthIndex) return null;
   if (date.getUTCDate() !== day) return null;
   return date;
-}
-
-function escapeRegex(value: string): string {
-  return value.replace(/[.*+?^${}()|[\]\\]/gu, "\\$&");
 }
 
 function appendEntryToLogSection(markdown: string, header: string, entry: string): string {
@@ -158,20 +120,6 @@
   const existing = (await logFile.exists()) ? await logFile.text() : "";
   const next = appendEntryToLogSection(existing, header, entry);
   await Bun.write(logPath, next);
-}
-
-async function removeProposalFromReview(proposalId: string): Promise<void> {
-  const reviewPath = getReviewPath();
-  const reviewFile = Bun.file(reviewPath);
-  if (!(await reviewFile.exists())) return;
-
-  const markdown = await reviewFile.text();
-  const pattern = new RegExp(`^\\s*-\\s*\\[( |x|X|-)\\]\\s*${escapeRegex(proposalId)}\\b`, "u");
-  const nextLines = markdown.split(/\r?\n/u).filter((line) => !pattern.test(line));
-  const next = `${nextLines.join("\n").replace(/\n*$/u, "")}\n`;
-  if (next !== markdown) {
-    await Bun.write(reviewPath, next);
-  }
 }
 
 function isProposalOlderThanSevenDays(proposalId: string, now: Date = new Date()): boolean {
@@ -278,114 +226,8 @@
     .find((line) => line.length > 0);
 
   return formatted ?? proposedText;
-}
-
-function parseState(raw: string): ProposalState | null {
-  const value = raw.trim().toLowerCase();
-  if (value === "x") return "checked";
-  if (value === "-") return "deleted";
-  if (value === "") return "unchecked";
-  return null;
-}
-
-function parseCurrentState(currentState: unknown): Map<string, ProposalState> {
-  const map = new Map<string, ProposalState>();
-
-  if (!currentState || typeof currentState !== "object") return map;
-  const proposals = (currentState as { proposals?: unknown }).proposals;
-  if (!Array.isArray(proposals)) return map;
-
-  for (const proposal of proposals) {
-    if (!proposal || typeof proposal !== "object") continue;
-    const id = (proposal as { id?: unknown }).id;
-    const state = (proposal as { state?: unknown }).state;
-    if (typeof id !== "string") continue;
-    if (state === "checked" || state === "unchecked" || state === "deleted") {
-      map.set(id, state);
-    }
-  }
-
-  return map;
 }
 
-function isExpired(capturedAt: string | undefined, now: Date): boolean {
-  if (!capturedAt) return false;
-  const created = new Date(capturedAt);
-  if (Number.isNaN(created.getTime())) return false;
-  return now.getTime() - created.getTime() >= SEVEN_DAYS_MS;
-}
-
-function extractContentPath(eventData: unknown): string | null {
-  if (!eventData || typeof eventData !== "object") return null;
-  const rec = eventData as Record<string, unknown>;
-
-  const candidates = [rec.path, rec.filePath, rec.filepath];
-  for (const candidate of candidates) {
-    if (typeof candidate === "string" && candidate.length > 0) {
-      return candidate;
-    }
-  }
-
-  return null;
-}
-
-function createStableDiff(
-  approved: ProposalChange[],
-  rejected: ProposalChange[],
-  expired: ProposalChange[],
-  unchanged: ProposalChange[],
-  pending: string[]
-): ProposalDiff {
-  const data = {
-    approved,
-    rejected,
-    expired,
-    unchanged,
-    pending,
-  } satisfies ProposalDiff;
-
-  return new Proxy({} as ProposalDiff, {
-    get(_, property) {
-      if (property === "approved") return data.approved.map((item) => ({ ...item }));
-      if (property === "rejected") return data.rejected.map((item) => ({ ...item }));
-      if (property === "expired") return data.expired.map((item) => ({ ...item }));
-      if (property === "unchanged") return data.unchanged.map((item) => ({ ...item }));
-      if (property === "pending") return [...data.pending];
-      return undefined;
-    },
-    set() {
-      return true;
-    },
-    has(_, property) {
-      return (
-        property === "approved" ||
-        property === "rejected" ||
-        property === "expired" ||
-        property === "unchanged" ||
-        property === "pending"
-      );
-    },
-    ownKeys() {
-      return ["approved", "rejected", "expired", "unchanged", "pending"];
-    },
-    getOwnPropertyDescriptor(_, property) {
-      if (
-        property === "approved" ||
-        property === "rejected" ||
-        property === "expired" ||
-        property === "unchanged" ||
-        property === "pending"
-      ) {
-        return {
-          enumerable: true,
-          configurable: true,
-        };
-      }
-      return undefined;
-    },
-  });
-}
-
 function stabilizeFunctionOpts<T extends { opts?: Record<string, unknown> }>(fn: T): T {
   const original = fn.opts;
   if (!original) return fn;
@@ -413,91 +255,6 @@
       return Reflect.set(target, property, value, receiver);
     },
   });
-}
-
-export function parseReviewMd(markdown: string): ParsedReview {
-  const proposals: ParsedReviewProposal[] = [];
-
-  const lines = markdown.split(/\r?\n/u);
-  for (const line of lines) {
-    const match = /^\s*-\s*\[( |x|X|-)\]\s*(p-\d{8}-\d{3,})\b/u.exec(line);
-    if (!match?.[1] || !match[2]) continue;
-
-    const state = parseState(match[1]);
-    if (!state) continue;
-
-    proposals.push({
-      id: match[2],
-      state,
-    });
-  }
-
-  return { proposals };
-}
-
-export async function loadProposalState(redis: Pick<RedisLike, "lrange" | "hgetall">): Promise<ProposalStateSnapshot> {
-  const pending = await redis.lrange(REVIEW_PENDING_KEY, 0, -1);
-  const proposals: Record<string, StoredProposal> = {};
-
-  for (const id of pending) {
-    const stored = await redis.hgetall(proposalKey(id));
-    proposals[id] = {
-      id,
-      status: stored.status ?? "pending",
-      capturedAt: stored.capturedAt,
-      date: stored.date,
-      section: stored.section,
-      change: stored.change,
-    };
-  }
-
-  return { pending, proposals };
-}
-
-export function detectChanges(
-  currentState: unknown,
-  previousState: ProposalStateSnapshot,
-  now: Date = new Date()
-): ProposalDiff {
-  const current = parseCurrentState(currentState);
-  const approved: ProposalChange[] = [];
-  const rejected: ProposalChange[] = [];
-  const expired: ProposalChange[] = [];
-  const unchanged: ProposalChange[] = [];
-  const pending: string[] = [];
-
-  for (const id of previousState.pending) {
-    const proposal = previousState.proposals[id] ?? { id, status: "pending" };
-    const currentProposalState = current.get(id);
-
-    if (currentProposalState === "checked") {
-      approved.push({ id, proposal });
-      continue;
-    }
-
-    if (currentProposalState === "deleted" || currentProposalState === undefined) {
-      rejected.push({ id, proposal });
-      continue;
-    }
-
-    if (isExpired(proposal.capturedAt, now)) {
-      expired.push({ id, proposal });
-      continue;
-    }
-
-    unchanged.push({ id, proposal });
-    pending.push(id);
-  }
-
-  for (const [id, state] of current.entries()) {
-    if (previousState.pending.includes(id)) continue;
-    if (state === "unchecked") {
-      unchanged.push({ id, proposal: previousState.proposals[id] ?? { id, status: "pending" } });
-      pending.push(id);
-    }
-  }
-
-  return createStableDiff(approved, rejected, expired, unchanged, pending);
 }
 
 export async function promoteToMemory(proposalId: string): Promise<void> {

file update:
diff --git a/packages/system-bus/src/inngest/functions/promote.ts b/packages/system-bus/src/inngest/functions/promote.ts
index 09730ecff690b4bfba745ef6f7b0a7469122608c..b999bd11551a268fdb8cccb307cc5c3ee9f7c9ce
--- a/packages/system-bus/src/inngest/functions/promote.ts
+++ b/packages/system-bus/src/inngest/functions/promote.ts
@@ -6,15 +6,6 @@
 
 export type ProposalState = "checked" | "unchecked" | "deleted";
 
-export type ParsedReviewProposal = {
-  id: string;
-  state: ProposalState;
-};
-
-export type ParsedReview = {
-  proposals: ParsedReviewProposal[];
-};
-
 export type StoredProposal = {
   id: string;
   status: string;
@@ -22,26 +13,8 @@
   date?: string;
   section?: string;
   change?: string;
-};
-
-export type ProposalStateSnapshot = {
-  pending: string[];
-  proposals: Record<string, StoredProposal>;
 };
 
-export type ProposalChange = {
-  id: string;
-  proposal?: StoredProposal;
-};
-
-export type ProposalDiff = {
-  approved: ProposalChange[];
-  rejected: ProposalChange[];
-  expired: ProposalChange[];
-  unchanged: ProposalChange[];
-  pending: string[];
-};
-
 type RedisLike = {
   lrange(key: string, start: number, stop: number): Promise<string[]>;
   hgetall(key: string): Promise<Record<string, string>>;
@@ -52,8 +25,6 @@
 };
 
 const REVIEW_PENDING_KEY = "memory:review:pending";
-const REVIEW_PATH_FILTER = "~/.joelclaw/workspace/REVIEW.md";
-const REVIEW_FILE_NAME = "REVIEW.md";
 const MEMORY_FILE_NAME = "MEMORY.md";
 const SEVEN_DAYS_MS = 7 * 24 * 60 * 60 * 1000;
 const REJECTED_PROPOSALS_HEADER = "### Rejected Proposals";
@@ -75,11 +46,6 @@
   return redisClient;
 }
 
-function getReviewPath(): string {
-  const home = process.env.HOME || process.env.USERPROFILE || "/Users/joel";
-  return join(home, ".joelclaw", "workspace", REVIEW_FILE_NAME);
-}
-
 function getMemoryPath(): string {
   const home = process.env.HOME || process.env.USERPROFILE || "/Users/joel";
   return join(home, ".joelclaw", "workspace", MEMORY_FILE_NAME);
@@ -119,10 +85,6 @@
   if (date.getUTCMonth() !== monthIndex) return null;
   if (date.getUTCDate() !== day) return null;
   return date;
-}
-
-function escapeRegex(value: string): string {
-  return value.replace(/[.*+?^${}()|[\]\\]/gu, "\\$&");
 }
 
 function appendEntryToLogSection(markdown: string, header: string, entry: string): string {
@@ -158,20 +120,6 @@
   const existing = (await logFile.exists()) ? await logFile.text() : "";
   const next = appendEntryToLogSection(existing, header, entry);
   await Bun.write(logPath, next);
-}
-
-async function removeProposalFromReview(proposalId: string): Promise<void> {
-  const reviewPath = getReviewPath();
-  const reviewFile = Bun.file(reviewPath);
-  if (!(await reviewFile.exists())) return;
-
-  const markdown = await reviewFile.text();
-  const pattern = new RegExp(`^\\s*-\\s*\\[( |x|X|-)\\]\\s*${escapeRegex(proposalId)}\\b`, "u");
-  const nextLines = markdown.split(/\r?\n/u).filter((line) => !pattern.test(line));
-  const next = `${nextLines.join("\n").replace(/\n*$/u, "")}\n`;
-  if (next !== markdown) {
-    await Bun.write(reviewPath, next);
-  }
 }
 
 function isProposalOlderThanSevenDays(proposalId: string, now: Date = new Date()): boolean {
@@ -278,114 +226,8 @@
     .find((line) => line.length > 0);
 
   return formatted ?? proposedText;
-}
-
-function parseState(raw: string): ProposalState | null {
-  const value = raw.trim().toLowerCase();
-  if (value === "x") return "checked";
-  if (value === "-") return "deleted";
-  if (value === "") return "unchecked";
-  return null;
-}
-
-function parseCurrentState(currentState: unknown): Map<string, ProposalState> {
-  const map = new Map<string, ProposalState>();
-
-  if (!currentState || typeof currentState !== "object") return map;
-  const proposals = (currentState as { proposals?: unknown }).proposals;
-  if (!Array.isArray(proposals)) return map;
-
-  for (const proposal of proposals) {
-    if (!proposal || typeof proposal !== "object") continue;
-    const id = (proposal as { id?: unknown }).id;
-    const state = (proposal as { state?: unknown }).state;
-    if (typeof id !== "string") continue;
-    if (state === "checked" || state === "unchecked" || state === "deleted") {
-      map.set(id, state);
-    }
-  }
-
-  return map;
 }
 
-function isExpired(capturedAt: string | undefined, now: Date): boolean {
-  if (!capturedAt) return false;
-  const created = new Date(capturedAt);
-  if (Number.isNaN(created.getTime())) return false;
-  return now.getTime() - created.getTime() >= SEVEN_DAYS_MS;
-}
-
-function extractContentPath(eventData: unknown): string | null {
-  if (!eventData || typeof eventData !== "object") return null;
-  const rec = eventData as Record<string, unknown>;
-
-  const candidates = [rec.path, rec.filePath, rec.filepath];
-  for (const candidate of candidates) {
-    if (typeof candidate === "string" && candidate.length > 0) {
-      return candidate;
-    }
-  }
-
-  return null;
-}
-
-function createStableDiff(
-  approved: ProposalChange[],
-  rejected: ProposalChange[],
-  expired: ProposalChange[],
-  unchanged: ProposalChange[],
-  pending: string[]
-): ProposalDiff {
-  const data = {
-    approved,
-    rejected,
-    expired,
-    unchanged,
-    pending,
-  } satisfies ProposalDiff;
-
-  return new Proxy({} as ProposalDiff, {
-    get(_, property) {
-      if (property === "approved") return data.approved.map((item) => ({ ...item }));
-      if (property === "rejected") return data.rejected.map((item) => ({ ...item }));
-      if (property === "expired") return data.expired.map((item) => ({ ...item }));
-      if (property === "unchanged") return data.unchanged.map((item) => ({ ...item }));
-      if (property === "pending") return [...data.pending];
-      return undefined;
-    },
-    set() {
-      return true;
-    },
-    has(_, property) {
-      return (
-        property === "approved" ||
-        property === "rejected" ||
-        property === "expired" ||
-        property === "unchanged" ||
-        property === "pending"
-      );
-    },
-    ownKeys() {
-      return ["approved", "rejected", "expired", "unchanged", "pending"];
-    },
-    getOwnPropertyDescriptor(_, property) {
-      if (
-        property === "approved" ||
-        property === "rejected" ||
-        property === "expired" ||
-        property === "unchanged" ||
-        property === "pending"
-      ) {
-        return {
-          enumerable: true,
-          configurable: true,
-        };
-      }
-      return undefined;
-    },
-  });
-}
-
 function stabilizeFunctionOpts<T extends { opts?: Record<string, unknown> }>(fn: T): T {
   const original = fn.opts;
   if (!original) return fn;
@@ -413,91 +255,6 @@
       return Reflect.set(target, property, value, receiver);
     },
   });
-}
-
-export function parseReviewMd(markdown: string): ParsedReview {
-  const proposals: ParsedReviewProposal[] = [];
-
-  const lines = markdown.split(/\r?\n/u);
-  for (const line of lines) {
-    const match = /^\s*-\s*\[( |x|X|-)\]\s*(p-\d{8}-\d{3,})\b/u.exec(line);
-    if (!match?.[1] || !match[2]) continue;
-
-    const state = parseState(match[1]);
-    if (!state) continue;
-
-    proposals.push({
-      id: match[2],
-      state,
-    });
-  }
-
-  return { proposals };
-}
-
-export async function loadProposalState(redis: Pick<RedisLike, "lrange" | "hgetall">): Promise<ProposalStateSnapshot> {
-  const pending = await redis.lrange(REVIEW_PENDING_KEY, 0, -1);
-  const proposals: Record<string, StoredProposal> = {};
-
-  for (const id of pending) {
-    const stored = await redis.hgetall(proposalKey(id));
-    proposals[id] = {
-      id,
-      status: stored.status ?? "pending",
-      capturedAt: stored.capturedAt,
-      date: stored.date,
-      section: stored.section,
-      change: stored.change,
-    };
-  }
-
-  return { pending, proposals };
-}
-
-export function detectChanges(
-  currentState: unknown,
-  previousState: ProposalStateSnapshot,
-  now: Date = new Date()
-): ProposalDiff {
-  const current = parseCurrentState(currentState);
-  const approved: ProposalChange[] = [];
-  const rejected: ProposalChange[] = [];
-  const expired: ProposalChange[] = [];
-  const unchanged: ProposalChange[] = [];
-  const pending: string[] = [];
-
-  for (const id of previousState.pending) {
-    const proposal = previousState.proposals[id] ?? { id, status: "pending" };
-    const currentProposalState = current.get(id);
-
-    if (currentProposalState === "checked") {
-      approved.push({ id, proposal });
-      continue;
-    }
-
-    if (currentProposalState === "deleted" || currentProposalState === undefined) {
-      rejected.push({ id, proposal });
-      continue;
-    }
-
-    if (isExpired(proposal.capturedAt, now)) {
-      expired.push({ id, proposal });
-      continue;
-    }
-
-    unchanged.push({ id, proposal });
-    pending.push(id);
-  }
-
-  for (const [id, state] of current.entries()) {
-    if (previousState.pending.includes(id)) continue;
-    if (state === "unchecked") {
-      unchanged.push({ id, proposal: previousState.proposals[id] ?? { id, status: "pending" } });
-      pending.push(id);
-    }
-  }
-
-  return createStableDiff(approved, rejected, expired, unchanged, pending);
 }
 
 export async function promoteToMemory(proposalId: string): Promise<void> {


thinking
**Removing deprecated calls**
file update
M /private/tmp/agent-loop/loop-mlr8oxtg-b68bp4/packages/system-bus/src/inngest/functions/promote.ts
@@ -292,6 +292,5 @@
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
-export async function archiveProposal(proposalId: string, reason: "deleted" | "marked-rejected"): Promise<void> {
+export async function archiveProposal(proposalId: string, reason: string): Promise<void> {
   const redis = getRedisClient();
@@ -308,3 +307,2 @@
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
@@ -326,3 +324,2 @@
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
apply_patch(auto_approved=true) exited 0 in 44ms:
Success. Updated the following files:
M packages/system-bus/src/inngest/functions/promote.ts
file update:
diff --git a/packages/system-bus/src/inngest/functions/promote.ts b/packages/system-bus/src/inngest/functions/promote.ts
index 09730ecff690b4bfba745ef6f7b0a7469122608c..30490f348f1dcd2d30362631cc10c626983bfd89
--- a/packages/system-bus/src/inngest/functions/promote.ts
+++ b/packages/system-bus/src/inngest/functions/promote.ts
@@ -6,15 +6,6 @@
 
 export type ProposalState = "checked" | "unchecked" | "deleted";
 
-export type ParsedReviewProposal = {
-  id: string;
-  state: ProposalState;
-};
-
-export type ParsedReview = {
-  proposals: ParsedReviewProposal[];
-};
-
 export type StoredProposal = {
   id: string;
   status: string;
@@ -22,26 +13,8 @@
   date?: string;
   section?: string;
   change?: string;
-};
-
-export type ProposalStateSnapshot = {
-  pending: string[];
-  proposals: Record<string, StoredProposal>;
 };
 
-export type ProposalChange = {
-  id: string;
-  proposal?: StoredProposal;
-};
-
-export type ProposalDiff = {
-  approved: ProposalChange[];
-  rejected: ProposalChange[];
-  expired: ProposalChange[];
-  unchanged: ProposalChange[];
-  pending: string[];
-};
-
 type RedisLike = {
   lrange(key: string, start: number, stop: number): Promise<string[]>;
   hgetall(key: string): Promise<Record<string, string>>;
@@ -52,8 +25,6 @@
 };
 
 const REVIEW_PENDING_KEY = "memory:review:pending";
-const REVIEW_PATH_FILTER = "~/.joelclaw/workspace/REVIEW.md";
-const REVIEW_FILE_NAME = "REVIEW.md";
 const MEMORY_FILE_NAME = "MEMORY.md";
 const SEVEN_DAYS_MS = 7 * 24 * 60 * 60 * 1000;
 const REJECTED_PROPOSALS_HEADER = "### Rejected Proposals";
@@ -73,11 +44,6 @@
     redisClient.on("error", () => {});
   }
   return redisClient;
-}
-
-function getReviewPath(): string {
-  const home = process.env.HOME || process.env.USERPROFILE || "/Users/joel";
-  return join(home, ".joelclaw", "workspace", REVIEW_FILE_NAME);
 }
 
 function getMemoryPath(): string {
@@ -119,10 +85,6 @@
   if (date.getUTCMonth() !== monthIndex) return null;
   if (date.getUTCDate() !== day) return null;
   return date;
-}
-
-function escapeRegex(value: string): string {
-  return value.replace(/[.*+?^${}()|[\]\\]/gu, "\\$&");
 }
 
 function appendEntryToLogSection(markdown: string, header: string, entry: string): string {
@@ -159,21 +121,7 @@
   const next = appendEntryToLogSection(existing, header, entry);
   await Bun.write(logPath, next);
 }
-
-async function removeProposalFromReview(proposalId: string): Promise<void> {
-  const reviewPath = getReviewPath();
-  const reviewFile = Bun.file(reviewPath);
-  if (!(await reviewFile.exists())) return;
 
-  const markdown = await reviewFile.text();
-  const pattern = new RegExp(`^\\s*-\\s*\\[( |x|X|-)\\]\\s*${escapeRegex(proposalId)}\\b`, "u");
-  const nextLines = markdown.split(/\r?\n/u).filter((line) => !pattern.test(line));
-  const next = `${nextLines.join("\n").replace(/\n*$/u, "")}\n`;
-  if (next !== markdown) {
-    await Bun.write(reviewPath, next);
-  }
-}
-
 function isProposalOlderThanSevenDays(proposalId: string, now: Date = new Date()): boolean {
   const proposalDate = parseDateFromProposalId(proposalId);
   if (!proposalDate) return false;
@@ -278,112 +226,6 @@
     .find((line) => line.length > 0);
 
   return formatted ?? proposedText;
-}
-
-function parseState(raw: string): ProposalState | null {
-  const value = raw.trim().toLowerCase();
-  if (value === "x") return "checked";
-  if (value === "-") return "deleted";
-  if (value === "") return "unchecked";
-  return null;
-}
-
-function parseCurrentState(currentState: unknown): Map<string, ProposalState> {
-  const map = new Map<string, ProposalState>();
-
-  if (!currentState || typeof currentState !== "object") return map;
-  const proposals = (currentState as { proposals?: unknown }).proposals;
-  if (!Array.isArray(proposals)) return map;
-
-  for (const proposal of proposals) {
-    if (!proposal || typeof proposal !== "object") continue;
-    const id = (proposal as { id?: unknown }).id;
-    const state = (proposal as { state?: unknown }).state;
-    if (typeof id !== "string") continue;
-    if (state === "checked" || state === "unchecked" || state === "deleted") {
-      map.set(id, state);
-    }
-  }
-
-  return map;
-}
-
-function isExpired(capturedAt: string | undefined, now: Date): boolean {
-  if (!capturedAt) return false;
-  const created = new Date(capturedAt);
-  if (Number.isNaN(created.getTime())) return false;
-  return now.getTime() - created.getTime() >= SEVEN_DAYS_MS;
-}
-
-function extractContentPath(eventData: unknown): string | null {
-  if (!eventData || typeof eventData !== "object") return null;
-  const rec = eventData as Record<string, unknown>;
-
-  const candidates = [rec.path, rec.filePath, rec.filepath];
-  for (const candidate of candidates) {
-    if (typeof candidate === "string" && candidate.length > 0) {
-      return candidate;
-    }
-  }
-
-  return null;
-}
-
-function createStableDiff(
-  approved: ProposalChange[],
-  rejected: ProposalChange[],
-  expired: ProposalChange[],
-  unchanged: ProposalChange[],
-  pending: string[]
-): ProposalDiff {
-  const data = {
-    approved,
-    rejected,
-    expired,
-    unchanged,
-    pending,
-  } satisfies ProposalDiff;
-
-  return new Proxy({} as ProposalDiff, {
-    get(_, property) {
-      if (property === "approved") return data.approved.map((item) => ({ ...item }));
-      if (property === "rejected") return data.rejected.map((item) => ({ ...item }));
-      if (property === "expired") return data.expired.map((item) => ({ ...item }));
-      if (property === "unchanged") return data.unchanged.map((item) => ({ ...item }));
-      if (property === "pending") return [...data.pending];
-      return undefined;
-    },
-    set() {
-      return true;
-    },
-    has(_, property) {
-      return (
-        property === "approved" ||
-        property === "rejected" ||
-        property === "expired" ||
-        property === "unchanged" ||
-        property === "pending"
-      );
-    },
-    ownKeys() {
-      return ["approved", "rejected", "expired", "unchanged", "pending"];
-    },
-    getOwnPropertyDescriptor(_, property) {
-      if (
-        property === "approved" ||
-        property === "rejected" ||
-        property === "expired" ||
-        property === "unchanged" ||
-        property === "pending"
-      ) {
-        return {
-          enumerable: true,
-          configurable: true,
-        };
-      }
-      return undefined;
-    },
-  });
 }
 
 function stabilizeFunctionOpts<T extends { opts?: Record<string, unknown> }>(fn: T): T {
@@ -413,91 +255,6 @@
       return Reflect.set(target, property, value, receiver);
     },
   });
-}
-
-export function parseReviewMd(markdown: string): ParsedReview {
-  const proposals: ParsedReviewProposal[] = [];
-
-  const lines = markdown.split(/\r?\n/u);
-  for (const line of lines) {
-    const match = /^\s*-\s*\[( |x|X|-)\]\s*(p-\d{8}-\d{3,})\b/u.exec(line);
-    if (!match?.[1] || !match[2]) continue;
-
-    const state = parseState(match[1]);
-    if (!state) continue;
-
-    proposals.push({
-      id: match[2],
-      state,
-    });
-  }
-
-  return { proposals };
-}
-
-export async function loadProposalState(redis: Pick<RedisLike, "lrange" | "hgetall">): Promise<ProposalStateSnapshot> {
-  const pending = await redis.lrange(REVIEW_PENDING_KEY, 0, -1);
-  const proposals: Record<string, StoredProposal> = {};
-
-  for (const id of pending) {
-    const stored = await redis.hgetall(proposalKey(id));
-    proposals[id] = {
-      id,
-      status: stored.status ?? "pending",
-      capturedAt: stored.capturedAt,
-      date: stored.date,
-      section: stored.section,
-      change: stored.change,
-    };
-  }
-
-  return { pending, proposals };
-}
-
-export function detectChanges(
-  currentState: unknown,
-  previousState: ProposalStateSnapshot,
-  now: Date = new Date()
-): ProposalDiff {
-  const current = parseCurrentState(currentState);
-  const approved: ProposalChange[] = [];
-  const rejected: ProposalChange[] = [];
-  const expired: ProposalChange[] = [];
-  const unchanged: ProposalChange[] = [];
-  const pending: string[] = [];
-
-  for (const id of previousState.pending) {
-    const proposal = previousState.proposals[id] ?? { id, status: "pending" };
-    const currentProposalState = current.get(id);
-
-    if (currentProposalState === "checked") {
-      approved.push({ id, proposal });
-      continue;
-    }
-
-    if (currentProposalState === "deleted" || currentProposalState === undefined) {
-      rejected.push({ id, proposal });
-      continue;
-    }
-
-    if (isExpired(proposal.capturedAt, now)) {
-      expired.push({ id, proposal });
-      continue;
-    }
-
-    unchanged.push({ id, proposal });
-    pending.push(id);
-  }
-
-  for (const [id, state] of current.entries()) {
-    if (previousState.pending.includes(id)) continue;
-    if (state === "unchecked") {
-      unchanged.push({ id, proposal: previousState.proposals[id] ?? { id, status: "pending" } });
-      pending.push(id);
-    }
-  }
-
-  return createStableDiff(approved, rejected, expired, unchanged, pending);
 }
 
 export async function promoteToMemory(proposalId: string): Promise<void> {
@@ -533,10 +290,9 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
-export async function archiveProposal(proposalId: string, reason: "deleted" | "marked-rejected"): Promise<void> {
+export async function archiveProposal(proposalId: string, reason: string): Promise<void> {
   const redis = getRedisClient();
   const key = proposalKey(proposalId);
   const proposal = await redis.hgetall(key);
@@ -549,7 +305,6 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
 export async function expireProposal(proposalId: string): Promise<void> {
@@ -567,7 +322,6 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
 const promoteFunction = stabilizeFunctionOpts(

file update:
diff --git a/packages/system-bus/src/inngest/functions/promote.ts b/packages/system-bus/src/inngest/functions/promote.ts
index 09730ecff690b4bfba745ef6f7b0a7469122608c..30490f348f1dcd2d30362631cc10c626983bfd89
--- a/packages/system-bus/src/inngest/functions/promote.ts
+++ b/packages/system-bus/src/inngest/functions/promote.ts
@@ -6,15 +6,6 @@
 
 export type ProposalState = "checked" | "unchecked" | "deleted";
 
-export type ParsedReviewProposal = {
-  id: string;
-  state: ProposalState;
-};
-
-export type ParsedReview = {
-  proposals: ParsedReviewProposal[];
-};
-
 export type StoredProposal = {
   id: string;
   status: string;
@@ -22,26 +13,8 @@
   date?: string;
   section?: string;
   change?: string;
-};
-
-export type ProposalStateSnapshot = {
-  pending: string[];
-  proposals: Record<string, StoredProposal>;
 };
 
-export type ProposalChange = {
-  id: string;
-  proposal?: StoredProposal;
-};
-
-export type ProposalDiff = {
-  approved: ProposalChange[];
-  rejected: ProposalChange[];
-  expired: ProposalChange[];
-  unchanged: ProposalChange[];
-  pending: string[];
-};
-
 type RedisLike = {
   lrange(key: string, start: number, stop: number): Promise<string[]>;
   hgetall(key: string): Promise<Record<string, string>>;
@@ -52,8 +25,6 @@
 };
 
 const REVIEW_PENDING_KEY = "memory:review:pending";
-const REVIEW_PATH_FILTER = "~/.joelclaw/workspace/REVIEW.md";
-const REVIEW_FILE_NAME = "REVIEW.md";
 const MEMORY_FILE_NAME = "MEMORY.md";
 const SEVEN_DAYS_MS = 7 * 24 * 60 * 60 * 1000;
 const REJECTED_PROPOSALS_HEADER = "### Rejected Proposals";
@@ -73,11 +44,6 @@
     redisClient.on("error", () => {});
   }
   return redisClient;
-}
-
-function getReviewPath(): string {
-  const home = process.env.HOME || process.env.USERPROFILE || "/Users/joel";
-  return join(home, ".joelclaw", "workspace", REVIEW_FILE_NAME);
 }
 
 function getMemoryPath(): string {
@@ -119,10 +85,6 @@
   if (date.getUTCMonth() !== monthIndex) return null;
   if (date.getUTCDate() !== day) return null;
   return date;
-}
-
-function escapeRegex(value: string): string {
-  return value.replace(/[.*+?^${}()|[\]\\]/gu, "\\$&");
 }
 
 function appendEntryToLogSection(markdown: string, header: string, entry: string): string {
@@ -159,21 +121,7 @@
   const next = appendEntryToLogSection(existing, header, entry);
   await Bun.write(logPath, next);
 }
-
-async function removeProposalFromReview(proposalId: string): Promise<void> {
-  const reviewPath = getReviewPath();
-  const reviewFile = Bun.file(reviewPath);
-  if (!(await reviewFile.exists())) return;
 
-  const markdown = await reviewFile.text();
-  const pattern = new RegExp(`^\\s*-\\s*\\[( |x|X|-)\\]\\s*${escapeRegex(proposalId)}\\b`, "u");
-  const nextLines = markdown.split(/\r?\n/u).filter((line) => !pattern.test(line));
-  const next = `${nextLines.join("\n").replace(/\n*$/u, "")}\n`;
-  if (next !== markdown) {
-    await Bun.write(reviewPath, next);
-  }
-}
-
 function isProposalOlderThanSevenDays(proposalId: string, now: Date = new Date()): boolean {
   const proposalDate = parseDateFromProposalId(proposalId);
   if (!proposalDate) return false;
@@ -278,112 +226,6 @@
     .find((line) => line.length > 0);
 
   return formatted ?? proposedText;
-}
-
-function parseState(raw: string): ProposalState | null {
-  const value = raw.trim().toLowerCase();
-  if (value === "x") return "checked";
-  if (value === "-") return "deleted";
-  if (value === "") return "unchecked";
-  return null;
-}
-
-function parseCurrentState(currentState: unknown): Map<string, ProposalState> {
-  const map = new Map<string, ProposalState>();
-
-  if (!currentState || typeof currentState !== "object") return map;
-  const proposals = (currentState as { proposals?: unknown }).proposals;
-  if (!Array.isArray(proposals)) return map;
-
-  for (const proposal of proposals) {
-    if (!proposal || typeof proposal !== "object") continue;
-    const id = (proposal as { id?: unknown }).id;
-    const state = (proposal as { state?: unknown }).state;
-    if (typeof id !== "string") continue;
-    if (state === "checked" || state === "unchecked" || state === "deleted") {
-      map.set(id, state);
-    }
-  }
-
-  return map;
-}
-
-function isExpired(capturedAt: string | undefined, now: Date): boolean {
-  if (!capturedAt) return false;
-  const created = new Date(capturedAt);
-  if (Number.isNaN(created.getTime())) return false;
-  return now.getTime() - created.getTime() >= SEVEN_DAYS_MS;
-}
-
-function extractContentPath(eventData: unknown): string | null {
-  if (!eventData || typeof eventData !== "object") return null;
-  const rec = eventData as Record<string, unknown>;
-
-  const candidates = [rec.path, rec.filePath, rec.filepath];
-  for (const candidate of candidates) {
-    if (typeof candidate === "string" && candidate.length > 0) {
-      return candidate;
-    }
-  }
-
-  return null;
-}
-
-function createStableDiff(
-  approved: ProposalChange[],
-  rejected: ProposalChange[],
-  expired: ProposalChange[],
-  unchanged: ProposalChange[],
-  pending: string[]
-): ProposalDiff {
-  const data = {
-    approved,
-    rejected,
-    expired,
-    unchanged,
-    pending,
-  } satisfies ProposalDiff;
-
-  return new Proxy({} as ProposalDiff, {
-    get(_, property) {
-      if (property === "approved") return data.approved.map((item) => ({ ...item }));
-      if (property === "rejected") return data.rejected.map((item) => ({ ...item }));
-      if (property === "expired") return data.expired.map((item) => ({ ...item }));
-      if (property === "unchanged") return data.unchanged.map((item) => ({ ...item }));
-      if (property === "pending") return [...data.pending];
-      return undefined;
-    },
-    set() {
-      return true;
-    },
-    has(_, property) {
-      return (
-        property === "approved" ||
-        property === "rejected" ||
-        property === "expired" ||
-        property === "unchanged" ||
-        property === "pending"
-      );
-    },
-    ownKeys() {
-      return ["approved", "rejected", "expired", "unchanged", "pending"];
-    },
-    getOwnPropertyDescriptor(_, property) {
-      if (
-        property === "approved" ||
-        property === "rejected" ||
-        property === "expired" ||
-        property === "unchanged" ||
-        property === "pending"
-      ) {
-        return {
-          enumerable: true,
-          configurable: true,
-        };
-      }
-      return undefined;
-    },
-  });
 }
 
 function stabilizeFunctionOpts<T extends { opts?: Record<string, unknown> }>(fn: T): T {
@@ -413,91 +255,6 @@
       return Reflect.set(target, property, value, receiver);
     },
   });
-}
-
-export function parseReviewMd(markdown: string): ParsedReview {
-  const proposals: ParsedReviewProposal[] = [];
-
-  const lines = markdown.split(/\r?\n/u);
-  for (const line of lines) {
-    const match = /^\s*-\s*\[( |x|X|-)\]\s*(p-\d{8}-\d{3,})\b/u.exec(line);
-    if (!match?.[1] || !match[2]) continue;
-
-    const state = parseState(match[1]);
-    if (!state) continue;
-
-    proposals.push({
-      id: match[2],
-      state,
-    });
-  }
-
-  return { proposals };
-}
-
-export async function loadProposalState(redis: Pick<RedisLike, "lrange" | "hgetall">): Promise<ProposalStateSnapshot> {
-  const pending = await redis.lrange(REVIEW_PENDING_KEY, 0, -1);
-  const proposals: Record<string, StoredProposal> = {};
-
-  for (const id of pending) {
-    const stored = await redis.hgetall(proposalKey(id));
-    proposals[id] = {
-      id,
-      status: stored.status ?? "pending",
-      capturedAt: stored.capturedAt,
-      date: stored.date,
-      section: stored.section,
-      change: stored.change,
-    };
-  }
-
-  return { pending, proposals };
-}
-
-export function detectChanges(
-  currentState: unknown,
-  previousState: ProposalStateSnapshot,
-  now: Date = new Date()
-): ProposalDiff {
-  const current = parseCurrentState(currentState);
-  const approved: ProposalChange[] = [];
-  const rejected: ProposalChange[] = [];
-  const expired: ProposalChange[] = [];
-  const unchanged: ProposalChange[] = [];
-  const pending: string[] = [];
-
-  for (const id of previousState.pending) {
-    const proposal = previousState.proposals[id] ?? { id, status: "pending" };
-    const currentProposalState = current.get(id);
-
-    if (currentProposalState === "checked") {
-      approved.push({ id, proposal });
-      continue;
-    }
-
-    if (currentProposalState === "deleted" || currentProposalState === undefined) {
-      rejected.push({ id, proposal });
-      continue;
-    }
-
-    if (isExpired(proposal.capturedAt, now)) {
-      expired.push({ id, proposal });
-      continue;
-    }
-
-    unchanged.push({ id, proposal });
-    pending.push(id);
-  }
-
-  for (const [id, state] of current.entries()) {
-    if (previousState.pending.includes(id)) continue;
-    if (state === "unchecked") {
-      unchanged.push({ id, proposal: previousState.proposals[id] ?? { id, status: "pending" } });
-      pending.push(id);
-    }
-  }
-
-  return createStableDiff(approved, rejected, expired, unchanged, pending);
 }
 
 export async function promoteToMemory(proposalId: string): Promise<void> {
@@ -533,10 +290,9 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
-export async function archiveProposal(proposalId: string, reason: "deleted" | "marked-rejected"): Promise<void> {
+export async function archiveProposal(proposalId: string, reason: string): Promise<void> {
   const redis = getRedisClient();
   const key = proposalKey(proposalId);
   const proposal = await redis.hgetall(key);
@@ -549,7 +305,6 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
 export async function expireProposal(proposalId: string): Promise<void> {
@@ -567,7 +322,6 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
 const promoteFunction = stabilizeFunctionOpts(


thinking
**Rewriting promotion section**
file update
M /private/tmp/agent-loop/loop-mlr8oxtg-b68bp4/packages/system-bus/src/inngest/functions/promote.ts
@@ -328,106 +328,54 @@
   inngest.createFunction(
-  {
-    id: "memory/review-promote",
-    name: "Promote Review Decisions",
-  },
-  [
     {
-      event: "content/updated",
-      if: `event.data.path == \"${REVIEW_PATH_FILTER}\" || event.data.path.endsWith(\"/${REVIEW_FILE_NAME}\")`,
+      id: "memory/review-promote",
+      name: "Promote Review Decisions",
     },
-    { cron: "0 8 * * *" },
-  ],
-  async ({ event, step }) => {
-    const shouldSkip = await step.run("filter-review-events", async () => {
-      if (event.name !== "content/updated") return false;
-      const updatedPath = extractContentPath(event.data);
-      if (!updatedPath) return false;
-      return !updatedPath.toLowerCase().endsWith(`/${REVIEW_FILE_NAME.toLowerCase()}`);
-    });
-
-    if (shouldSkip) {
-      return {
-        skipped: true,
-        reason: "content/updated path does not target REVIEW.md",
-      };
-    }
+    [{ event: "memory/proposal.approved" }, { event: "memory/proposal.rejected" }, { cron: "0 8 * * *" }],
+    async ({ event, step }) => {
+      if (event.name === "memory/proposal.approved") {
+        const proposalId = await step.run("resolve-approved-proposal-id", async () => {
+          const id = (event.data as { proposalId?: unknown }).proposalId;
+          if (typeof id !== "string" || id.trim().length === 0) {
+            throw new Error("memory/proposal.approved requires event.data.proposalId");
+          }
+          return id;
+        });
 
-    const parsed = await step.run("parse-review", async () => {
-      const reviewFile = Bun.file(getReviewPath());
-      if (!(await reviewFile.exists())) {
-        return { proposals: [] } as ParsedReview;
+        await step.run("promote-approved-proposal", async () => promoteToMemory(proposalId));
+        return { approved: [proposalId] };
       }
 
-      const markdown = await reviewFile.text();
-      return parseReviewMd(markdown);
-    });
-
-    const previous = await step.run("load-state", async () => {
-      const redis = getRedisClient();
-      return loadProposalState(redis);
-    });
-
-    const changes = await step.run("detect-changes", async () => detectChanges(parsed, previous));
+      if (event.name === "memory/proposal.rejected") {
+        const payload = await step.run("resolve-rejected-payload", async () => {
+          const id = (event.data as { proposalId?: unknown }).proposalId;
+          const reason = (event.data as { reason?: unknown }).reason;
+          if (typeof id !== "string" || id.trim().length === 0) {
+            throw new Error("memory/proposal.rejected requires event.data.proposalId");
+          }
+          if (typeof reason !== "string" || reason.trim().length === 0) {
+            throw new Error("memory/proposal.rejected requires event.data.reason");
+          }
+          return { proposalId: id, reason };
+        });
 
-    await step.run("route", async () => {
-      const parsedById = new Map(parsed.proposals.map((proposal) => [proposal.id, proposal]));
-
-      for (const change of changes.approved) {
-        await promoteToMemory(change.id);
+        await step.run("archive-rejected-proposal", async () => archiveProposal(payload.proposalId, payload.reason));
+        return { rejected: [payload.proposalId], reason: payload.reason };
       }
 
-      for (const change of changes.rejected) {
-        const reason = parsedById.get(change.id)?.state === "deleted" ? "marked-rejected" : "deleted";
-        await archiveProposal(change.id, reason);
-      }
-
-      for (const change of changes.expired) {
-        await expireProposal(change.id);
-      }
-    });
-
-    const updateState = await step.run("update-state", async () => {
-      const redis = getRedisClient();
-      const nextPending = [...new Set(changes.pending)];
+      const expiredIds = await step.run("expire-stale-proposals", async () => {
+        const redis = getRedisClient();
+        const pending = await redis.lrange(REVIEW_PENDING_KEY, 0, -1);
+        const expired: string[] = [];
 
-      await redis.del(REVIEW_PENDING_KEY);
-      if (nextPending.length > 0) {
-        await redis.rpush(REVIEW_PENDING_KEY, ...nextPending);
-      }
-
-      const parsedById = new Map(parsed.proposals.map((proposal) => [proposal.id, proposal]));
-      for (const id of nextPending) {
-        const existing = previous.proposals[id];
-        const parsedProposal = parsedById.get(id);
-        await redis.hset(
-          proposalKey(id),
-          "id",
-          id,
-          "status",
-          "pending",
-          "state",
-          parsedProposal?.state ?? "unchecked",
-          "capturedAt",
-          existing?.capturedAt ?? new Date().toISOString(),
-          "date",
-          existing?.date ?? new Date().toISOString().slice(0, 10),
-          "section",
-          existing?.section ?? "",
-          "change",
-          existing?.change ?? ""
-        );
-      }
+        for (const proposalId of pending) {
+          if (!isProposalOlderThanSevenDays(proposalId)) continue;
+          await expireProposal(proposalId);
+          expired.push(proposalId);
+        }
 
-      return {
-        pending: nextPending,
-      };
-    });
+        return expired;
+      });
 
-    return {
-      approved: changes.approved.map((item) => item.id),
-      rejected: changes.rejected.map((item) => item.id),
-      expired: changes.expired.map((item) => item.id),
-      pending: updateState.pending,
-    };
-  }
+      return { expired: expiredIds };
+    }
   )
apply_patch(auto_approved=true) exited 0 in 53ms:
Success. Updated the following files:
M packages/system-bus/src/inngest/functions/promote.ts
file update:
diff --git a/packages/system-bus/src/inngest/functions/promote.ts b/packages/system-bus/src/inngest/functions/promote.ts
index 09730ecff690b4bfba745ef6f7b0a7469122608c..664e19e27ff0bfdc686be96c6935f256e17e25b6
--- a/packages/system-bus/src/inngest/functions/promote.ts
+++ b/packages/system-bus/src/inngest/functions/promote.ts
@@ -6,15 +6,6 @@
 
 export type ProposalState = "checked" | "unchecked" | "deleted";
 
-export type ParsedReviewProposal = {
-  id: string;
-  state: ProposalState;
-};
-
-export type ParsedReview = {
-  proposals: ParsedReviewProposal[];
-};
-
 export type StoredProposal = {
   id: string;
   status: string;
@@ -22,24 +13,6 @@
   date?: string;
   section?: string;
   change?: string;
-};
-
-export type ProposalStateSnapshot = {
-  pending: string[];
-  proposals: Record<string, StoredProposal>;
-};
-
-export type ProposalChange = {
-  id: string;
-  proposal?: StoredProposal;
-};
-
-export type ProposalDiff = {
-  approved: ProposalChange[];
-  rejected: ProposalChange[];
-  expired: ProposalChange[];
-  unchanged: ProposalChange[];
-  pending: string[];
 };
 
 type RedisLike = {
@@ -52,8 +25,6 @@
 };
 
 const REVIEW_PENDING_KEY = "memory:review:pending";
-const REVIEW_PATH_FILTER = "~/.joelclaw/workspace/REVIEW.md";
-const REVIEW_FILE_NAME = "REVIEW.md";
 const MEMORY_FILE_NAME = "MEMORY.md";
 const SEVEN_DAYS_MS = 7 * 24 * 60 * 60 * 1000;
 const REJECTED_PROPOSALS_HEADER = "### Rejected Proposals";
@@ -73,11 +44,6 @@
     redisClient.on("error", () => {});
   }
   return redisClient;
-}
-
-function getReviewPath(): string {
-  const home = process.env.HOME || process.env.USERPROFILE || "/Users/joel";
-  return join(home, ".joelclaw", "workspace", REVIEW_FILE_NAME);
 }
 
 function getMemoryPath(): string {
@@ -119,10 +85,6 @@
   if (date.getUTCMonth() !== monthIndex) return null;
   if (date.getUTCDate() !== day) return null;
   return date;
-}
-
-function escapeRegex(value: string): string {
-  return value.replace(/[.*+?^${}()|[\]\\]/gu, "\\$&");
 }
 
 function appendEntryToLogSection(markdown: string, header: string, entry: string): string {
@@ -158,20 +120,6 @@
   const existing = (await logFile.exists()) ? await logFile.text() : "";
   const next = appendEntryToLogSection(existing, header, entry);
   await Bun.write(logPath, next);
-}
-
-async function removeProposalFromReview(proposalId: string): Promise<void> {
-  const reviewPath = getReviewPath();
-  const reviewFile = Bun.file(reviewPath);
-  if (!(await reviewFile.exists())) return;
-
-  const markdown = await reviewFile.text();
-  const pattern = new RegExp(`^\\s*-\\s*\\[( |x|X|-)\\]\\s*${escapeRegex(proposalId)}\\b`, "u");
-  const nextLines = markdown.split(/\r?\n/u).filter((line) => !pattern.test(line));
-  const next = `${nextLines.join("\n").replace(/\n*$/u, "")}\n`;
-  if (next !== markdown) {
-    await Bun.write(reviewPath, next);
-  }
 }
 
 function isProposalOlderThanSevenDays(proposalId: string, now: Date = new Date()): boolean {
@@ -278,114 +226,8 @@
     .find((line) => line.length > 0);
 
   return formatted ?? proposedText;
-}
-
-function parseState(raw: string): ProposalState | null {
-  const value = raw.trim().toLowerCase();
-  if (value === "x") return "checked";
-  if (value === "-") return "deleted";
-  if (value === "") return "unchecked";
-  return null;
-}
-
-function parseCurrentState(currentState: unknown): Map<string, ProposalState> {
-  const map = new Map<string, ProposalState>();
-
-  if (!currentState || typeof currentState !== "object") return map;
-  const proposals = (currentState as { proposals?: unknown }).proposals;
-  if (!Array.isArray(proposals)) return map;
-
-  for (const proposal of proposals) {
-    if (!proposal || typeof proposal !== "object") continue;
-    const id = (proposal as { id?: unknown }).id;
-    const state = (proposal as { state?: unknown }).state;
-    if (typeof id !== "string") continue;
-    if (state === "checked" || state === "unchecked" || state === "deleted") {
-      map.set(id, state);
-    }
-  }
-
-  return map;
-}
-
-function isExpired(capturedAt: string | undefined, now: Date): boolean {
-  if (!capturedAt) return false;
-  const created = new Date(capturedAt);
-  if (Number.isNaN(created.getTime())) return false;
-  return now.getTime() - created.getTime() >= SEVEN_DAYS_MS;
 }
-
-function extractContentPath(eventData: unknown): string | null {
-  if (!eventData || typeof eventData !== "object") return null;
-  const rec = eventData as Record<string, unknown>;
 
-  const candidates = [rec.path, rec.filePath, rec.filepath];
-  for (const candidate of candidates) {
-    if (typeof candidate === "string" && candidate.length > 0) {
-      return candidate;
-    }
-  }
-
-  return null;
-}
-
-function createStableDiff(
-  approved: ProposalChange[],
-  rejected: ProposalChange[],
-  expired: ProposalChange[],
-  unchanged: ProposalChange[],
-  pending: string[]
-): ProposalDiff {
-  const data = {
-    approved,
-    rejected,
-    expired,
-    unchanged,
-    pending,
-  } satisfies ProposalDiff;
-
-  return new Proxy({} as ProposalDiff, {
-    get(_, property) {
-      if (property === "approved") return data.approved.map((item) => ({ ...item }));
-      if (property === "rejected") return data.rejected.map((item) => ({ ...item }));
-      if (property === "expired") return data.expired.map((item) => ({ ...item }));
-      if (property === "unchanged") return data.unchanged.map((item) => ({ ...item }));
-      if (property === "pending") return [...data.pending];
-      return undefined;
-    },
-    set() {
-      return true;
-    },
-    has(_, property) {
-      return (
-        property === "approved" ||
-        property === "rejected" ||
-        property === "expired" ||
-        property === "unchanged" ||
-        property === "pending"
-      );
-    },
-    ownKeys() {
-      return ["approved", "rejected", "expired", "unchanged", "pending"];
-    },
-    getOwnPropertyDescriptor(_, property) {
-      if (
-        property === "approved" ||
-        property === "rejected" ||
-        property === "expired" ||
-        property === "unchanged" ||
-        property === "pending"
-      ) {
-        return {
-          enumerable: true,
-          configurable: true,
-        };
-      }
-      return undefined;
-    },
-  });
-}
-
 function stabilizeFunctionOpts<T extends { opts?: Record<string, unknown> }>(fn: T): T {
   const original = fn.opts;
   if (!original) return fn;
@@ -413,91 +255,6 @@
       return Reflect.set(target, property, value, receiver);
     },
   });
-}
-
-export function parseReviewMd(markdown: string): ParsedReview {
-  const proposals: ParsedReviewProposal[] = [];
-
-  const lines = markdown.split(/\r?\n/u);
-  for (const line of lines) {
-    const match = /^\s*-\s*\[( |x|X|-)\]\s*(p-\d{8}-\d{3,})\b/u.exec(line);
-    if (!match?.[1] || !match[2]) continue;
-
-    const state = parseState(match[1]);
-    if (!state) continue;
-
-    proposals.push({
-      id: match[2],
-      state,
-    });
-  }
-
-  return { proposals };
-}
-
-export async function loadProposalState(redis: Pick<RedisLike, "lrange" | "hgetall">): Promise<ProposalStateSnapshot> {
-  const pending = await redis.lrange(REVIEW_PENDING_KEY, 0, -1);
-  const proposals: Record<string, StoredProposal> = {};
-
-  for (const id of pending) {
-    const stored = await redis.hgetall(proposalKey(id));
-    proposals[id] = {
-      id,
-      status: stored.status ?? "pending",
-      capturedAt: stored.capturedAt,
-      date: stored.date,
-      section: stored.section,
-      change: stored.change,
-    };
-  }
-
-  return { pending, proposals };
-}
-
-export function detectChanges(
-  currentState: unknown,
-  previousState: ProposalStateSnapshot,
-  now: Date = new Date()
-): ProposalDiff {
-  const current = parseCurrentState(currentState);
-  const approved: ProposalChange[] = [];
-  const rejected: ProposalChange[] = [];
-  const expired: ProposalChange[] = [];
-  const unchanged: ProposalChange[] = [];
-  const pending: string[] = [];
-
-  for (const id of previousState.pending) {
-    const proposal = previousState.proposals[id] ?? { id, status: "pending" };
-    const currentProposalState = current.get(id);
-
-    if (currentProposalState === "checked") {
-      approved.push({ id, proposal });
-      continue;
-    }
-
-    if (currentProposalState === "deleted" || currentProposalState === undefined) {
-      rejected.push({ id, proposal });
-      continue;
-    }
-
-    if (isExpired(proposal.capturedAt, now)) {
-      expired.push({ id, proposal });
-      continue;
-    }
-
-    unchanged.push({ id, proposal });
-    pending.push(id);
-  }
-
-  for (const [id, state] of current.entries()) {
-    if (previousState.pending.includes(id)) continue;
-    if (state === "unchecked") {
-      unchanged.push({ id, proposal: previousState.proposals[id] ?? { id, status: "pending" } });
-      pending.push(id);
-    }
-  }
-
-  return createStableDiff(approved, rejected, expired, unchanged, pending);
 }
 
 export async function promoteToMemory(proposalId: string): Promise<void> {
@@ -533,10 +290,9 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
-export async function archiveProposal(proposalId: string, reason: "deleted" | "marked-rejected"): Promise<void> {
+export async function archiveProposal(proposalId: string, reason: string): Promise<void> {
   const redis = getRedisClient();
   const key = proposalKey(proposalId);
   const proposal = await redis.hgetall(key);
@@ -549,7 +305,6 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
 export async function expireProposal(proposalId: string): Promise<void> {
@@ -567,115 +322,62 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
 const promoteFunction = stabilizeFunctionOpts(
   inngest.createFunction(
-  {
-    id: "memory/review-promote",
-    name: "Promote Review Decisions",
-  },
-  [
     {
-      event: "content/updated",
-      if: `event.data.path == \"${REVIEW_PATH_FILTER}\" || event.data.path.endsWith(\"/${REVIEW_FILE_NAME}\")`,
+      id: "memory/review-promote",
+      name: "Promote Review Decisions",
     },
-    { cron: "0 8 * * *" },
-  ],
-  async ({ event, step }) => {
-    const shouldSkip = await step.run("filter-review-events", async () => {
-      if (event.name !== "content/updated") return false;
-      const updatedPath = extractContentPath(event.data);
-      if (!updatedPath) return false;
-      return !updatedPath.toLowerCase().endsWith(`/${REVIEW_FILE_NAME.toLowerCase()}`);
-    });
-
-    if (shouldSkip) {
-      return {
-        skipped: true,
-        reason: "content/updated path does not target REVIEW.md",
-      };
-    }
-
-    const parsed = await step.run("parse-review", async () => {
-      const reviewFile = Bun.file(getReviewPath());
-      if (!(await reviewFile.exists())) {
-        return { proposals: [] } as ParsedReview;
-      }
-
-      const markdown = await reviewFile.text();
-      return parseReviewMd(markdown);
-    });
-
-    const previous = await step.run("load-state", async () => {
-      const redis = getRedisClient();
-      return loadProposalState(redis);
-    });
+    [{ event: "memory/proposal.approved" }, { event: "memory/proposal.rejected" }, { cron: "0 8 * * *" }],
+    async ({ event, step }) => {
+      if (event.name === "memory/proposal.approved") {
+        const proposalId = await step.run("resolve-approved-proposal-id", async () => {
+          const id = (event.data as { proposalId?: unknown }).proposalId;
+          if (typeof id !== "string" || id.trim().length === 0) {
+            throw new Error("memory/proposal.approved requires event.data.proposalId");
+          }
+          return id;
+        });
 
-    const changes = await step.run("detect-changes", async () => detectChanges(parsed, previous));
-
-    await step.run("route", async () => {
-      const parsedById = new Map(parsed.proposals.map((proposal) => [proposal.id, proposal]));
-
-      for (const change of changes.approved) {
-        await promoteToMemory(change.id);
+        await step.run("promote-approved-proposal", async () => promoteToMemory(proposalId));
+        return { approved: [proposalId] };
       }
 
-      for (const change of changes.rejected) {
-        const reason = parsedById.get(change.id)?.state === "deleted" ? "marked-rejected" : "deleted";
-        await archiveProposal(change.id, reason);
-      }
+      if (event.name === "memory/proposal.rejected") {
+        const payload = await step.run("resolve-rejected-payload", async () => {
+          const id = (event.data as { proposalId?: unknown }).proposalId;
+          const reason = (event.data as { reason?: unknown }).reason;
+          if (typeof id !== "string" || id.trim().length === 0) {
+            throw new Error("memory/proposal.rejected requires event.data.proposalId");
+          }
+          if (typeof reason !== "string" || reason.trim().length === 0) {
+            throw new Error("memory/proposal.rejected requires event.data.reason");
+          }
+          return { proposalId: id, reason };
+        });
 
-      for (const change of changes.expired) {
-        await expireProposal(change.id);
+        await step.run("archive-rejected-proposal", async () => archiveProposal(payload.proposalId, payload.reason));
+        return { rejected: [payload.proposalId], reason: payload.reason };
       }
-    });
-
-    const updateState = await step.run("update-state", async () => {
-      const redis = getRedisClient();
-      const nextPending = [...new Set(changes.pending)];
 
-      await redis.del(REVIEW_PENDING_KEY);
-      if (nextPending.length > 0) {
-        await redis.rpush(REVIEW_PENDING_KEY, ...nextPending);
-      }
+      const expiredIds = await step.run("expire-stale-proposals", async () => {
+        const redis = getRedisClient();
+        const pending = await redis.lrange(REVIEW_PENDING_KEY, 0, -1);
+        const expired: string[] = [];
 
-      const parsedById = new Map(parsed.proposals.map((proposal) => [proposal.id, proposal]));
-      for (const id of nextPending) {
-        const existing = previous.proposals[id];
-        const parsedProposal = parsedById.get(id);
-        await redis.hset(
-          proposalKey(id),
-          "id",
-          id,
-          "status",
-          "pending",
-          "state",
-          parsedProposal?.state ?? "unchecked",
-          "capturedAt",
-          existing?.capturedAt ?? new Date().toISOString(),
-          "date",
-          existing?.date ?? new Date().toISOString().slice(0, 10),
-          "section",
-          existing?.section ?? "",
-          "change",
-          existing?.change ?? ""
-        );
-      }
+        for (const proposalId of pending) {
+          if (!isProposalOlderThanSevenDays(proposalId)) continue;
+          await expireProposal(proposalId);
+          expired.push(proposalId);
+        }
 
-      return {
-        pending: nextPending,
-      };
-    });
+        return expired;
+      });
 
-    return {
-      approved: changes.approved.map((item) => item.id),
-      rejected: changes.rejected.map((item) => item.id),
-      expired: changes.expired.map((item) => item.id),
-      pending: updateState.pending,
-    };
-  }
+      return { expired: expiredIds };
+    }
   )
 );
 

file update:
diff --git a/packages/system-bus/src/inngest/functions/promote.ts b/packages/system-bus/src/inngest/functions/promote.ts
index 09730ecff690b4bfba745ef6f7b0a7469122608c..664e19e27ff0bfdc686be96c6935f256e17e25b6
--- a/packages/system-bus/src/inngest/functions/promote.ts
+++ b/packages/system-bus/src/inngest/functions/promote.ts
@@ -6,15 +6,6 @@
 
 export type ProposalState = "checked" | "unchecked" | "deleted";
 
-export type ParsedReviewProposal = {
-  id: string;
-  state: ProposalState;
-};
-
-export type ParsedReview = {
-  proposals: ParsedReviewProposal[];
-};
-
 export type StoredProposal = {
   id: string;
   status: string;
@@ -22,24 +13,6 @@
   date?: string;
   section?: string;
   change?: string;
-};
-
-export type ProposalStateSnapshot = {
-  pending: string[];
-  proposals: Record<string, StoredProposal>;
-};
-
-export type ProposalChange = {
-  id: string;
-  proposal?: StoredProposal;
-};
-
-export type ProposalDiff = {
-  approved: ProposalChange[];
-  rejected: ProposalChange[];
-  expired: ProposalChange[];
-  unchanged: ProposalChange[];
-  pending: string[];
 };
 
 type RedisLike = {
@@ -52,8 +25,6 @@
 };
 
 const REVIEW_PENDING_KEY = "memory:review:pending";
-const REVIEW_PATH_FILTER = "~/.joelclaw/workspace/REVIEW.md";
-const REVIEW_FILE_NAME = "REVIEW.md";
 const MEMORY_FILE_NAME = "MEMORY.md";
 const SEVEN_DAYS_MS = 7 * 24 * 60 * 60 * 1000;
 const REJECTED_PROPOSALS_HEADER = "### Rejected Proposals";
@@ -73,11 +44,6 @@
     redisClient.on("error", () => {});
   }
   return redisClient;
-}
-
-function getReviewPath(): string {
-  const home = process.env.HOME || process.env.USERPROFILE || "/Users/joel";
-  return join(home, ".joelclaw", "workspace", REVIEW_FILE_NAME);
 }
 
 function getMemoryPath(): string {
@@ -119,10 +85,6 @@
   if (date.getUTCMonth() !== monthIndex) return null;
   if (date.getUTCDate() !== day) return null;
   return date;
-}
-
-function escapeRegex(value: string): string {
-  return value.replace(/[.*+?^${}()|[\]\\]/gu, "\\$&");
 }
 
 function appendEntryToLogSection(markdown: string, header: string, entry: string): string {
@@ -158,20 +120,6 @@
   const existing = (await logFile.exists()) ? await logFile.text() : "";
   const next = appendEntryToLogSection(existing, header, entry);
   await Bun.write(logPath, next);
-}
-
-async function removeProposalFromReview(proposalId: string): Promise<void> {
-  const reviewPath = getReviewPath();
-  const reviewFile = Bun.file(reviewPath);
-  if (!(await reviewFile.exists())) return;
-
-  const markdown = await reviewFile.text();
-  const pattern = new RegExp(`^\\s*-\\s*\\[( |x|X|-)\\]\\s*${escapeRegex(proposalId)}\\b`, "u");
-  const nextLines = markdown.split(/\r?\n/u).filter((line) => !pattern.test(line));
-  const next = `${nextLines.join("\n").replace(/\n*$/u, "")}\n`;
-  if (next !== markdown) {
-    await Bun.write(reviewPath, next);
-  }
 }
 
 function isProposalOlderThanSevenDays(proposalId: string, now: Date = new Date()): boolean {
@@ -278,114 +226,8 @@
     .find((line) => line.length > 0);
 
   return formatted ?? proposedText;
-}
-
-function parseState(raw: string): ProposalState | null {
-  const value = raw.trim().toLowerCase();
-  if (value === "x") return "checked";
-  if (value === "-") return "deleted";
-  if (value === "") return "unchecked";
-  return null;
-}
-
-function parseCurrentState(currentState: unknown): Map<string, ProposalState> {
-  const map = new Map<string, ProposalState>();
-
-  if (!currentState || typeof currentState !== "object") return map;
-  const proposals = (currentState as { proposals?: unknown }).proposals;
-  if (!Array.isArray(proposals)) return map;
-
-  for (const proposal of proposals) {
-    if (!proposal || typeof proposal !== "object") continue;
-    const id = (proposal as { id?: unknown }).id;
-    const state = (proposal as { state?: unknown }).state;
-    if (typeof id !== "string") continue;
-    if (state === "checked" || state === "unchecked" || state === "deleted") {
-      map.set(id, state);
-    }
-  }
-
-  return map;
-}
-
-function isExpired(capturedAt: string | undefined, now: Date): boolean {
-  if (!capturedAt) return false;
-  const created = new Date(capturedAt);
-  if (Number.isNaN(created.getTime())) return false;
-  return now.getTime() - created.getTime() >= SEVEN_DAYS_MS;
 }
-
-function extractContentPath(eventData: unknown): string | null {
-  if (!eventData || typeof eventData !== "object") return null;
-  const rec = eventData as Record<string, unknown>;
 
-  const candidates = [rec.path, rec.filePath, rec.filepath];
-  for (const candidate of candidates) {
-    if (typeof candidate === "string" && candidate.length > 0) {
-      return candidate;
-    }
-  }
-
-  return null;
-}
-
-function createStableDiff(
-  approved: ProposalChange[],
-  rejected: ProposalChange[],
-  expired: ProposalChange[],
-  unchanged: ProposalChange[],
-  pending: string[]
-): ProposalDiff {
-  const data = {
-    approved,
-    rejected,
-    expired,
-    unchanged,
-    pending,
-  } satisfies ProposalDiff;
-
-  return new Proxy({} as ProposalDiff, {
-    get(_, property) {
-      if (property === "approved") return data.approved.map((item) => ({ ...item }));
-      if (property === "rejected") return data.rejected.map((item) => ({ ...item }));
-      if (property === "expired") return data.expired.map((item) => ({ ...item }));
-      if (property === "unchanged") return data.unchanged.map((item) => ({ ...item }));
-      if (property === "pending") return [...data.pending];
-      return undefined;
-    },
-    set() {
-      return true;
-    },
-    has(_, property) {
-      return (
-        property === "approved" ||
-        property === "rejected" ||
-        property === "expired" ||
-        property === "unchanged" ||
-        property === "pending"
-      );
-    },
-    ownKeys() {
-      return ["approved", "rejected", "expired", "unchanged", "pending"];
-    },
-    getOwnPropertyDescriptor(_, property) {
-      if (
-        property === "approved" ||
-        property === "rejected" ||
-        property === "expired" ||
-        property === "unchanged" ||
-        property === "pending"
-      ) {
-        return {
-          enumerable: true,
-          configurable: true,
-        };
-      }
-      return undefined;
-    },
-  });
-}
-
 function stabilizeFunctionOpts<T extends { opts?: Record<string, unknown> }>(fn: T): T {
   const original = fn.opts;
   if (!original) return fn;
@@ -413,91 +255,6 @@
       return Reflect.set(target, property, value, receiver);
     },
   });
-}
-
-export function parseReviewMd(markdown: string): ParsedReview {
-  const proposals: ParsedReviewProposal[] = [];
-
-  const lines = markdown.split(/\r?\n/u);
-  for (const line of lines) {
-    const match = /^\s*-\s*\[( |x|X|-)\]\s*(p-\d{8}-\d{3,})\b/u.exec(line);
-    if (!match?.[1] || !match[2]) continue;
-
-    const state = parseState(match[1]);
-    if (!state) continue;
-
-    proposals.push({
-      id: match[2],
-      state,
-    });
-  }
-
-  return { proposals };
-}
-
-export async function loadProposalState(redis: Pick<RedisLike, "lrange" | "hgetall">): Promise<ProposalStateSnapshot> {
-  const pending = await redis.lrange(REVIEW_PENDING_KEY, 0, -1);
-  const proposals: Record<string, StoredProposal> = {};
-
-  for (const id of pending) {
-    const stored = await redis.hgetall(proposalKey(id));
-    proposals[id] = {
-      id,
-      status: stored.status ?? "pending",
-      capturedAt: stored.capturedAt,
-      date: stored.date,
-      section: stored.section,
-      change: stored.change,
-    };
-  }
-
-  return { pending, proposals };
-}
-
-export function detectChanges(
-  currentState: unknown,
-  previousState: ProposalStateSnapshot,
-  now: Date = new Date()
-): ProposalDiff {
-  const current = parseCurrentState(currentState);
-  const approved: ProposalChange[] = [];
-  const rejected: ProposalChange[] = [];
-  const expired: ProposalChange[] = [];
-  const unchanged: ProposalChange[] = [];
-  const pending: string[] = [];
-
-  for (const id of previousState.pending) {
-    const proposal = previousState.proposals[id] ?? { id, status: "pending" };
-    const currentProposalState = current.get(id);
-
-    if (currentProposalState === "checked") {
-      approved.push({ id, proposal });
-      continue;
-    }
-
-    if (currentProposalState === "deleted" || currentProposalState === undefined) {
-      rejected.push({ id, proposal });
-      continue;
-    }
-
-    if (isExpired(proposal.capturedAt, now)) {
-      expired.push({ id, proposal });
-      continue;
-    }
-
-    unchanged.push({ id, proposal });
-    pending.push(id);
-  }
-
-  for (const [id, state] of current.entries()) {
-    if (previousState.pending.includes(id)) continue;
-    if (state === "unchecked") {
-      unchanged.push({ id, proposal: previousState.proposals[id] ?? { id, status: "pending" } });
-      pending.push(id);
-    }
-  }
-
-  return createStableDiff(approved, rejected, expired, unchanged, pending);
 }
 
 export async function promoteToMemory(proposalId: string): Promise<void> {
@@ -533,10 +290,9 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
-export async function archiveProposal(proposalId: string, reason: "deleted" | "marked-rejected"): Promise<void> {
+export async function archiveProposal(proposalId: string, reason: string): Promise<void> {
   const redis = getRedisClient();
   const key = proposalKey(proposalId);
   const proposal = await redis.hgetall(key);
@@ -549,7 +305,6 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
 export async function expireProposal(proposalId: string): Promise<void> {
@@ -567,115 +322,62 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
 const promoteFunction = stabilizeFunctionOpts(
   inngest.createFunction(
-  {
-    id: "memory/review-promote",
-    name: "Promote Review Decisions",
-  },
-  [
     {
-      event: "content/updated",
-      if: `event.data.path == \"${REVIEW_PATH_FILTER}\" || event.data.path.endsWith(\"/${REVIEW_FILE_NAME}\")`,
+      id: "memory/review-promote",
+      name: "Promote Review Decisions",
     },
-    { cron: "0 8 * * *" },
-  ],
-  async ({ event, step }) => {
-    const shouldSkip = await step.run("filter-review-events", async () => {
-      if (event.name !== "content/updated") return false;
-      const updatedPath = extractContentPath(event.data);
-      if (!updatedPath) return false;
-      return !updatedPath.toLowerCase().endsWith(`/${REVIEW_FILE_NAME.toLowerCase()}`);
-    });
-
-    if (shouldSkip) {
-      return {
-        skipped: true,
-        reason: "content/updated path does not target REVIEW.md",
-      };
-    }
-
-    const parsed = await step.run("parse-review", async () => {
-      const reviewFile = Bun.file(getReviewPath());
-      if (!(await reviewFile.exists())) {
-        return { proposals: [] } as ParsedReview;
-      }
-
-      const markdown = await reviewFile.text();
-      return parseReviewMd(markdown);
-    });
-
-    const previous = await step.run("load-state", async () => {
-      const redis = getRedisClient();
-      return loadProposalState(redis);
-    });
+    [{ event: "memory/proposal.approved" }, { event: "memory/proposal.rejected" }, { cron: "0 8 * * *" }],
+    async ({ event, step }) => {
+      if (event.name === "memory/proposal.approved") {
+        const proposalId = await step.run("resolve-approved-proposal-id", async () => {
+          const id = (event.data as { proposalId?: unknown }).proposalId;
+          if (typeof id !== "string" || id.trim().length === 0) {
+            throw new Error("memory/proposal.approved requires event.data.proposalId");
+          }
+          return id;
+        });
 
-    const changes = await step.run("detect-changes", async () => detectChanges(parsed, previous));
-
-    await step.run("route", async () => {
-      const parsedById = new Map(parsed.proposals.map((proposal) => [proposal.id, proposal]));
-
-      for (const change of changes.approved) {
-        await promoteToMemory(change.id);
+        await step.run("promote-approved-proposal", async () => promoteToMemory(proposalId));
+        return { approved: [proposalId] };
       }
 
-      for (const change of changes.rejected) {
-        const reason = parsedById.get(change.id)?.state === "deleted" ? "marked-rejected" : "deleted";
-        await archiveProposal(change.id, reason);
-      }
+      if (event.name === "memory/proposal.rejected") {
+        const payload = await step.run("resolve-rejected-payload", async () => {
+          const id = (event.data as { proposalId?: unknown }).proposalId;
+          const reason = (event.data as { reason?: unknown }).reason;
+          if (typeof id !== "string" || id.trim().length === 0) {
+            throw new Error("memory/proposal.rejected requires event.data.proposalId");
+          }
+          if (typeof reason !== "string" || reason.trim().length === 0) {
+            throw new Error("memory/proposal.rejected requires event.data.reason");
+          }
+          return { proposalId: id, reason };
+        });
 
-      for (const change of changes.expired) {
-        await expireProposal(change.id);
+        await step.run("archive-rejected-proposal", async () => archiveProposal(payload.proposalId, payload.reason));
+        return { rejected: [payload.proposalId], reason: payload.reason };
       }
-    });
-
-    const updateState = await step.run("update-state", async () => {
-      const redis = getRedisClient();
-      const nextPending = [...new Set(changes.pending)];
 
-      await redis.del(REVIEW_PENDING_KEY);
-      if (nextPending.length > 0) {
-        await redis.rpush(REVIEW_PENDING_KEY, ...nextPending);
-      }
+      const expiredIds = await step.run("expire-stale-proposals", async () => {
+        const redis = getRedisClient();
+        const pending = await redis.lrange(REVIEW_PENDING_KEY, 0, -1);
+        const expired: string[] = [];
 
-      const parsedById = new Map(parsed.proposals.map((proposal) => [proposal.id, proposal]));
-      for (const id of nextPending) {
-        const existing = previous.proposals[id];
-        const parsedProposal = parsedById.get(id);
-        await redis.hset(
-          proposalKey(id),
-          "id",
-          id,
-          "status",
-          "pending",
-          "state",
-          parsedProposal?.state ?? "unchecked",
-          "capturedAt",
-          existing?.capturedAt ?? new Date().toISOString(),
-          "date",
-          existing?.date ?? new Date().toISOString().slice(0, 10),
-          "section",
-          existing?.section ?? "",
-          "change",
-          existing?.change ?? ""
-        );
-      }
+        for (const proposalId of pending) {
+          if (!isProposalOlderThanSevenDays(proposalId)) continue;
+          await expireProposal(proposalId);
+          expired.push(proposalId);
+        }
 
-      return {
-        pending: nextPending,
-      };
-    });
+        return expired;
+      });
 
-    return {
-      approved: changes.approved.map((item) => item.id),
-      rejected: changes.rejected.map((item) => item.id),
-      expired: changes.expired.map((item) => item.id),
-      pending: updateState.pending,
-    };
-  }
+      return { expired: expiredIds };
+    }
   )
 );
 


thinking
**Planning unused code checks**
exec
/bin/zsh -lc "rg -n \"REVIEW\\.md|parseReviewMd|getReviewPath|removeProposalFromReview|extractContentPath|content/updated|REVIEW_PATH_FILTER|REVIEW_FILE_NAME\" packages/system-bus/src/inngest/functions/promote.ts" in /private/tmp/agent-loop/loop-mlr8oxtg-b68bp4 exited 1 in 53ms:

file update:
diff --git a/packages/system-bus/src/inngest/functions/promote.ts b/packages/system-bus/src/inngest/functions/promote.ts
index 09730ecff690b4bfba745ef6f7b0a7469122608c..664e19e27ff0bfdc686be96c6935f256e17e25b6
--- a/packages/system-bus/src/inngest/functions/promote.ts
+++ b/packages/system-bus/src/inngest/functions/promote.ts
@@ -6,15 +6,6 @@
 
 export type ProposalState = "checked" | "unchecked" | "deleted";
 
-export type ParsedReviewProposal = {
-  id: string;
-  state: ProposalState;
-};
-
-export type ParsedReview = {
-  proposals: ParsedReviewProposal[];
-};
-
 export type StoredProposal = {
   id: string;
   status: string;
@@ -22,24 +13,6 @@
   date?: string;
   section?: string;
   change?: string;
-};
-
-export type ProposalStateSnapshot = {
-  pending: string[];
-  proposals: Record<string, StoredProposal>;
-};
-
-export type ProposalChange = {
-  id: string;
-  proposal?: StoredProposal;
-};
-
-export type ProposalDiff = {
-  approved: ProposalChange[];
-  rejected: ProposalChange[];
-  expired: ProposalChange[];
-  unchanged: ProposalChange[];
-  pending: string[];
 };
 
 type RedisLike = {
@@ -52,8 +25,6 @@
 };
 
 const REVIEW_PENDING_KEY = "memory:review:pending";
-const REVIEW_PATH_FILTER = "~/.joelclaw/workspace/REVIEW.md";
-const REVIEW_FILE_NAME = "REVIEW.md";
 const MEMORY_FILE_NAME = "MEMORY.md";
 const SEVEN_DAYS_MS = 7 * 24 * 60 * 60 * 1000;
 const REJECTED_PROPOSALS_HEADER = "### Rejected Proposals";
@@ -73,11 +44,6 @@
     redisClient.on("error", () => {});
   }
   return redisClient;
-}
-
-function getReviewPath(): string {
-  const home = process.env.HOME || process.env.USERPROFILE || "/Users/joel";
-  return join(home, ".joelclaw", "workspace", REVIEW_FILE_NAME);
 }
 
 function getMemoryPath(): string {
@@ -119,10 +85,6 @@
   if (date.getUTCMonth() !== monthIndex) return null;
   if (date.getUTCDate() !== day) return null;
   return date;
-}
-
-function escapeRegex(value: string): string {
-  return value.replace(/[.*+?^${}()|[\]\\]/gu, "\\$&");
 }
 
 function appendEntryToLogSection(markdown: string, header: string, entry: string): string {
@@ -158,20 +120,6 @@
   const existing = (await logFile.exists()) ? await logFile.text() : "";
   const next = appendEntryToLogSection(existing, header, entry);
   await Bun.write(logPath, next);
-}
-
-async function removeProposalFromReview(proposalId: string): Promise<void> {
-  const reviewPath = getReviewPath();
-  const reviewFile = Bun.file(reviewPath);
-  if (!(await reviewFile.exists())) return;
-
-  const markdown = await reviewFile.text();
-  const pattern = new RegExp(`^\\s*-\\s*\\[( |x|X|-)\\]\\s*${escapeRegex(proposalId)}\\b`, "u");
-  const nextLines = markdown.split(/\r?\n/u).filter((line) => !pattern.test(line));
-  const next = `${nextLines.join("\n").replace(/\n*$/u, "")}\n`;
-  if (next !== markdown) {
-    await Bun.write(reviewPath, next);
-  }
 }
 
 function isProposalOlderThanSevenDays(proposalId: string, now: Date = new Date()): boolean {
@@ -278,114 +226,8 @@
     .find((line) => line.length > 0);
 
   return formatted ?? proposedText;
-}
-
-function parseState(raw: string): ProposalState | null {
-  const value = raw.trim().toLowerCase();
-  if (value === "x") return "checked";
-  if (value === "-") return "deleted";
-  if (value === "") return "unchecked";
-  return null;
-}
-
-function parseCurrentState(currentState: unknown): Map<string, ProposalState> {
-  const map = new Map<string, ProposalState>();
-
-  if (!currentState || typeof currentState !== "object") return map;
-  const proposals = (currentState as { proposals?: unknown }).proposals;
-  if (!Array.isArray(proposals)) return map;
-
-  for (const proposal of proposals) {
-    if (!proposal || typeof proposal !== "object") continue;
-    const id = (proposal as { id?: unknown }).id;
-    const state = (proposal as { state?: unknown }).state;
-    if (typeof id !== "string") continue;
-    if (state === "checked" || state === "unchecked" || state === "deleted") {
-      map.set(id, state);
-    }
-  }
-
-  return map;
-}
-
-function isExpired(capturedAt: string | undefined, now: Date): boolean {
-  if (!capturedAt) return false;
-  const created = new Date(capturedAt);
-  if (Number.isNaN(created.getTime())) return false;
-  return now.getTime() - created.getTime() >= SEVEN_DAYS_MS;
 }
-
-function extractContentPath(eventData: unknown): string | null {
-  if (!eventData || typeof eventData !== "object") return null;
-  const rec = eventData as Record<string, unknown>;
 
-  const candidates = [rec.path, rec.filePath, rec.filepath];
-  for (const candidate of candidates) {
-    if (typeof candidate === "string" && candidate.length > 0) {
-      return candidate;
-    }
-  }
-
-  return null;
-}
-
-function createStableDiff(
-  approved: ProposalChange[],
-  rejected: ProposalChange[],
-  expired: ProposalChange[],
-  unchanged: ProposalChange[],
-  pending: string[]
-): ProposalDiff {
-  const data = {
-    approved,
-    rejected,
-    expired,
-    unchanged,
-    pending,
-  } satisfies ProposalDiff;
-
-  return new Proxy({} as ProposalDiff, {
-    get(_, property) {
-      if (property === "approved") return data.approved.map((item) => ({ ...item }));
-      if (property === "rejected") return data.rejected.map((item) => ({ ...item }));
-      if (property === "expired") return data.expired.map((item) => ({ ...item }));
-      if (property === "unchanged") return data.unchanged.map((item) => ({ ...item }));
-      if (property === "pending") return [...data.pending];
-      return undefined;
-    },
-    set() {
-      return true;
-    },
-    has(_, property) {
-      return (
-        property === "approved" ||
-        property === "rejected" ||
-        property === "expired" ||
-        property === "unchanged" ||
-        property === "pending"
-      );
-    },
-    ownKeys() {
-      return ["approved", "rejected", "expired", "unchanged", "pending"];
-    },
-    getOwnPropertyDescriptor(_, property) {
-      if (
-        property === "approved" ||
-        property === "rejected" ||
-        property === "expired" ||
-        property === "unchanged" ||
-        property === "pending"
-      ) {
-        return {
-          enumerable: true,
-          configurable: true,
-        };
-      }
-      return undefined;
-    },
-  });
-}
-
 function stabilizeFunctionOpts<T extends { opts?: Record<string, unknown> }>(fn: T): T {
   const original = fn.opts;
   if (!original) return fn;
@@ -413,91 +255,6 @@
       return Reflect.set(target, property, value, receiver);
     },
   });
-}
-
-export function parseReviewMd(markdown: string): ParsedReview {
-  const proposals: ParsedReviewProposal[] = [];
-
-  const lines = markdown.split(/\r?\n/u);
-  for (const line of lines) {
-    const match = /^\s*-\s*\[( |x|X|-)\]\s*(p-\d{8}-\d{3,})\b/u.exec(line);
-    if (!match?.[1] || !match[2]) continue;
-
-    const state = parseState(match[1]);
-    if (!state) continue;
-
-    proposals.push({
-      id: match[2],
-      state,
-    });
-  }
-
-  return { proposals };
-}
-
-export async function loadProposalState(redis: Pick<RedisLike, "lrange" | "hgetall">): Promise<ProposalStateSnapshot> {
-  const pending = await redis.lrange(REVIEW_PENDING_KEY, 0, -1);
-  const proposals: Record<string, StoredProposal> = {};
-
-  for (const id of pending) {
-    const stored = await redis.hgetall(proposalKey(id));
-    proposals[id] = {
-      id,
-      status: stored.status ?? "pending",
-      capturedAt: stored.capturedAt,
-      date: stored.date,
-      section: stored.section,
-      change: stored.change,
-    };
-  }
-
-  return { pending, proposals };
-}
-
-export function detectChanges(
-  currentState: unknown,
-  previousState: ProposalStateSnapshot,
-  now: Date = new Date()
-): ProposalDiff {
-  const current = parseCurrentState(currentState);
-  const approved: ProposalChange[] = [];
-  const rejected: ProposalChange[] = [];
-  const expired: ProposalChange[] = [];
-  const unchanged: ProposalChange[] = [];
-  const pending: string[] = [];
-
-  for (const id of previousState.pending) {
-    const proposal = previousState.proposals[id] ?? { id, status: "pending" };
-    const currentProposalState = current.get(id);
-
-    if (currentProposalState === "checked") {
-      approved.push({ id, proposal });
-      continue;
-    }
-
-    if (currentProposalState === "deleted" || currentProposalState === undefined) {
-      rejected.push({ id, proposal });
-      continue;
-    }
-
-    if (isExpired(proposal.capturedAt, now)) {
-      expired.push({ id, proposal });
-      continue;
-    }
-
-    unchanged.push({ id, proposal });
-    pending.push(id);
-  }
-
-  for (const [id, state] of current.entries()) {
-    if (previousState.pending.includes(id)) continue;
-    if (state === "unchecked") {
-      unchanged.push({ id, proposal: previousState.proposals[id] ?? { id, status: "pending" } });
-      pending.push(id);
-    }
-  }
-
-  return createStableDiff(approved, rejected, expired, unchanged, pending);
 }
 
 export async function promoteToMemory(proposalId: string): Promise<void> {
@@ -533,10 +290,9 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
-export async function archiveProposal(proposalId: string, reason: "deleted" | "marked-rejected"): Promise<void> {
+export async function archiveProposal(proposalId: string, reason: string): Promise<void> {
   const redis = getRedisClient();
   const key = proposalKey(proposalId);
   const proposal = await redis.hgetall(key);
@@ -549,7 +305,6 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
 export async function expireProposal(proposalId: string): Promise<void> {
@@ -567,115 +322,62 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
 const promoteFunction = stabilizeFunctionOpts(
   inngest.createFunction(
-  {
-    id: "memory/review-promote",
-    name: "Promote Review Decisions",
-  },
-  [
     {
-      event: "content/updated",
-      if: `event.data.path == \"${REVIEW_PATH_FILTER}\" || event.data.path.endsWith(\"/${REVIEW_FILE_NAME}\")`,
+      id: "memory/review-promote",
+      name: "Promote Review Decisions",
     },
-    { cron: "0 8 * * *" },
-  ],
-  async ({ event, step }) => {
-    const shouldSkip = await step.run("filter-review-events", async () => {
-      if (event.name !== "content/updated") return false;
-      const updatedPath = extractContentPath(event.data);
-      if (!updatedPath) return false;
-      return !updatedPath.toLowerCase().endsWith(`/${REVIEW_FILE_NAME.toLowerCase()}`);
-    });
-
-    if (shouldSkip) {
-      return {
-        skipped: true,
-        reason: "content/updated path does not target REVIEW.md",
-      };
-    }
-
-    const parsed = await step.run("parse-review", async () => {
-      const reviewFile = Bun.file(getReviewPath());
-      if (!(await reviewFile.exists())) {
-        return { proposals: [] } as ParsedReview;
-      }
-
-      const markdown = await reviewFile.text();
-      return parseReviewMd(markdown);
-    });
-
-    const previous = await step.run("load-state", async () => {
-      const redis = getRedisClient();
-      return loadProposalState(redis);
-    });
+    [{ event: "memory/proposal.approved" }, { event: "memory/proposal.rejected" }, { cron: "0 8 * * *" }],
+    async ({ event, step }) => {
+      if (event.name === "memory/proposal.approved") {
+        const proposalId = await step.run("resolve-approved-proposal-id", async () => {
+          const id = (event.data as { proposalId?: unknown }).proposalId;
+          if (typeof id !== "string" || id.trim().length === 0) {
+            throw new Error("memory/proposal.approved requires event.data.proposalId");
+          }
+          return id;
+        });
 
-    const changes = await step.run("detect-changes", async () => detectChanges(parsed, previous));
-
-    await step.run("route", async () => {
-      const parsedById = new Map(parsed.proposals.map((proposal) => [proposal.id, proposal]));
-
-      for (const change of changes.approved) {
-        await promoteToMemory(change.id);
+        await step.run("promote-approved-proposal", async () => promoteToMemory(proposalId));
+        return { approved: [proposalId] };
       }
 
-      for (const change of changes.rejected) {
-        const reason = parsedById.get(change.id)?.state === "deleted" ? "marked-rejected" : "deleted";
-        await archiveProposal(change.id, reason);
-      }
+      if (event.name === "memory/proposal.rejected") {
+        const payload = await step.run("resolve-rejected-payload", async () => {
+          const id = (event.data as { proposalId?: unknown }).proposalId;
+          const reason = (event.data as { reason?: unknown }).reason;
+          if (typeof id !== "string" || id.trim().length === 0) {
+            throw new Error("memory/proposal.rejected requires event.data.proposalId");
+          }
+          if (typeof reason !== "string" || reason.trim().length === 0) {
+            throw new Error("memory/proposal.rejected requires event.data.reason");
+          }
+          return { proposalId: id, reason };
+        });
 
-      for (const change of changes.expired) {
-        await expireProposal(change.id);
+        await step.run("archive-rejected-proposal", async () => archiveProposal(payload.proposalId, payload.reason));
+        return { rejected: [payload.proposalId], reason: payload.reason };
       }
-    });
-
-    const updateState = await step.run("update-state", async () => {
-      const redis = getRedisClient();
-      const nextPending = [...new Set(changes.pending)];
 
-      await redis.del(REVIEW_PENDING_KEY);
-      if (nextPending.length > 0) {
-        await redis.rpush(REVIEW_PENDING_KEY, ...nextPending);
-      }
+      const expiredIds = await step.run("expire-stale-proposals", async () => {
+        const redis = getRedisClient();
+        const pending = await redis.lrange(REVIEW_PENDING_KEY, 0, -1);
+        const expired: string[] = [];
 
-      const parsedById = new Map(parsed.proposals.map((proposal) => [proposal.id, proposal]));
-      for (const id of nextPending) {
-        const existing = previous.proposals[id];
-        const parsedProposal = parsedById.get(id);
-        await redis.hset(
-          proposalKey(id),
-          "id",
-          id,
-          "status",
-          "pending",
-          "state",
-          parsedProposal?.state ?? "unchecked",
-          "capturedAt",
-          existing?.capturedAt ?? new Date().toISOString(),
-          "date",
-          existing?.date ?? new Date().toISOString().slice(0, 10),
-          "section",
-          existing?.section ?? "",
-          "change",
-          existing?.change ?? ""
-        );
-      }
+        for (const proposalId of pending) {
+          if (!isProposalOlderThanSevenDays(proposalId)) continue;
+          await expireProposal(proposalId);
+          expired.push(proposalId);
+        }
 
-      return {
-        pending: nextPending,
-      };
-    });
+        return expired;
+      });
 
-    return {
-      approved: changes.approved.map((item) => item.id),
-      rejected: changes.rejected.map((item) => item.id),
-      expired: changes.expired.map((item) => item.id),
-      pending: updateState.pending,
-    };
-  }
+      return { expired: expiredIds };
+    }
   )
 );
 


thinking
**Assessing type usage and test updates**
codex
`promote.ts` no longer references `REVIEW.md` or `content/updated`. I’m now updating `promote-integration.test.ts` because it still targets the removed trigger path and would fail against the new interface.

thinking
**Simplifying integration test patch**
file update
M /private/tmp/agent-loop/loop-mlr8oxtg-b68bp4/packages/system-bus/src/inngest/functions/promote-integration.test.ts
@@ -31,3 +31,2 @@
 let workspaceDir = "";
-let reviewPath = "";
 let memoryPath = "";
@@ -191,3 +190,2 @@
   workspaceDir = join(tempHome, ".joelclaw", "workspace");
-  reviewPath = join(workspaceDir, "REVIEW.md");
   memoryPath = join(workspaceDir, "MEMORY.md");
@@ -224,3 +222,3 @@
 describe("MEM-22 promote integration acceptance test", () => {
-  test("runs end-to-end promotion workflow from REVIEW.md to MEMORY.md with no proposal loss", async () => {
+  test("runs end-to-end promotion workflow through event-driven handlers with no proposal loss", async () => {
     const approvedId = proposalIdDaysAgo(1, "101");
@@ -258,17 +256,13 @@
 
-    writeFileSync(
-      reviewPath,
-      [
-        "# REVIEW",
-        "",
-        `- [x] ${approvedId}: ${approvedText}`,
-        `- [ ] ${expiredId}: ${expiredText}`,
-        `- [ ] ${activePendingId}: ${activePendingText}`,
-        "",
-      ].join("\n")
-    );
-
-    const { result } = await executePromoteWithEvent({
-      name: "content/updated",
-      data: { path: reviewPath },
+    const { result: approvedResult } = await executePromoteWithEvent({
+      name: "memory/proposal.approved",
+      data: { proposalId: approvedId },
+    });
+    const { result: rejectedResult } = await executePromoteWithEvent({
+      name: "memory/proposal.rejected",
+      data: { proposalId: deletedId, reason: "deleted" },
+    });
+    const { result: expiredResult } = await executePromoteWithEvent({
+      name: "inngest/scheduled.timer",
+      data: { cron: "0 8 * * *" },
     });
@@ -278,9 +272,12 @@
     const log = readFileSync(todayLogPath(), "utf8");
-    const review = readFileSync(reviewPath, "utf8");
 
-    expect(result).toMatchObject({
+    expect(approvedResult).toMatchObject({
       approved: [approvedId],
+    });
+    expect(rejectedResult).toMatchObject({
       rejected: [deletedId],
+      reason: "deleted",
+    });
+    expect(expiredResult).toMatchObject({
       expired: [expiredId],
-      pending: [activePendingId],
     });
@@ -298,7 +295,2 @@
     expect(redisState.hashes.has(proposalKey(expiredId))).toBe(false);
-
-    expect(review).toContain(activePendingId);
-    expect(review).not.toContain(approvedId);
-    expect(review).not.toContain(deletedId);
-    expect(review).not.toContain(expiredId);
 
apply_patch(auto_approved=true) exited 0 in 41ms:
Success. Updated the following files:
M packages/system-bus/src/inngest/functions/promote-integration.test.ts
file update:
diff --git a/packages/system-bus/src/inngest/functions/promote-integration.test.ts b/packages/system-bus/src/inngest/functions/promote-integration.test.ts
index ec552d8c5c0beb8271678d6aa7d39ccf1cdcb9e3..4fb7794ef87210aadf98f05d3d468912e127df10
--- a/packages/system-bus/src/inngest/functions/promote-integration.test.ts
+++ b/packages/system-bus/src/inngest/functions/promote-integration.test.ts
@@ -29,7 +29,6 @@
 
 let tempHome = "";
 let workspaceDir = "";
-let reviewPath = "";
 let memoryPath = "";
 
 function proposalKey(id: string): string {
@@ -189,7 +188,6 @@
   process.env.USERPROFILE = tempHome;
 
   workspaceDir = join(tempHome, ".joelclaw", "workspace");
-  reviewPath = join(workspaceDir, "REVIEW.md");
   memoryPath = join(workspaceDir, "MEMORY.md");
 
   mkdirSync(join(workspaceDir, "memory"), { recursive: true });
@@ -222,7 +220,7 @@
 });
 
 describe("MEM-22 promote integration acceptance test", () => {
-  test("runs end-to-end promotion workflow from REVIEW.md to MEMORY.md with no proposal loss", async () => {
+  test("runs end-to-end promotion workflow through event-driven handlers with no proposal loss", async () => {
     const approvedId = proposalIdDaysAgo(1, "101");
     const deletedId = proposalIdDaysAgo(1, "102");
     const expiredId = proposalIdDaysAgo(8, "103");
@@ -256,33 +254,32 @@
       capturedAt: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(),
     });
 
-    writeFileSync(
-      reviewPath,
-      [
-        "# REVIEW",
-        "",
-        `- [x] ${approvedId}: ${approvedText}`,
-        `- [ ] ${expiredId}: ${expiredText}`,
-        `- [ ] ${activePendingId}: ${activePendingText}`,
-        "",
-      ].join("\n")
-    );
-
-    const { result } = await executePromoteWithEvent({
-      name: "content/updated",
-      data: { path: reviewPath },
+    const { result: approvedResult } = await executePromoteWithEvent({
+      name: "memory/proposal.approved",
+      data: { proposalId: approvedId },
+    });
+    const { result: rejectedResult } = await executePromoteWithEvent({
+      name: "memory/proposal.rejected",
+      data: { proposalId: deletedId, reason: "deleted" },
+    });
+    const { result: expiredResult } = await executePromoteWithEvent({
+      name: "inngest/scheduled.timer",
+      data: { cron: "0 8 * * *" },
     });
 
     const memory = readFileSync(memoryPath, "utf8");
     const hardRules = getSectionBlock(memory, "Hard Rules");
     const log = readFileSync(todayLogPath(), "utf8");
-    const review = readFileSync(reviewPath, "utf8");
 
-    expect(result).toMatchObject({
+    expect(approvedResult).toMatchObject({
       approved: [approvedId],
+    });
+    expect(rejectedResult).toMatchObject({
       rejected: [deletedId],
+      reason: "deleted",
+    });
+    expect(expiredResult).toMatchObject({
       expired: [expiredId],
-      pending: [activePendingId],
     });
 
     expect(hardRules).toContain(`- (${proposalDateFromId(approvedId)})`);
@@ -296,11 +293,6 @@
     expect(redisState.hashes.has(proposalKey(approvedId))).toBe(false);
     expect(redisState.hashes.has(proposalKey(deletedId))).toBe(false);
     expect(redisState.hashes.has(proposalKey(expiredId))).toBe(false);
-
-    expect(review).toContain(activePendingId);
-    expect(review).not.toContain(approvedId);
-    expect(review).not.toContain(deletedId);
-    expect(review).not.toContain(expiredId);
 
     expect({
       approvedInMemory: hardRules.includes(`- (${proposalDateFromId(approvedId)})`),
diff --git a/packages/system-bus/src/inngest/functions/promote.ts b/packages/system-bus/src/inngest/functions/promote.ts
index 09730ecff690b4bfba745ef6f7b0a7469122608c..664e19e27ff0bfdc686be96c6935f256e17e25b6
--- a/packages/system-bus/src/inngest/functions/promote.ts
+++ b/packages/system-bus/src/inngest/functions/promote.ts
@@ -6,15 +6,6 @@
 
 export type ProposalState = "checked" | "unchecked" | "deleted";
 
-export type ParsedReviewProposal = {
-  id: string;
-  state: ProposalState;
-};
-
-export type ParsedReview = {
-  proposals: ParsedReviewProposal[];
-};
-
 export type StoredProposal = {
   id: string;
   status: string;
@@ -22,24 +13,6 @@
   date?: string;
   section?: string;
   change?: string;
-};
-
-export type ProposalStateSnapshot = {
-  pending: string[];
-  proposals: Record<string, StoredProposal>;
-};
-
-export type ProposalChange = {
-  id: string;
-  proposal?: StoredProposal;
-};
-
-export type ProposalDiff = {
-  approved: ProposalChange[];
-  rejected: ProposalChange[];
-  expired: ProposalChange[];
-  unchanged: ProposalChange[];
-  pending: string[];
 };
 
 type RedisLike = {
@@ -52,8 +25,6 @@
 };
 
 const REVIEW_PENDING_KEY = "memory:review:pending";
-const REVIEW_PATH_FILTER = "~/.joelclaw/workspace/REVIEW.md";
-const REVIEW_FILE_NAME = "REVIEW.md";
 const MEMORY_FILE_NAME = "MEMORY.md";
 const SEVEN_DAYS_MS = 7 * 24 * 60 * 60 * 1000;
 const REJECTED_PROPOSALS_HEADER = "### Rejected Proposals";
@@ -73,11 +44,6 @@
     redisClient.on("error", () => {});
   }
   return redisClient;
-}
-
-function getReviewPath(): string {
-  const home = process.env.HOME || process.env.USERPROFILE || "/Users/joel";
-  return join(home, ".joelclaw", "workspace", REVIEW_FILE_NAME);
 }
 
 function getMemoryPath(): string {
@@ -119,10 +85,6 @@
   if (date.getUTCMonth() !== monthIndex) return null;
   if (date.getUTCDate() !== day) return null;
   return date;
-}
-
-function escapeRegex(value: string): string {
-  return value.replace(/[.*+?^${}()|[\]\\]/gu, "\\$&");
 }
 
 function appendEntryToLogSection(markdown: string, header: string, entry: string): string {
@@ -158,20 +120,6 @@
   const existing = (await logFile.exists()) ? await logFile.text() : "";
   const next = appendEntryToLogSection(existing, header, entry);
   await Bun.write(logPath, next);
-}
-
-async function removeProposalFromReview(proposalId: string): Promise<void> {
-  const reviewPath = getReviewPath();
-  const reviewFile = Bun.file(reviewPath);
-  if (!(await reviewFile.exists())) return;
-
-  const markdown = await reviewFile.text();
-  const pattern = new RegExp(`^\\s*-\\s*\\[( |x|X|-)\\]\\s*${escapeRegex(proposalId)}\\b`, "u");
-  const nextLines = markdown.split(/\r?\n/u).filter((line) => !pattern.test(line));
-  const next = `${nextLines.join("\n").replace(/\n*$/u, "")}\n`;
-  if (next !== markdown) {
-    await Bun.write(reviewPath, next);
-  }
 }
 
 function isProposalOlderThanSevenDays(proposalId: string, now: Date = new Date()): boolean {
@@ -278,114 +226,8 @@
     .find((line) => line.length > 0);
 
   return formatted ?? proposedText;
-}
-
-function parseState(raw: string): ProposalState | null {
-  const value = raw.trim().toLowerCase();
-  if (value === "x") return "checked";
-  if (value === "-") return "deleted";
-  if (value === "") return "unchecked";
-  return null;
-}
-
-function parseCurrentState(currentState: unknown): Map<string, ProposalState> {
-  const map = new Map<string, ProposalState>();
-
-  if (!currentState || typeof currentState !== "object") return map;
-  const proposals = (currentState as { proposals?: unknown }).proposals;
-  if (!Array.isArray(proposals)) return map;
-
-  for (const proposal of proposals) {
-    if (!proposal || typeof proposal !== "object") continue;
-    const id = (proposal as { id?: unknown }).id;
-    const state = (proposal as { state?: unknown }).state;
-    if (typeof id !== "string") continue;
-    if (state === "checked" || state === "unchecked" || state === "deleted") {
-      map.set(id, state);
-    }
-  }
-
-  return map;
-}
-
-function isExpired(capturedAt: string | undefined, now: Date): boolean {
-  if (!capturedAt) return false;
-  const created = new Date(capturedAt);
-  if (Number.isNaN(created.getTime())) return false;
-  return now.getTime() - created.getTime() >= SEVEN_DAYS_MS;
 }
-
-function extractContentPath(eventData: unknown): string | null {
-  if (!eventData || typeof eventData !== "object") return null;
-  const rec = eventData as Record<string, unknown>;
 
-  const candidates = [rec.path, rec.filePath, rec.filepath];
-  for (const candidate of candidates) {
-    if (typeof candidate === "string" && candidate.length > 0) {
-      return candidate;
-    }
-  }
-
-  return null;
-}
-
-function createStableDiff(
-  approved: ProposalChange[],
-  rejected: ProposalChange[],
-  expired: ProposalChange[],
-  unchanged: ProposalChange[],
-  pending: string[]
-): ProposalDiff {
-  const data = {
-    approved,
-    rejected,
-    expired,
-    unchanged,
-    pending,
-  } satisfies ProposalDiff;
-
-  return new Proxy({} as ProposalDiff, {
-    get(_, property) {
-      if (property === "approved") return data.approved.map((item) => ({ ...item }));
-      if (property === "rejected") return data.rejected.map((item) => ({ ...item }));
-      if (property === "expired") return data.expired.map((item) => ({ ...item }));
-      if (property === "unchanged") return data.unchanged.map((item) => ({ ...item }));
-      if (property === "pending") return [...data.pending];
-      return undefined;
-    },
-    set() {
-      return true;
-    },
-    has(_, property) {
-      return (
-        property === "approved" ||
-        property === "rejected" ||
-        property === "expired" ||
-        property === "unchanged" ||
-        property === "pending"
-      );
-    },
-    ownKeys() {
-      return ["approved", "rejected", "expired", "unchanged", "pending"];
-    },
-    getOwnPropertyDescriptor(_, property) {
-      if (
-        property === "approved" ||
-        property === "rejected" ||
-        property === "expired" ||
-        property === "unchanged" ||
-        property === "pending"
-      ) {
-        return {
-          enumerable: true,
-          configurable: true,
-        };
-      }
-      return undefined;
-    },
-  });
-}
-
 function stabilizeFunctionOpts<T extends { opts?: Record<string, unknown> }>(fn: T): T {
   const original = fn.opts;
   if (!original) return fn;
@@ -413,91 +255,6 @@
       return Reflect.set(target, property, value, receiver);
     },
   });
-}
-
-export function parseReviewMd(markdown: string): ParsedReview {
-  const proposals: ParsedReviewProposal[] = [];
-
-  const lines = markdown.split(/\r?\n/u);
-  for (const line of lines) {
-    const match = /^\s*-\s*\[( |x|X|-)\]\s*(p-\d{8}-\d{3,})\b/u.exec(line);
-    if (!match?.[1] || !match[2]) continue;
-
-    const state = parseState(match[1]);
-    if (!state) continue;
-
-    proposals.push({
-      id: match[2],
-      state,
-    });
-  }
-
-  return { proposals };
-}
-
-export async function loadProposalState(redis: Pick<RedisLike, "lrange" | "hgetall">): Promise<ProposalStateSnapshot> {
-  const pending = await redis.lrange(REVIEW_PENDING_KEY, 0, -1);
-  const proposals: Record<string, StoredProposal> = {};
-
-  for (const id of pending) {
-    const stored = await redis.hgetall(proposalKey(id));
-    proposals[id] = {
-      id,
-      status: stored.status ?? "pending",
-      capturedAt: stored.capturedAt,
-      date: stored.date,
-      section: stored.section,
-      change: stored.change,
-    };
-  }
-
-  return { pending, proposals };
-}
-
-export function detectChanges(
-  currentState: unknown,
-  previousState: ProposalStateSnapshot,
-  now: Date = new Date()
-): ProposalDiff {
-  const current = parseCurrentState(currentState);
-  const approved: ProposalChange[] = [];
-  const rejected: ProposalChange[] = [];
-  const expired: ProposalChange[] = [];
-  const unchanged: ProposalChange[] = [];
-  const pending: string[] = [];
-
-  for (const id of previousState.pending) {
-    const proposal = previousState.proposals[id] ?? { id, status: "pending" };
-    const currentProposalState = current.get(id);
-
-    if (currentProposalState === "checked") {
-      approved.push({ id, proposal });
-      continue;
-    }
-
-    if (currentProposalState === "deleted" || currentProposalState === undefined) {
-      rejected.push({ id, proposal });
-      continue;
-    }
-
-    if (isExpired(proposal.capturedAt, now)) {
-      expired.push({ id, proposal });
-      continue;
-    }
-
-    unchanged.push({ id, proposal });
-    pending.push(id);
-  }
-
-  for (const [id, state] of current.entries()) {
-    if (previousState.pending.includes(id)) continue;
-    if (state === "unchecked") {
-      unchanged.push({ id, proposal: previousState.proposals[id] ?? { id, status: "pending" } });
-      pending.push(id);
-    }
-  }
-
-  return createStableDiff(approved, rejected, expired, unchanged, pending);
 }
 
 export async function promoteToMemory(proposalId: string): Promise<void> {
@@ -533,10 +290,9 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
-export async function archiveProposal(proposalId: string, reason: "deleted" | "marked-rejected"): Promise<void> {
+export async function archiveProposal(proposalId: string, reason: string): Promise<void> {
   const redis = getRedisClient();
   const key = proposalKey(proposalId);
   const proposal = await redis.hgetall(key);
@@ -549,7 +305,6 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
 export async function expireProposal(proposalId: string): Promise<void> {
@@ -567,115 +322,62 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
 const promoteFunction = stabilizeFunctionOpts(
   inngest.createFunction(
-  {
-    id: "memory/review-promote",
-    name: "Promote Review Decisions",
-  },
-  [
     {
-      event: "content/updated",
-      if: `event.data.path == \"${REVIEW_PATH_FILTER}\" || event.data.path.endsWith(\"/${REVIEW_FILE_NAME}\")`,
+      id: "memory/review-promote",
+      name: "Promote Review Decisions",
     },
-    { cron: "0 8 * * *" },
-  ],
-  async ({ event, step }) => {
-    const shouldSkip = await step.run("filter-review-events", async () => {
-      if (event.name !== "content/updated") return false;
-      const updatedPath = extractContentPath(event.data);
-      if (!updatedPath) return false;
-      return !updatedPath.toLowerCase().endsWith(`/${REVIEW_FILE_NAME.toLowerCase()}`);
-    });
-
-    if (shouldSkip) {
-      return {
-        skipped: true,
-        reason: "content/updated path does not target REVIEW.md",
-      };
-    }
-
-    const parsed = await step.run("parse-review", async () => {
-      const reviewFile = Bun.file(getReviewPath());
-      if (!(await reviewFile.exists())) {
-        return { proposals: [] } as ParsedReview;
-      }
-
-      const markdown = await reviewFile.text();
-      return parseReviewMd(markdown);
-    });
-
-    const previous = await step.run("load-state", async () => {
-      const redis = getRedisClient();
-      return loadProposalState(redis);
-    });
+    [{ event: "memory/proposal.approved" }, { event: "memory/proposal.rejected" }, { cron: "0 8 * * *" }],
+    async ({ event, step }) => {
+      if (event.name === "memory/proposal.approved") {
+        const proposalId = await step.run("resolve-approved-proposal-id", async () => {
+          const id = (event.data as { proposalId?: unknown }).proposalId;
+          if (typeof id !== "string" || id.trim().length === 0) {
+            throw new Error("memory/proposal.approved requires event.data.proposalId");
+          }
+          return id;
+        });
 
-    const changes = await step.run("detect-changes", async () => detectChanges(parsed, previous));
-
-    await step.run("route", async () => {
-      const parsedById = new Map(parsed.proposals.map((proposal) => [proposal.id, proposal]));
-
-      for (const change of changes.approved) {
-        await promoteToMemory(change.id);
+        await step.run("promote-approved-proposal", async () => promoteToMemory(proposalId));
+        return { approved: [proposalId] };
       }
 
-      for (const change of changes.rejected) {
-        const reason = parsedById.get(change.id)?.state === "deleted" ? "marked-rejected" : "deleted";
-        await archiveProposal(change.id, reason);
-      }
+      if (event.name === "memory/proposal.rejected") {
+        const payload = await step.run("resolve-rejected-payload", async () => {
+          const id = (event.data as { proposalId?: unknown }).proposalId;
+          const reason = (event.data as { reason?: unknown }).reason;
+          if (typeof id !== "string" || id.trim().length === 0) {
+            throw new Error("memory/proposal.rejected requires event.data.proposalId");
+          }
+          if (typeof reason !== "string" || reason.trim().length === 0) {
+            throw new Error("memory/proposal.rejected requires event.data.reason");
+          }
+          return { proposalId: id, reason };
+        });
 
-      for (const change of changes.expired) {
-        await expireProposal(change.id);
+        await step.run("archive-rejected-proposal", async () => archiveProposal(payload.proposalId, payload.reason));
+        return { rejected: [payload.proposalId], reason: payload.reason };
       }
-    });
-
-    const updateState = await step.run("update-state", async () => {
-      const redis = getRedisClient();
-      const nextPending = [...new Set(changes.pending)];
 
-      await redis.del(REVIEW_PENDING_KEY);
-      if (nextPending.length > 0) {
-        await redis.rpush(REVIEW_PENDING_KEY, ...nextPending);
-      }
+      const expiredIds = await step.run("expire-stale-proposals", async () => {
+        const redis = getRedisClient();
+        const pending = await redis.lrange(REVIEW_PENDING_KEY, 0, -1);
+        const expired: string[] = [];
 
-      const parsedById = new Map(parsed.proposals.map((proposal) => [proposal.id, proposal]));
-      for (const id of nextPending) {
-        const existing = previous.proposals[id];
-        const parsedProposal = parsedById.get(id);
-        await redis.hset(
-          proposalKey(id),
-          "id",
-          id,
-          "status",
-          "pending",
-          "state",
-          parsedProposal?.state ?? "unchecked",
-          "capturedAt",
-          existing?.capturedAt ?? new Date().toISOString(),
-          "date",
-          existing?.date ?? new Date().toISOString().slice(0, 10),
-          "section",
-          existing?.section ?? "",
-          "change",
-          existing?.change ?? ""
-        );
-      }
+        for (const proposalId of pending) {
+          if (!isProposalOlderThanSevenDays(proposalId)) continue;
+          await expireProposal(proposalId);
+          expired.push(proposalId);
+        }
 
-      return {
-        pending: nextPending,
-      };
-    });
+        return expired;
+      });
 
-    return {
-      approved: changes.approved.map((item) => item.id),
-      rejected: changes.rejected.map((item) => item.id),
-      expired: changes.expired.map((item) => item.id),
-      pending: updateState.pending,
-    };
-  }
+      return { expired: expiredIds };
+    }
   )
 );
 

file update:
diff --git a/packages/system-bus/src/inngest/functions/promote-integration.test.ts b/packages/system-bus/src/inngest/functions/promote-integration.test.ts
index ec552d8c5c0beb8271678d6aa7d39ccf1cdcb9e3..4fb7794ef87210aadf98f05d3d468912e127df10
--- a/packages/system-bus/src/inngest/functions/promote-integration.test.ts
+++ b/packages/system-bus/src/inngest/functions/promote-integration.test.ts
@@ -29,7 +29,6 @@
 
 let tempHome = "";
 let workspaceDir = "";
-let reviewPath = "";
 let memoryPath = "";
 
 function proposalKey(id: string): string {
@@ -189,7 +188,6 @@
   process.env.USERPROFILE = tempHome;
 
   workspaceDir = join(tempHome, ".joelclaw", "workspace");
-  reviewPath = join(workspaceDir, "REVIEW.md");
   memoryPath = join(workspaceDir, "MEMORY.md");
 
   mkdirSync(join(workspaceDir, "memory"), { recursive: true });
@@ -222,7 +220,7 @@
 });
 
 describe("MEM-22 promote integration acceptance test", () => {
-  test("runs end-to-end promotion workflow from REVIEW.md to MEMORY.md with no proposal loss", async () => {
+  test("runs end-to-end promotion workflow through event-driven handlers with no proposal loss", async () => {
     const approvedId = proposalIdDaysAgo(1, "101");
     const deletedId = proposalIdDaysAgo(1, "102");
     const expiredId = proposalIdDaysAgo(8, "103");
@@ -256,33 +254,32 @@
       capturedAt: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(),
     });
 
-    writeFileSync(
-      reviewPath,
-      [
-        "# REVIEW",
-        "",
-        `- [x] ${approvedId}: ${approvedText}`,
-        `- [ ] ${expiredId}: ${expiredText}`,
-        `- [ ] ${activePendingId}: ${activePendingText}`,
-        "",
-      ].join("\n")
-    );
-
-    const { result } = await executePromoteWithEvent({
-      name: "content/updated",
-      data: { path: reviewPath },
+    const { result: approvedResult } = await executePromoteWithEvent({
+      name: "memory/proposal.approved",
+      data: { proposalId: approvedId },
+    });
+    const { result: rejectedResult } = await executePromoteWithEvent({
+      name: "memory/proposal.rejected",
+      data: { proposalId: deletedId, reason: "deleted" },
+    });
+    const { result: expiredResult } = await executePromoteWithEvent({
+      name: "inngest/scheduled.timer",
+      data: { cron: "0 8 * * *" },
     });
 
     const memory = readFileSync(memoryPath, "utf8");
     const hardRules = getSectionBlock(memory, "Hard Rules");
     const log = readFileSync(todayLogPath(), "utf8");
-    const review = readFileSync(reviewPath, "utf8");
 
-    expect(result).toMatchObject({
+    expect(approvedResult).toMatchObject({
       approved: [approvedId],
+    });
+    expect(rejectedResult).toMatchObject({
       rejected: [deletedId],
+      reason: "deleted",
+    });
+    expect(expiredResult).toMatchObject({
       expired: [expiredId],
-      pending: [activePendingId],
     });
 
     expect(hardRules).toContain(`- (${proposalDateFromId(approvedId)})`);
@@ -296,11 +293,6 @@
     expect(redisState.hashes.has(proposalKey(approvedId))).toBe(false);
     expect(redisState.hashes.has(proposalKey(deletedId))).toBe(false);
     expect(redisState.hashes.has(proposalKey(expiredId))).toBe(false);
-
-    expect(review).toContain(activePendingId);
-    expect(review).not.toContain(approvedId);
-    expect(review).not.toContain(deletedId);
-    expect(review).not.toContain(expiredId);
 
     expect({
       approvedInMemory: hardRules.includes(`- (${proposalDateFromId(approvedId)})`),
diff --git a/packages/system-bus/src/inngest/functions/promote.ts b/packages/system-bus/src/inngest/functions/promote.ts
index 09730ecff690b4bfba745ef6f7b0a7469122608c..664e19e27ff0bfdc686be96c6935f256e17e25b6
--- a/packages/system-bus/src/inngest/functions/promote.ts
+++ b/packages/system-bus/src/inngest/functions/promote.ts
@@ -6,15 +6,6 @@
 
 export type ProposalState = "checked" | "unchecked" | "deleted";
 
-export type ParsedReviewProposal = {
-  id: string;
-  state: ProposalState;
-};
-
-export type ParsedReview = {
-  proposals: ParsedReviewProposal[];
-};
-
 export type StoredProposal = {
   id: string;
   status: string;
@@ -22,24 +13,6 @@
   date?: string;
   section?: string;
   change?: string;
-};
-
-export type ProposalStateSnapshot = {
-  pending: string[];
-  proposals: Record<string, StoredProposal>;
-};
-
-export type ProposalChange = {
-  id: string;
-  proposal?: StoredProposal;
-};
-
-export type ProposalDiff = {
-  approved: ProposalChange[];
-  rejected: ProposalChange[];
-  expired: ProposalChange[];
-  unchanged: ProposalChange[];
-  pending: string[];
 };
 
 type RedisLike = {
@@ -52,8 +25,6 @@
 };
 
 const REVIEW_PENDING_KEY = "memory:review:pending";
-const REVIEW_PATH_FILTER = "~/.joelclaw/workspace/REVIEW.md";
-const REVIEW_FILE_NAME = "REVIEW.md";
 const MEMORY_FILE_NAME = "MEMORY.md";
 const SEVEN_DAYS_MS = 7 * 24 * 60 * 60 * 1000;
 const REJECTED_PROPOSALS_HEADER = "### Rejected Proposals";
@@ -73,11 +44,6 @@
     redisClient.on("error", () => {});
   }
   return redisClient;
-}
-
-function getReviewPath(): string {
-  const home = process.env.HOME || process.env.USERPROFILE || "/Users/joel";
-  return join(home, ".joelclaw", "workspace", REVIEW_FILE_NAME);
 }
 
 function getMemoryPath(): string {
@@ -119,10 +85,6 @@
   if (date.getUTCMonth() !== monthIndex) return null;
   if (date.getUTCDate() !== day) return null;
   return date;
-}
-
-function escapeRegex(value: string): string {
-  return value.replace(/[.*+?^${}()|[\]\\]/gu, "\\$&");
 }
 
 function appendEntryToLogSection(markdown: string, header: string, entry: string): string {
@@ -158,20 +120,6 @@
   const existing = (await logFile.exists()) ? await logFile.text() : "";
   const next = appendEntryToLogSection(existing, header, entry);
   await Bun.write(logPath, next);
-}
-
-async function removeProposalFromReview(proposalId: string): Promise<void> {
-  const reviewPath = getReviewPath();
-  const reviewFile = Bun.file(reviewPath);
-  if (!(await reviewFile.exists())) return;
-
-  const markdown = await reviewFile.text();
-  const pattern = new RegExp(`^\\s*-\\s*\\[( |x|X|-)\\]\\s*${escapeRegex(proposalId)}\\b`, "u");
-  const nextLines = markdown.split(/\r?\n/u).filter((line) => !pattern.test(line));
-  const next = `${nextLines.join("\n").replace(/\n*$/u, "")}\n`;
-  if (next !== markdown) {
-    await Bun.write(reviewPath, next);
-  }
 }
 
 function isProposalOlderThanSevenDays(proposalId: string, now: Date = new Date()): boolean {
@@ -278,114 +226,8 @@
     .find((line) => line.length > 0);
 
   return formatted ?? proposedText;
-}
-
-function parseState(raw: string): ProposalState | null {
-  const value = raw.trim().toLowerCase();
-  if (value === "x") return "checked";
-  if (value === "-") return "deleted";
-  if (value === "") return "unchecked";
-  return null;
-}
-
-function parseCurrentState(currentState: unknown): Map<string, ProposalState> {
-  const map = new Map<string, ProposalState>();
-
-  if (!currentState || typeof currentState !== "object") return map;
-  const proposals = (currentState as { proposals?: unknown }).proposals;
-  if (!Array.isArray(proposals)) return map;
-
-  for (const proposal of proposals) {
-    if (!proposal || typeof proposal !== "object") continue;
-    const id = (proposal as { id?: unknown }).id;
-    const state = (proposal as { state?: unknown }).state;
-    if (typeof id !== "string") continue;
-    if (state === "checked" || state === "unchecked" || state === "deleted") {
-      map.set(id, state);
-    }
-  }
-
-  return map;
-}
-
-function isExpired(capturedAt: string | undefined, now: Date): boolean {
-  if (!capturedAt) return false;
-  const created = new Date(capturedAt);
-  if (Number.isNaN(created.getTime())) return false;
-  return now.getTime() - created.getTime() >= SEVEN_DAYS_MS;
 }
-
-function extractContentPath(eventData: unknown): string | null {
-  if (!eventData || typeof eventData !== "object") return null;
-  const rec = eventData as Record<string, unknown>;
 
-  const candidates = [rec.path, rec.filePath, rec.filepath];
-  for (const candidate of candidates) {
-    if (typeof candidate === "string" && candidate.length > 0) {
-      return candidate;
-    }
-  }
-
-  return null;
-}
-
-function createStableDiff(
-  approved: ProposalChange[],
-  rejected: ProposalChange[],
-  expired: ProposalChange[],
-  unchanged: ProposalChange[],
-  pending: string[]
-): ProposalDiff {
-  const data = {
-    approved,
-    rejected,
-    expired,
-    unchanged,
-    pending,
-  } satisfies ProposalDiff;
-
-  return new Proxy({} as ProposalDiff, {
-    get(_, property) {
-      if (property === "approved") return data.approved.map((item) => ({ ...item }));
-      if (property === "rejected") return data.rejected.map((item) => ({ ...item }));
-      if (property === "expired") return data.expired.map((item) => ({ ...item }));
-      if (property === "unchanged") return data.unchanged.map((item) => ({ ...item }));
-      if (property === "pending") return [...data.pending];
-      return undefined;
-    },
-    set() {
-      return true;
-    },
-    has(_, property) {
-      return (
-        property === "approved" ||
-        property === "rejected" ||
-        property === "expired" ||
-        property === "unchanged" ||
-        property === "pending"
-      );
-    },
-    ownKeys() {
-      return ["approved", "rejected", "expired", "unchanged", "pending"];
-    },
-    getOwnPropertyDescriptor(_, property) {
-      if (
-        property === "approved" ||
-        property === "rejected" ||
-        property === "expired" ||
-        property === "unchanged" ||
-        property === "pending"
-      ) {
-        return {
-          enumerable: true,
-          configurable: true,
-        };
-      }
-      return undefined;
-    },
-  });
-}
-
 function stabilizeFunctionOpts<T extends { opts?: Record<string, unknown> }>(fn: T): T {
   const original = fn.opts;
   if (!original) return fn;
@@ -413,91 +255,6 @@
       return Reflect.set(target, property, value, receiver);
     },
   });
-}
-
-export function parseReviewMd(markdown: string): ParsedReview {
-  const proposals: ParsedReviewProposal[] = [];
-
-  const lines = markdown.split(/\r?\n/u);
-  for (const line of lines) {
-    const match = /^\s*-\s*\[( |x|X|-)\]\s*(p-\d{8}-\d{3,})\b/u.exec(line);
-    if (!match?.[1] || !match[2]) continue;
-
-    const state = parseState(match[1]);
-    if (!state) continue;
-
-    proposals.push({
-      id: match[2],
-      state,
-    });
-  }
-
-  return { proposals };
-}
-
-export async function loadProposalState(redis: Pick<RedisLike, "lrange" | "hgetall">): Promise<ProposalStateSnapshot> {
-  const pending = await redis.lrange(REVIEW_PENDING_KEY, 0, -1);
-  const proposals: Record<string, StoredProposal> = {};
-
-  for (const id of pending) {
-    const stored = await redis.hgetall(proposalKey(id));
-    proposals[id] = {
-      id,
-      status: stored.status ?? "pending",
-      capturedAt: stored.capturedAt,
-      date: stored.date,
-      section: stored.section,
-      change: stored.change,
-    };
-  }
-
-  return { pending, proposals };
-}
-
-export function detectChanges(
-  currentState: unknown,
-  previousState: ProposalStateSnapshot,
-  now: Date = new Date()
-): ProposalDiff {
-  const current = parseCurrentState(currentState);
-  const approved: ProposalChange[] = [];
-  const rejected: ProposalChange[] = [];
-  const expired: ProposalChange[] = [];
-  const unchanged: ProposalChange[] = [];
-  const pending: string[] = [];
-
-  for (const id of previousState.pending) {
-    const proposal = previousState.proposals[id] ?? { id, status: "pending" };
-    const currentProposalState = current.get(id);
-
-    if (currentProposalState === "checked") {
-      approved.push({ id, proposal });
-      continue;
-    }
-
-    if (currentProposalState === "deleted" || currentProposalState === undefined) {
-      rejected.push({ id, proposal });
-      continue;
-    }
-
-    if (isExpired(proposal.capturedAt, now)) {
-      expired.push({ id, proposal });
-      continue;
-    }
-
-    unchanged.push({ id, proposal });
-    pending.push(id);
-  }
-
-  for (const [id, state] of current.entries()) {
-    if (previousState.pending.includes(id)) continue;
-    if (state === "unchecked") {
-      unchanged.push({ id, proposal: previousState.proposals[id] ?? { id, status: "pending" } });
-      pending.push(id);
-    }
-  }
-
-  return createStableDiff(approved, rejected, expired, unchanged, pending);
 }
 
 export async function promoteToMemory(proposalId: string): Promise<void> {
@@ -533,10 +290,9 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
-export async function archiveProposal(proposalId: string, reason: "deleted" | "marked-rejected"): Promise<void> {
+export async function archiveProposal(proposalId: string, reason: string): Promise<void> {
   const redis = getRedisClient();
   const key = proposalKey(proposalId);
   const proposal = await redis.hgetall(key);
@@ -549,7 +305,6 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
 export async function expireProposal(proposalId: string): Promise<void> {
@@ -567,115 +322,62 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
 const promoteFunction = stabilizeFunctionOpts(
   inngest.createFunction(
-  {
-    id: "memory/review-promote",
-    name: "Promote Review Decisions",
-  },
-  [
     {
-      event: "content/updated",
-      if: `event.data.path == \"${REVIEW_PATH_FILTER}\" || event.data.path.endsWith(\"/${REVIEW_FILE_NAME}\")`,
+      id: "memory/review-promote",
+      name: "Promote Review Decisions",
     },
-    { cron: "0 8 * * *" },
-  ],
-  async ({ event, step }) => {
-    const shouldSkip = await step.run("filter-review-events", async () => {
-      if (event.name !== "content/updated") return false;
-      const updatedPath = extractContentPath(event.data);
-      if (!updatedPath) return false;
-      return !updatedPath.toLowerCase().endsWith(`/${REVIEW_FILE_NAME.toLowerCase()}`);
-    });
-
-    if (shouldSkip) {
-      return {
-        skipped: true,
-        reason: "content/updated path does not target REVIEW.md",
-      };
-    }
-
-    const parsed = await step.run("parse-review", async () => {
-      const reviewFile = Bun.file(getReviewPath());
-      if (!(await reviewFile.exists())) {
-        return { proposals: [] } as ParsedReview;
-      }
-
-      const markdown = await reviewFile.text();
-      return parseReviewMd(markdown);
-    });
-
-    const previous = await step.run("load-state", async () => {
-      const redis = getRedisClient();
-      return loadProposalState(redis);
-    });
+    [{ event: "memory/proposal.approved" }, { event: "memory/proposal.rejected" }, { cron: "0 8 * * *" }],
+    async ({ event, step }) => {
+      if (event.name === "memory/proposal.approved") {
+        const proposalId = await step.run("resolve-approved-proposal-id", async () => {
+          const id = (event.data as { proposalId?: unknown }).proposalId;
+          if (typeof id !== "string" || id.trim().length === 0) {
+            throw new Error("memory/proposal.approved requires event.data.proposalId");
+          }
+          return id;
+        });
 
-    const changes = await step.run("detect-changes", async () => detectChanges(parsed, previous));
-
-    await step.run("route", async () => {
-      const parsedById = new Map(parsed.proposals.map((proposal) => [proposal.id, proposal]));
-
-      for (const change of changes.approved) {
-        await promoteToMemory(change.id);
+        await step.run("promote-approved-proposal", async () => promoteToMemory(proposalId));
+        return { approved: [proposalId] };
       }
 
-      for (const change of changes.rejected) {
-        const reason = parsedById.get(change.id)?.state === "deleted" ? "marked-rejected" : "deleted";
-        await archiveProposal(change.id, reason);
-      }
+      if (event.name === "memory/proposal.rejected") {
+        const payload = await step.run("resolve-rejected-payload", async () => {
+          const id = (event.data as { proposalId?: unknown }).proposalId;
+          const reason = (event.data as { reason?: unknown }).reason;
+          if (typeof id !== "string" || id.trim().length === 0) {
+            throw new Error("memory/proposal.rejected requires event.data.proposalId");
+          }
+          if (typeof reason !== "string" || reason.trim().length === 0) {
+            throw new Error("memory/proposal.rejected requires event.data.reason");
+          }
+          return { proposalId: id, reason };
+        });
 
-      for (const change of changes.expired) {
-        await expireProposal(change.id);
+        await step.run("archive-rejected-proposal", async () => archiveProposal(payload.proposalId, payload.reason));
+        return { rejected: [payload.proposalId], reason: payload.reason };
       }
-    });
-
-    const updateState = await step.run("update-state", async () => {
-      const redis = getRedisClient();
-      const nextPending = [...new Set(changes.pending)];
 
-      await redis.del(REVIEW_PENDING_KEY);
-      if (nextPending.length > 0) {
-        await redis.rpush(REVIEW_PENDING_KEY, ...nextPending);
-      }
+      const expiredIds = await step.run("expire-stale-proposals", async () => {
+        const redis = getRedisClient();
+        const pending = await redis.lrange(REVIEW_PENDING_KEY, 0, -1);
+        const expired: string[] = [];
 
-      const parsedById = new Map(parsed.proposals.map((proposal) => [proposal.id, proposal]));
-      for (const id of nextPending) {
-        const existing = previous.proposals[id];
-        const parsedProposal = parsedById.get(id);
-        await redis.hset(
-          proposalKey(id),
-          "id",
-          id,
-          "status",
-          "pending",
-          "state",
-          parsedProposal?.state ?? "unchecked",
-          "capturedAt",
-          existing?.capturedAt ?? new Date().toISOString(),
-          "date",
-          existing?.date ?? new Date().toISOString().slice(0, 10),
-          "section",
-          existing?.section ?? "",
-          "change",
-          existing?.change ?? ""
-        );
-      }
+        for (const proposalId of pending) {
+          if (!isProposalOlderThanSevenDays(proposalId)) continue;
+          await expireProposal(proposalId);
+          expired.push(proposalId);
+        }
 
-      return {
-        pending: nextPending,
-      };
-    });
+        return expired;
+      });
 
-    return {
-      approved: changes.approved.map((item) => item.id),
-      rejected: changes.rejected.map((item) => item.id),
-      expired: changes.expired.map((item) => item.id),
-      pending: updateState.pending,
-    };
-  }
+      return { expired: expiredIds };
+    }
   )
 );
 


thinking
**Preparing test and code adjustments**
codex
I’ve updated the integration test to use the new approved/rejected/cron events and removed legacy `content/updated` expectations. Next I’m running the requested `bun test` target and then `bunx tsc --noEmit` to verify end-to-end.
exec
/bin/zsh -lc 'bun test packages/system-bus/src/inngest/functions/promote.test.ts' in /private/tmp/agent-loop/loop-mlr8oxtg-b68bp4exec
/bin/zsh -lc 'bunx tsc --noEmit' in /private/tmp/agent-loop/loop-mlr8oxtg-b68bp4 succeeded in 466ms:

 succeeded in 507ms:
(pass) MEM-3 promote acceptance tests > approved proposal event promotes memory and leaves REVIEW.md untouched [334.27ms]
(pass) MEM-3 promote acceptance tests > rejected proposal event archives reason and leaves REVIEW.md untouched [4.13ms]
(pass) MEM-3 promote acceptance tests > cron trigger auto-expires proposals older than 7 days [3.67ms]
(pass) MEM-3 promote acceptance tests > direct public operations do not mutate REVIEW.md [133.28ms]

 6 pass
 0 fail
 7 expect() calls
Ran 6 tests across 1 file. [548.00ms]
file update:
diff --git a/packages/system-bus/src/inngest/functions/promote-integration.test.ts b/packages/system-bus/src/inngest/functions/promote-integration.test.ts
index ec552d8c5c0beb8271678d6aa7d39ccf1cdcb9e3..4fb7794ef87210aadf98f05d3d468912e127df10
--- a/packages/system-bus/src/inngest/functions/promote-integration.test.ts
+++ b/packages/system-bus/src/inngest/functions/promote-integration.test.ts
@@ -29,7 +29,6 @@
 
 let tempHome = "";
 let workspaceDir = "";
-let reviewPath = "";
 let memoryPath = "";
 
 function proposalKey(id: string): string {
@@ -189,7 +188,6 @@
   process.env.USERPROFILE = tempHome;
 
   workspaceDir = join(tempHome, ".joelclaw", "workspace");
-  reviewPath = join(workspaceDir, "REVIEW.md");
   memoryPath = join(workspaceDir, "MEMORY.md");
 
   mkdirSync(join(workspaceDir, "memory"), { recursive: true });
@@ -222,7 +220,7 @@
 });
 
 describe("MEM-22 promote integration acceptance test", () => {
-  test("runs end-to-end promotion workflow from REVIEW.md to MEMORY.md with no proposal loss", async () => {
+  test("runs end-to-end promotion workflow through event-driven handlers with no proposal loss", async () => {
     const approvedId = proposalIdDaysAgo(1, "101");
     const deletedId = proposalIdDaysAgo(1, "102");
     const expiredId = proposalIdDaysAgo(8, "103");
@@ -256,33 +254,32 @@
       capturedAt: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(),
     });
 
-    writeFileSync(
-      reviewPath,
-      [
-        "# REVIEW",
-        "",
-        `- [x] ${approvedId}: ${approvedText}`,
-        `- [ ] ${expiredId}: ${expiredText}`,
-        `- [ ] ${activePendingId}: ${activePendingText}`,
-        "",
-      ].join("\n")
-    );
-
-    const { result } = await executePromoteWithEvent({
-      name: "content/updated",
-      data: { path: reviewPath },
+    const { result: approvedResult } = await executePromoteWithEvent({
+      name: "memory/proposal.approved",
+      data: { proposalId: approvedId },
+    });
+    const { result: rejectedResult } = await executePromoteWithEvent({
+      name: "memory/proposal.rejected",
+      data: { proposalId: deletedId, reason: "deleted" },
+    });
+    const { result: expiredResult } = await executePromoteWithEvent({
+      name: "inngest/scheduled.timer",
+      data: { cron: "0 8 * * *" },
     });
 
     const memory = readFileSync(memoryPath, "utf8");
     const hardRules = getSectionBlock(memory, "Hard Rules");
     const log = readFileSync(todayLogPath(), "utf8");
-    const review = readFileSync(reviewPath, "utf8");
 
-    expect(result).toMatchObject({
+    expect(approvedResult).toMatchObject({
       approved: [approvedId],
+    });
+    expect(rejectedResult).toMatchObject({
       rejected: [deletedId],
+      reason: "deleted",
+    });
+    expect(expiredResult).toMatchObject({
       expired: [expiredId],
-      pending: [activePendingId],
     });
 
     expect(hardRules).toContain(`- (${proposalDateFromId(approvedId)})`);
@@ -296,11 +293,6 @@
     expect(redisState.hashes.has(proposalKey(approvedId))).toBe(false);
     expect(redisState.hashes.has(proposalKey(deletedId))).toBe(false);
     expect(redisState.hashes.has(proposalKey(expiredId))).toBe(false);
-
-    expect(review).toContain(activePendingId);
-    expect(review).not.toContain(approvedId);
-    expect(review).not.toContain(deletedId);
-    expect(review).not.toContain(expiredId);
 
     expect({
       approvedInMemory: hardRules.includes(`- (${proposalDateFromId(approvedId)})`),
diff --git a/packages/system-bus/src/inngest/functions/promote.ts b/packages/system-bus/src/inngest/functions/promote.ts
index 09730ecff690b4bfba745ef6f7b0a7469122608c..664e19e27ff0bfdc686be96c6935f256e17e25b6
--- a/packages/system-bus/src/inngest/functions/promote.ts
+++ b/packages/system-bus/src/inngest/functions/promote.ts
@@ -6,15 +6,6 @@
 
 export type ProposalState = "checked" | "unchecked" | "deleted";
 
-export type ParsedReviewProposal = {
-  id: string;
-  state: ProposalState;
-};
-
-export type ParsedReview = {
-  proposals: ParsedReviewProposal[];
-};
-
 export type StoredProposal = {
   id: string;
   status: string;
@@ -22,24 +13,6 @@
   date?: string;
   section?: string;
   change?: string;
-};
-
-export type ProposalStateSnapshot = {
-  pending: string[];
-  proposals: Record<string, StoredProposal>;
-};
-
-export type ProposalChange = {
-  id: string;
-  proposal?: StoredProposal;
-};
-
-export type ProposalDiff = {
-  approved: ProposalChange[];
-  rejected: ProposalChange[];
-  expired: ProposalChange[];
-  unchanged: ProposalChange[];
-  pending: string[];
 };
 
 type RedisLike = {
@@ -52,8 +25,6 @@
 };
 
 const REVIEW_PENDING_KEY = "memory:review:pending";
-const REVIEW_PATH_FILTER = "~/.joelclaw/workspace/REVIEW.md";
-const REVIEW_FILE_NAME = "REVIEW.md";
 const MEMORY_FILE_NAME = "MEMORY.md";
 const SEVEN_DAYS_MS = 7 * 24 * 60 * 60 * 1000;
 const REJECTED_PROPOSALS_HEADER = "### Rejected Proposals";
@@ -73,11 +44,6 @@
     redisClient.on("error", () => {});
   }
   return redisClient;
-}
-
-function getReviewPath(): string {
-  const home = process.env.HOME || process.env.USERPROFILE || "/Users/joel";
-  return join(home, ".joelclaw", "workspace", REVIEW_FILE_NAME);
 }
 
 function getMemoryPath(): string {
@@ -119,10 +85,6 @@
   if (date.getUTCMonth() !== monthIndex) return null;
   if (date.getUTCDate() !== day) return null;
   return date;
-}
-
-function escapeRegex(value: string): string {
-  return value.replace(/[.*+?^${}()|[\]\\]/gu, "\\$&");
 }
 
 function appendEntryToLogSection(markdown: string, header: string, entry: string): string {
@@ -158,20 +120,6 @@
   const existing = (await logFile.exists()) ? await logFile.text() : "";
   const next = appendEntryToLogSection(existing, header, entry);
   await Bun.write(logPath, next);
-}
-
-async function removeProposalFromReview(proposalId: string): Promise<void> {
-  const reviewPath = getReviewPath();
-  const reviewFile = Bun.file(reviewPath);
-  if (!(await reviewFile.exists())) return;
-
-  const markdown = await reviewFile.text();
-  const pattern = new RegExp(`^\\s*-\\s*\\[( |x|X|-)\\]\\s*${escapeRegex(proposalId)}\\b`, "u");
-  const nextLines = markdown.split(/\r?\n/u).filter((line) => !pattern.test(line));
-  const next = `${nextLines.join("\n").replace(/\n*$/u, "")}\n`;
-  if (next !== markdown) {
-    await Bun.write(reviewPath, next);
-  }
 }
 
 function isProposalOlderThanSevenDays(proposalId: string, now: Date = new Date()): boolean {
@@ -278,114 +226,8 @@
     .find((line) => line.length > 0);
 
   return formatted ?? proposedText;
-}
-
-function parseState(raw: string): ProposalState | null {
-  const value = raw.trim().toLowerCase();
-  if (value === "x") return "checked";
-  if (value === "-") return "deleted";
-  if (value === "") return "unchecked";
-  return null;
-}
-
-function parseCurrentState(currentState: unknown): Map<string, ProposalState> {
-  const map = new Map<string, ProposalState>();
-
-  if (!currentState || typeof currentState !== "object") return map;
-  const proposals = (currentState as { proposals?: unknown }).proposals;
-  if (!Array.isArray(proposals)) return map;
-
-  for (const proposal of proposals) {
-    if (!proposal || typeof proposal !== "object") continue;
-    const id = (proposal as { id?: unknown }).id;
-    const state = (proposal as { state?: unknown }).state;
-    if (typeof id !== "string") continue;
-    if (state === "checked" || state === "unchecked" || state === "deleted") {
-      map.set(id, state);
-    }
-  }
-
-  return map;
-}
-
-function isExpired(capturedAt: string | undefined, now: Date): boolean {
-  if (!capturedAt) return false;
-  const created = new Date(capturedAt);
-  if (Number.isNaN(created.getTime())) return false;
-  return now.getTime() - created.getTime() >= SEVEN_DAYS_MS;
 }
-
-function extractContentPath(eventData: unknown): string | null {
-  if (!eventData || typeof eventData !== "object") return null;
-  const rec = eventData as Record<string, unknown>;
 
-  const candidates = [rec.path, rec.filePath, rec.filepath];
-  for (const candidate of candidates) {
-    if (typeof candidate === "string" && candidate.length > 0) {
-      return candidate;
-    }
-  }
-
-  return null;
-}
-
-function createStableDiff(
-  approved: ProposalChange[],
-  rejected: ProposalChange[],
-  expired: ProposalChange[],
-  unchanged: ProposalChange[],
-  pending: string[]
-): ProposalDiff {
-  const data = {
-    approved,
-    rejected,
-    expired,
-    unchanged,
-    pending,
-  } satisfies ProposalDiff;
-
-  return new Proxy({} as ProposalDiff, {
-    get(_, property) {
-      if (property === "approved") return data.approved.map((item) => ({ ...item }));
-      if (property === "rejected") return data.rejected.map((item) => ({ ...item }));
-      if (property === "expired") return data.expired.map((item) => ({ ...item }));
-      if (property === "unchanged") return data.unchanged.map((item) => ({ ...item }));
-      if (property === "pending") return [...data.pending];
-      return undefined;
-    },
-    set() {
-      return true;
-    },
-    has(_, property) {
-      return (
-        property === "approved" ||
-        property === "rejected" ||
-        property === "expired" ||
-        property === "unchanged" ||
-        property === "pending"
-      );
-    },
-    ownKeys() {
-      return ["approved", "rejected", "expired", "unchanged", "pending"];
-    },
-    getOwnPropertyDescriptor(_, property) {
-      if (
-        property === "approved" ||
-        property === "rejected" ||
-        property === "expired" ||
-        property === "unchanged" ||
-        property === "pending"
-      ) {
-        return {
-          enumerable: true,
-          configurable: true,
-        };
-      }
-      return undefined;
-    },
-  });
-}
-
 function stabilizeFunctionOpts<T extends { opts?: Record<string, unknown> }>(fn: T): T {
   const original = fn.opts;
   if (!original) return fn;
@@ -413,91 +255,6 @@
       return Reflect.set(target, property, value, receiver);
     },
   });
-}
-
-export function parseReviewMd(markdown: string): ParsedReview {
-  const proposals: ParsedReviewProposal[] = [];
-
-  const lines = markdown.split(/\r?\n/u);
-  for (const line of lines) {
-    const match = /^\s*-\s*\[( |x|X|-)\]\s*(p-\d{8}-\d{3,})\b/u.exec(line);
-    if (!match?.[1] || !match[2]) continue;
-
-    const state = parseState(match[1]);
-    if (!state) continue;
-
-    proposals.push({
-      id: match[2],
-      state,
-    });
-  }
-
-  return { proposals };
-}
-
-export async function loadProposalState(redis: Pick<RedisLike, "lrange" | "hgetall">): Promise<ProposalStateSnapshot> {
-  const pending = await redis.lrange(REVIEW_PENDING_KEY, 0, -1);
-  const proposals: Record<string, StoredProposal> = {};
-
-  for (const id of pending) {
-    const stored = await redis.hgetall(proposalKey(id));
-    proposals[id] = {
-      id,
-      status: stored.status ?? "pending",
-      capturedAt: stored.capturedAt,
-      date: stored.date,
-      section: stored.section,
-      change: stored.change,
-    };
-  }
-
-  return { pending, proposals };
-}
-
-export function detectChanges(
-  currentState: unknown,
-  previousState: ProposalStateSnapshot,
-  now: Date = new Date()
-): ProposalDiff {
-  const current = parseCurrentState(currentState);
-  const approved: ProposalChange[] = [];
-  const rejected: ProposalChange[] = [];
-  const expired: ProposalChange[] = [];
-  const unchanged: ProposalChange[] = [];
-  const pending: string[] = [];
-
-  for (const id of previousState.pending) {
-    const proposal = previousState.proposals[id] ?? { id, status: "pending" };
-    const currentProposalState = current.get(id);
-
-    if (currentProposalState === "checked") {
-      approved.push({ id, proposal });
-      continue;
-    }
-
-    if (currentProposalState === "deleted" || currentProposalState === undefined) {
-      rejected.push({ id, proposal });
-      continue;
-    }
-
-    if (isExpired(proposal.capturedAt, now)) {
-      expired.push({ id, proposal });
-      continue;
-    }
-
-    unchanged.push({ id, proposal });
-    pending.push(id);
-  }
-
-  for (const [id, state] of current.entries()) {
-    if (previousState.pending.includes(id)) continue;
-    if (state === "unchecked") {
-      unchanged.push({ id, proposal: previousState.proposals[id] ?? { id, status: "pending" } });
-      pending.push(id);
-    }
-  }
-
-  return createStableDiff(approved, rejected, expired, unchanged, pending);
 }
 
 export async function promoteToMemory(proposalId: string): Promise<void> {
@@ -533,10 +290,9 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
-export async function archiveProposal(proposalId: string, reason: "deleted" | "marked-rejected"): Promise<void> {
+export async function archiveProposal(proposalId: string, reason: string): Promise<void> {
   const redis = getRedisClient();
   const key = proposalKey(proposalId);
   const proposal = await redis.hgetall(key);
@@ -549,7 +305,6 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
 export async function expireProposal(proposalId: string): Promise<void> {
@@ -567,115 +322,62 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
 const promoteFunction = stabilizeFunctionOpts(
   inngest.createFunction(
-  {
-    id: "memory/review-promote",
-    name: "Promote Review Decisions",
-  },
-  [
     {
-      event: "content/updated",
-      if: `event.data.path == \"${REVIEW_PATH_FILTER}\" || event.data.path.endsWith(\"/${REVIEW_FILE_NAME}\")`,
+      id: "memory/review-promote",
+      name: "Promote Review Decisions",
     },
-    { cron: "0 8 * * *" },
-  ],
-  async ({ event, step }) => {
-    const shouldSkip = await step.run("filter-review-events", async () => {
-      if (event.name !== "content/updated") return false;
-      const updatedPath = extractContentPath(event.data);
-      if (!updatedPath) return false;
-      return !updatedPath.toLowerCase().endsWith(`/${REVIEW_FILE_NAME.toLowerCase()}`);
-    });
-
-    if (shouldSkip) {
-      return {
-        skipped: true,
-        reason: "content/updated path does not target REVIEW.md",
-      };
-    }
-
-    const parsed = await step.run("parse-review", async () => {
-      const reviewFile = Bun.file(getReviewPath());
-      if (!(await reviewFile.exists())) {
-        return { proposals: [] } as ParsedReview;
-      }
-
-      const markdown = await reviewFile.text();
-      return parseReviewMd(markdown);
-    });
-
-    const previous = await step.run("load-state", async () => {
-      const redis = getRedisClient();
-      return loadProposalState(redis);
-    });
+    [{ event: "memory/proposal.approved" }, { event: "memory/proposal.rejected" }, { cron: "0 8 * * *" }],
+    async ({ event, step }) => {
+      if (event.name === "memory/proposal.approved") {
+        const proposalId = await step.run("resolve-approved-proposal-id", async () => {
+          const id = (event.data as { proposalId?: unknown }).proposalId;
+          if (typeof id !== "string" || id.trim().length === 0) {
+            throw new Error("memory/proposal.approved requires event.data.proposalId");
+          }
+          return id;
+        });
 
-    const changes = await step.run("detect-changes", async () => detectChanges(parsed, previous));
-
-    await step.run("route", async () => {
-      const parsedById = new Map(parsed.proposals.map((proposal) => [proposal.id, proposal]));
-
-      for (const change of changes.approved) {
-        await promoteToMemory(change.id);
+        await step.run("promote-approved-proposal", async () => promoteToMemory(proposalId));
+        return { approved: [proposalId] };
       }
 
-      for (const change of changes.rejected) {
-        const reason = parsedById.get(change.id)?.state === "deleted" ? "marked-rejected" : "deleted";
-        await archiveProposal(change.id, reason);
-      }
+      if (event.name === "memory/proposal.rejected") {
+        const payload = await step.run("resolve-rejected-payload", async () => {
+          const id = (event.data as { proposalId?: unknown }).proposalId;
+          const reason = (event.data as { reason?: unknown }).reason;
+          if (typeof id !== "string" || id.trim().length === 0) {
+            throw new Error("memory/proposal.rejected requires event.data.proposalId");
+          }
+          if (typeof reason !== "string" || reason.trim().length === 0) {
+            throw new Error("memory/proposal.rejected requires event.data.reason");
+          }
+          return { proposalId: id, reason };
+        });
 
-      for (const change of changes.expired) {
-        await expireProposal(change.id);
+        await step.run("archive-rejected-proposal", async () => archiveProposal(payload.proposalId, payload.reason));
+        return { rejected: [payload.proposalId], reason: payload.reason };
       }
-    });
-
-    const updateState = await step.run("update-state", async () => {
-      const redis = getRedisClient();
-      const nextPending = [...new Set(changes.pending)];
 
-      await redis.del(REVIEW_PENDING_KEY);
-      if (nextPending.length > 0) {
-        await redis.rpush(REVIEW_PENDING_KEY, ...nextPending);
-      }
+      const expiredIds = await step.run("expire-stale-proposals", async () => {
+        const redis = getRedisClient();
+        const pending = await redis.lrange(REVIEW_PENDING_KEY, 0, -1);
+        const expired: string[] = [];
 
-      const parsedById = new Map(parsed.proposals.map((proposal) => [proposal.id, proposal]));
-      for (const id of nextPending) {
-        const existing = previous.proposals[id];
-        const parsedProposal = parsedById.get(id);
-        await redis.hset(
-          proposalKey(id),
-          "id",
-          id,
-          "status",
-          "pending",
-          "state",
-          parsedProposal?.state ?? "unchecked",
-          "capturedAt",
-          existing?.capturedAt ?? new Date().toISOString(),
-          "date",
-          existing?.date ?? new Date().toISOString().slice(0, 10),
-          "section",
-          existing?.section ?? "",
-          "change",
-          existing?.change ?? ""
-        );
-      }
+        for (const proposalId of pending) {
+          if (!isProposalOlderThanSevenDays(proposalId)) continue;
+          await expireProposal(proposalId);
+          expired.push(proposalId);
+        }
 
-      return {
-        pending: nextPending,
-      };
-    });
+        return expired;
+      });
 
-    return {
-      approved: changes.approved.map((item) => item.id),
-      rejected: changes.rejected.map((item) => item.id),
-      expired: changes.expired.map((item) => item.id),
-      pending: updateState.pending,
-    };
-  }
+      return { expired: expiredIds };
+    }
   )
 );
 


thinking
**Verifying integration tests**
codex
The required test and typecheck both pass. I’m running the adjacent integration test once to make sure the interface change didn’t leave a regression in existing test coverage.
exec
/bin/zsh -lc 'bun test packages/system-bus/src/inngest/functions/promote-integration.test.ts' in /private/tmp/agent-loop/loop-mlr8oxtg-b68bp4 succeeded in 409ms:
promoteToMemory formatting failed (1): 551 |             if (isOAuth) {
552 |                 throw new Error(`Authentication failed for "${this.model.provider}". ` +
553 |                     `Credentials may have expired or network is unavailable. ` +
554 |                     `Run '/login ${this.model.provider}' to re-authenticate.`);
555 |             }
556 |             throw new Error(`No API key found for ${this.model.provider}.\n\n` +
                            ^
error: No API key found for amazon-bedrock.

Use /login or set an API key environment variable. See /Users/joel/.bun/install/global/node_modules/@mariozechner/pi-coding-agent/docs/providers.md
      at prompt (/Users/joel/.bun/install/global/node_modules/@mariozechner/pi-coding-agent/dist/core/agent-session.js:556:23)
      at async runPrintMode (/Users/joel/.bun/install/global/node_modules/@mariozechner/pi-coding-agent/dist/modes/print-mode.js:69:23)
      at async main (/Users/joel/.bun/install/global/node_modules/@mariozechner/pi-coding-agent/dist/main.js:626:15)

Bun v1.3.9 (macOS arm64)

(pass) MEM-22 promote integration acceptance test > runs end-to-end promotion workflow through event-driven handlers with no proposal loss [380.44ms]

 1 pass
 0 fail
file update:
diff --git a/packages/system-bus/src/inngest/functions/promote-integration.test.ts b/packages/system-bus/src/inngest/functions/promote-integration.test.ts
index ec552d8c5c0beb8271678d6aa7d39ccf1cdcb9e3..4fb7794ef87210aadf98f05d3d468912e127df10
--- a/packages/system-bus/src/inngest/functions/promote-integration.test.ts
+++ b/packages/system-bus/src/inngest/functions/promote-integration.test.ts
@@ -29,7 +29,6 @@
 
 let tempHome = "";
 let workspaceDir = "";
-let reviewPath = "";
 let memoryPath = "";
 
 function proposalKey(id: string): string {
@@ -189,7 +188,6 @@
   process.env.USERPROFILE = tempHome;
 
   workspaceDir = join(tempHome, ".joelclaw", "workspace");
-  reviewPath = join(workspaceDir, "REVIEW.md");
   memoryPath = join(workspaceDir, "MEMORY.md");
 
   mkdirSync(join(workspaceDir, "memory"), { recursive: true });
@@ -222,7 +220,7 @@
 });
 
 describe("MEM-22 promote integration acceptance test", () => {
-  test("runs end-to-end promotion workflow from REVIEW.md to MEMORY.md with no proposal loss", async () => {
+  test("runs end-to-end promotion workflow through event-driven handlers with no proposal loss", async () => {
     const approvedId = proposalIdDaysAgo(1, "101");
     const deletedId = proposalIdDaysAgo(1, "102");
     const expiredId = proposalIdDaysAgo(8, "103");
@@ -256,33 +254,32 @@
       capturedAt: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(),
     });
 
-    writeFileSync(
-      reviewPath,
-      [
-        "# REVIEW",
-        "",
-        `- [x] ${approvedId}: ${approvedText}`,
-        `- [ ] ${expiredId}: ${expiredText}`,
-        `- [ ] ${activePendingId}: ${activePendingText}`,
-        "",
-      ].join("\n")
-    );
-
-    const { result } = await executePromoteWithEvent({
-      name: "content/updated",
-      data: { path: reviewPath },
+    const { result: approvedResult } = await executePromoteWithEvent({
+      name: "memory/proposal.approved",
+      data: { proposalId: approvedId },
+    });
+    const { result: rejectedResult } = await executePromoteWithEvent({
+      name: "memory/proposal.rejected",
+      data: { proposalId: deletedId, reason: "deleted" },
+    });
+    const { result: expiredResult } = await executePromoteWithEvent({
+      name: "inngest/scheduled.timer",
+      data: { cron: "0 8 * * *" },
     });
 
     const memory = readFileSync(memoryPath, "utf8");
     const hardRules = getSectionBlock(memory, "Hard Rules");
     const log = readFileSync(todayLogPath(), "utf8");
-    const review = readFileSync(reviewPath, "utf8");
 
-    expect(result).toMatchObject({
+    expect(approvedResult).toMatchObject({
       approved: [approvedId],
+    });
+    expect(rejectedResult).toMatchObject({
       rejected: [deletedId],
+      reason: "deleted",
+    });
+    expect(expiredResult).toMatchObject({
       expired: [expiredId],
-      pending: [activePendingId],
     });
 
     expect(hardRules).toContain(`- (${proposalDateFromId(approvedId)})`);
@@ -296,11 +293,6 @@
     expect(redisState.hashes.has(proposalKey(approvedId))).toBe(false);
     expect(redisState.hashes.has(proposalKey(deletedId))).toBe(false);
     expect(redisState.hashes.has(proposalKey(expiredId))).toBe(false);
-
-    expect(review).toContain(activePendingId);
-    expect(review).not.toContain(approvedId);
-    expect(review).not.toContain(deletedId);
-    expect(review).not.toContain(expiredId);
 
     expect({
       approvedInMemory: hardRules.includes(`- (${proposalDateFromId(approvedId)})`),
diff --git a/packages/system-bus/src/inngest/functions/promote.ts b/packages/system-bus/src/inngest/functions/promote.ts
index 09730ecff690b4bfba745ef6f7b0a7469122608c..664e19e27ff0bfdc686be96c6935f256e17e25b6
--- a/packages/system-bus/src/inngest/functions/promote.ts
+++ b/packages/system-bus/src/inngest/functions/promote.ts
@@ -6,15 +6,6 @@
 
 export type ProposalState = "checked" | "unchecked" | "deleted";
 
-export type ParsedReviewProposal = {
-  id: string;
-  state: ProposalState;
-};
-
-export type ParsedReview = {
-  proposals: ParsedReviewProposal[];
-};
-
 export type StoredProposal = {
   id: string;
   status: string;
@@ -22,24 +13,6 @@
   date?: string;
   section?: string;
   change?: string;
-};
-
-export type ProposalStateSnapshot = {
-  pending: string[];
-  proposals: Record<string, StoredProposal>;
-};
-
-export type ProposalChange = {
-  id: string;
-  proposal?: StoredProposal;
-};
-
-export type ProposalDiff = {
-  approved: ProposalChange[];
-  rejected: ProposalChange[];
-  expired: ProposalChange[];
-  unchanged: ProposalChange[];
-  pending: string[];
 };
 
 type RedisLike = {
@@ -52,8 +25,6 @@
 };
 
 const REVIEW_PENDING_KEY = "memory:review:pending";
-const REVIEW_PATH_FILTER = "~/.joelclaw/workspace/REVIEW.md";
-const REVIEW_FILE_NAME = "REVIEW.md";
 const MEMORY_FILE_NAME = "MEMORY.md";
 const SEVEN_DAYS_MS = 7 * 24 * 60 * 60 * 1000;
 const REJECTED_PROPOSALS_HEADER = "### Rejected Proposals";
@@ -73,11 +44,6 @@
     redisClient.on("error", () => {});
   }
   return redisClient;
-}
-
-function getReviewPath(): string {
-  const home = process.env.HOME || process.env.USERPROFILE || "/Users/joel";
-  return join(home, ".joelclaw", "workspace", REVIEW_FILE_NAME);
 }
 
 function getMemoryPath(): string {
@@ -119,10 +85,6 @@
   if (date.getUTCMonth() !== monthIndex) return null;
   if (date.getUTCDate() !== day) return null;
   return date;
-}
-
-function escapeRegex(value: string): string {
-  return value.replace(/[.*+?^${}()|[\]\\]/gu, "\\$&");
 }
 
 function appendEntryToLogSection(markdown: string, header: string, entry: string): string {
@@ -158,20 +120,6 @@
   const existing = (await logFile.exists()) ? await logFile.text() : "";
   const next = appendEntryToLogSection(existing, header, entry);
   await Bun.write(logPath, next);
-}
-
-async function removeProposalFromReview(proposalId: string): Promise<void> {
-  const reviewPath = getReviewPath();
-  const reviewFile = Bun.file(reviewPath);
-  if (!(await reviewFile.exists())) return;
-
-  const markdown = await reviewFile.text();
-  const pattern = new RegExp(`^\\s*-\\s*\\[( |x|X|-)\\]\\s*${escapeRegex(proposalId)}\\b`, "u");
-  const nextLines = markdown.split(/\r?\n/u).filter((line) => !pattern.test(line));
-  const next = `${nextLines.join("\n").replace(/\n*$/u, "")}\n`;
-  if (next !== markdown) {
-    await Bun.write(reviewPath, next);
-  }
 }
 
 function isProposalOlderThanSevenDays(proposalId: string, now: Date = new Date()): boolean {
@@ -278,114 +226,8 @@
     .find((line) => line.length > 0);
 
   return formatted ?? proposedText;
-}
-
-function parseState(raw: string): ProposalState | null {
-  const value = raw.trim().toLowerCase();
-  if (value === "x") return "checked";
-  if (value === "-") return "deleted";
-  if (value === "") return "unchecked";
-  return null;
-}
-
-function parseCurrentState(currentState: unknown): Map<string, ProposalState> {
-  const map = new Map<string, ProposalState>();
-
-  if (!currentState || typeof currentState !== "object") return map;
-  const proposals = (currentState as { proposals?: unknown }).proposals;
-  if (!Array.isArray(proposals)) return map;
-
-  for (const proposal of proposals) {
-    if (!proposal || typeof proposal !== "object") continue;
-    const id = (proposal as { id?: unknown }).id;
-    const state = (proposal as { state?: unknown }).state;
-    if (typeof id !== "string") continue;
-    if (state === "checked" || state === "unchecked" || state === "deleted") {
-      map.set(id, state);
-    }
-  }
-
-  return map;
-}
-
-function isExpired(capturedAt: string | undefined, now: Date): boolean {
-  if (!capturedAt) return false;
-  const created = new Date(capturedAt);
-  if (Number.isNaN(created.getTime())) return false;
-  return now.getTime() - created.getTime() >= SEVEN_DAYS_MS;
 }
-
-function extractContentPath(eventData: unknown): string | null {
-  if (!eventData || typeof eventData !== "object") return null;
-  const rec = eventData as Record<string, unknown>;
 
-  const candidates = [rec.path, rec.filePath, rec.filepath];
-  for (const candidate of candidates) {
-    if (typeof candidate === "string" && candidate.length > 0) {
-      return candidate;
-    }
-  }
-
-  return null;
-}
-
-function createStableDiff(
-  approved: ProposalChange[],
-  rejected: ProposalChange[],
-  expired: ProposalChange[],
-  unchanged: ProposalChange[],
-  pending: string[]
-): ProposalDiff {
-  const data = {
-    approved,
-    rejected,
-    expired,
-    unchanged,
-    pending,
-  } satisfies ProposalDiff;
-
-  return new Proxy({} as ProposalDiff, {
-    get(_, property) {
-      if (property === "approved") return data.approved.map((item) => ({ ...item }));
-      if (property === "rejected") return data.rejected.map((item) => ({ ...item }));
-      if (property === "expired") return data.expired.map((item) => ({ ...item }));
-      if (property === "unchanged") return data.unchanged.map((item) => ({ ...item }));
-      if (property === "pending") return [...data.pending];
-      return undefined;
-    },
-    set() {
-      return true;
-    },
-    has(_, property) {
-      return (
-        property === "approved" ||
-        property === "rejected" ||
-        property === "expired" ||
-        property === "unchanged" ||
-        property === "pending"
-      );
-    },
-    ownKeys() {
-      return ["approved", "rejected", "expired", "unchanged", "pending"];
-    },
-    getOwnPropertyDescriptor(_, property) {
-      if (
-        property === "approved" ||
-        property === "rejected" ||
-        property === "expired" ||
-        property === "unchanged" ||
-        property === "pending"
-      ) {
-        return {
-          enumerable: true,
-          configurable: true,
-        };
-      }
-      return undefined;
-    },
-  });
-}
-
 function stabilizeFunctionOpts<T extends { opts?: Record<string, unknown> }>(fn: T): T {
   const original = fn.opts;
   if (!original) return fn;
@@ -413,91 +255,6 @@
       return Reflect.set(target, property, value, receiver);
     },
   });
-}
-
-export function parseReviewMd(markdown: string): ParsedReview {
-  const proposals: ParsedReviewProposal[] = [];
-
-  const lines = markdown.split(/\r?\n/u);
-  for (const line of lines) {
-    const match = /^\s*-\s*\[( |x|X|-)\]\s*(p-\d{8}-\d{3,})\b/u.exec(line);
-    if (!match?.[1] || !match[2]) continue;
-
-    const state = parseState(match[1]);
-    if (!state) continue;
-
-    proposals.push({
-      id: match[2],
-      state,
-    });
-  }
-
-  return { proposals };
-}
-
-export async function loadProposalState(redis: Pick<RedisLike, "lrange" | "hgetall">): Promise<ProposalStateSnapshot> {
-  const pending = await redis.lrange(REVIEW_PENDING_KEY, 0, -1);
-  const proposals: Record<string, StoredProposal> = {};
-
-  for (const id of pending) {
-    const stored = await redis.hgetall(proposalKey(id));
-    proposals[id] = {
-      id,
-      status: stored.status ?? "pending",
-      capturedAt: stored.capturedAt,
-      date: stored.date,
-      section: stored.section,
-      change: stored.change,
-    };
-  }
-
-  return { pending, proposals };
-}
-
-export function detectChanges(
-  currentState: unknown,
-  previousState: ProposalStateSnapshot,
-  now: Date = new Date()
-): ProposalDiff {
-  const current = parseCurrentState(currentState);
-  const approved: ProposalChange[] = [];
-  const rejected: ProposalChange[] = [];
-  const expired: ProposalChange[] = [];
-  const unchanged: ProposalChange[] = [];
-  const pending: string[] = [];
-
-  for (const id of previousState.pending) {
-    const proposal = previousState.proposals[id] ?? { id, status: "pending" };
-    const currentProposalState = current.get(id);
-
-    if (currentProposalState === "checked") {
-      approved.push({ id, proposal });
-      continue;
-    }
-
-    if (currentProposalState === "deleted" || currentProposalState === undefined) {
-      rejected.push({ id, proposal });
-      continue;
-    }
-
-    if (isExpired(proposal.capturedAt, now)) {
-      expired.push({ id, proposal });
-      continue;
-    }
-
-    unchanged.push({ id, proposal });
-    pending.push(id);
-  }
-
-  for (const [id, state] of current.entries()) {
-    if (previousState.pending.includes(id)) continue;
-    if (state === "unchecked") {
-      unchanged.push({ id, proposal: previousState.proposals[id] ?? { id, status: "pending" } });
-      pending.push(id);
-    }
-  }
-
-  return createStableDiff(approved, rejected, expired, unchanged, pending);
 }
 
 export async function promoteToMemory(proposalId: string): Promise<void> {
@@ -533,10 +290,9 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
-export async function archiveProposal(proposalId: string, reason: "deleted" | "marked-rejected"): Promise<void> {
+export async function archiveProposal(proposalId: string, reason: string): Promise<void> {
   const redis = getRedisClient();
   const key = proposalKey(proposalId);
   const proposal = await redis.hgetall(key);
@@ -549,7 +305,6 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
 export async function expireProposal(proposalId: string): Promise<void> {
@@ -567,115 +322,62 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
 const promoteFunction = stabilizeFunctionOpts(
   inngest.createFunction(
-  {
-    id: "memory/review-promote",
-    name: "Promote Review Decisions",
-  },
-  [
     {
-      event: "content/updated",
-      if: `event.data.path == \"${REVIEW_PATH_FILTER}\" || event.data.path.endsWith(\"/${REVIEW_FILE_NAME}\")`,
+      id: "memory/review-promote",
+      name: "Promote Review Decisions",
     },
-    { cron: "0 8 * * *" },
-  ],
-  async ({ event, step }) => {
-    const shouldSkip = await step.run("filter-review-events", async () => {
-      if (event.name !== "content/updated") return false;
-      const updatedPath = extractContentPath(event.data);
-      if (!updatedPath) return false;
-      return !updatedPath.toLowerCase().endsWith(`/${REVIEW_FILE_NAME.toLowerCase()}`);
-    });
-
-    if (shouldSkip) {
-      return {
-        skipped: true,
-        reason: "content/updated path does not target REVIEW.md",
-      };
-    }
-
-    const parsed = await step.run("parse-review", async () => {
-      const reviewFile = Bun.file(getReviewPath());
-      if (!(await reviewFile.exists())) {
-        return { proposals: [] } as ParsedReview;
-      }
-
-      const markdown = await reviewFile.text();
-      return parseReviewMd(markdown);
-    });
-
-    const previous = await step.run("load-state", async () => {
-      const redis = getRedisClient();
-      return loadProposalState(redis);
-    });
+    [{ event: "memory/proposal.approved" }, { event: "memory/proposal.rejected" }, { cron: "0 8 * * *" }],
+    async ({ event, step }) => {
+      if (event.name === "memory/proposal.approved") {
+        const proposalId = await step.run("resolve-approved-proposal-id", async () => {
+          const id = (event.data as { proposalId?: unknown }).proposalId;
+          if (typeof id !== "string" || id.trim().length === 0) {
+            throw new Error("memory/proposal.approved requires event.data.proposalId");
+          }
+          return id;
+        });
 
-    const changes = await step.run("detect-changes", async () => detectChanges(parsed, previous));
-
-    await step.run("route", async () => {
-      const parsedById = new Map(parsed.proposals.map((proposal) => [proposal.id, proposal]));
-
-      for (const change of changes.approved) {
-        await promoteToMemory(change.id);
+        await step.run("promote-approved-proposal", async () => promoteToMemory(proposalId));
+        return { approved: [proposalId] };
       }
 
-      for (const change of changes.rejected) {
-        const reason = parsedById.get(change.id)?.state === "deleted" ? "marked-rejected" : "deleted";
-        await archiveProposal(change.id, reason);
-      }
+      if (event.name === "memory/proposal.rejected") {
+        const payload = await step.run("resolve-rejected-payload", async () => {
+          const id = (event.data as { proposalId?: unknown }).proposalId;
+          const reason = (event.data as { reason?: unknown }).reason;
+          if (typeof id !== "string" || id.trim().length === 0) {
+            throw new Error("memory/proposal.rejected requires event.data.proposalId");
+          }
+          if (typeof reason !== "string" || reason.trim().length === 0) {
+            throw new Error("memory/proposal.rejected requires event.data.reason");
+          }
+          return { proposalId: id, reason };
+        });
 
-      for (const change of changes.expired) {
-        await expireProposal(change.id);
+        await step.run("archive-rejected-proposal", async () => archiveProposal(payload.proposalId, payload.reason));
+        return { rejected: [payload.proposalId], reason: payload.reason };
       }
-    });
-
-    const updateState = await step.run("update-state", async () => {
-      const redis = getRedisClient();
-      const nextPending = [...new Set(changes.pending)];
 
-      await redis.del(REVIEW_PENDING_KEY);
-      if (nextPending.length > 0) {
-        await redis.rpush(REVIEW_PENDING_KEY, ...nextPending);
-      }
+      const expiredIds = await step.run("expire-stale-proposals", async () => {
+        const redis = getRedisClient();
+        const pending = await redis.lrange(REVIEW_PENDING_KEY, 0, -1);
+        const expired: string[] = [];
 
-      const parsedById = new Map(parsed.proposals.map((proposal) => [proposal.id, proposal]));
-      for (const id of nextPending) {
-        const existing = previous.proposals[id];
-        const parsedProposal = parsedById.get(id);
-        await redis.hset(
-          proposalKey(id),
-          "id",
-          id,
-          "status",
-          "pending",
-          "state",
-          parsedProposal?.state ?? "unchecked",
-          "capturedAt",
-          existing?.capturedAt ?? new Date().toISOString(),
-          "date",
-          existing?.date ?? new Date().toISOString().slice(0, 10),
-          "section",
-          existing?.section ?? "",
-          "change",
-          existing?.change ?? ""
-        );
-      }
+        for (const proposalId of pending) {
+          if (!isProposalOlderThanSevenDays(proposalId)) continue;
+          await expireProposal(proposalId);
+          expired.push(proposalId);
+        }
 
-      return {
-        pending: nextPending,
-      };
-    });
+        return expired;
+      });
 
-    return {
-      approved: changes.approved.map((item) => item.id),
-      rejected: changes.rejected.map((item) => item.id),
-      expired: changes.expired.map((item) => item.id),
-      pending: updateState.pending,
-    };
-  }
+      return { expired: expiredIds };
+    }
   )
 );
 


thinking
**Verifying fallback handling**
exec
/bin/zsh -lc 'git status --short' in /private/tmp/agent-loop/loop-mlr8oxtg-b68bp4exec
/bin/zsh -lc 'git diff -- packages/system-bus/src/inngest/functions/promote.ts packages/system-bus/src/inngest/functions/promote.test.ts packages/system-bus/src/inngest/functions/promote-integration.test.ts' in /private/tmp/agent-loop/loop-mlr8oxtg-b68bp4 succeeded in 52ms:
 M packages/system-bus/src/inngest/functions/promote-integration.test.ts
 M packages/system-bus/src/inngest/functions/promote.test.ts
 M packages/system-bus/src/inngest/functions/promote.ts
 M prd.json
?? pid
 succeeded in 52ms:
diff --git a/packages/system-bus/src/inngest/functions/promote-integration.test.ts b/packages/system-bus/src/inngest/functions/promote-integration.test.ts
index ec552d8..4fb7794 100644
--- a/packages/system-bus/src/inngest/functions/promote-integration.test.ts
+++ b/packages/system-bus/src/inngest/functions/promote-integration.test.ts
@@ -29,7 +29,6 @@ let redisState: RedisMockState = {
 
 let tempHome = "";
 let workspaceDir = "";
-let reviewPath = "";
 let memoryPath = "";
 
 function proposalKey(id: string): string {
@@ -189,7 +188,6 @@ beforeEach(() => {
   process.env.USERPROFILE = tempHome;
 
   workspaceDir = join(tempHome, ".joelclaw", "workspace");
-  reviewPath = join(workspaceDir, "REVIEW.md");
   memoryPath = join(workspaceDir, "MEMORY.md");
 
   mkdirSync(join(workspaceDir, "memory"), { recursive: true });
file update:
diff --git a/packages/system-bus/src/inngest/functions/promote-integration.test.ts b/packages/system-bus/src/inngest/functions/promote-integration.test.ts
index ec552d8c5c0beb8271678d6aa7d39ccf1cdcb9e3..4fb7794ef87210aadf98f05d3d468912e127df10
--- a/packages/system-bus/src/inngest/functions/promote-integration.test.ts
+++ b/packages/system-bus/src/inngest/functions/promote-integration.test.ts
@@ -29,7 +29,6 @@
 
 let tempHome = "";
 let workspaceDir = "";
-let reviewPath = "";
 let memoryPath = "";
 
 function proposalKey(id: string): string {
@@ -189,7 +188,6 @@
   process.env.USERPROFILE = tempHome;
 
   workspaceDir = join(tempHome, ".joelclaw", "workspace");
-  reviewPath = join(workspaceDir, "REVIEW.md");
   memoryPath = join(workspaceDir, "MEMORY.md");
 
   mkdirSync(join(workspaceDir, "memory"), { recursive: true });
@@ -222,7 +220,7 @@
 });
 
 describe("MEM-22 promote integration acceptance test", () => {
-  test("runs end-to-end promotion workflow from REVIEW.md to MEMORY.md with no proposal loss", async () => {
+  test("runs end-to-end promotion workflow through event-driven handlers with no proposal loss", async () => {
     const approvedId = proposalIdDaysAgo(1, "101");
     const deletedId = proposalIdDaysAgo(1, "102");
     const expiredId = proposalIdDaysAgo(8, "103");
@@ -256,33 +254,32 @@
       capturedAt: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(),
     });
 
-    writeFileSync(
-      reviewPath,
-      [
-        "# REVIEW",
-        "",
-        `- [x] ${approvedId}: ${approvedText}`,
-        `- [ ] ${expiredId}: ${expiredText}`,
-        `- [ ] ${activePendingId}: ${activePendingText}`,
-        "",
-      ].join("\n")
-    );
-
-    const { result } = await executePromoteWithEvent({
-      name: "content/updated",
-      data: { path: reviewPath },
+    const { result: approvedResult } = await executePromoteWithEvent({
+      name: "memory/proposal.approved",
+      data: { proposalId: approvedId },
+    });
+    const { result: rejectedResult } = await executePromoteWithEvent({
+      name: "memory/proposal.rejected",
+      data: { proposalId: deletedId, reason: "deleted" },
+    });
+    const { result: expiredResult } = await executePromoteWithEvent({
+      name: "inngest/scheduled.timer",
+      data: { cron: "0 8 * * *" },
     });
 
     const memory = readFileSync(memoryPath, "utf8");
     const hardRules = getSectionBlock(memory, "Hard Rules");
     const log = readFileSync(todayLogPath(), "utf8");
-    const review = readFileSync(reviewPath, "utf8");
 
-    expect(result).toMatchObject({
+    expect(approvedResult).toMatchObject({
       approved: [approvedId],
+    });
+    expect(rejectedResult).toMatchObject({
       rejected: [deletedId],
+      reason: "deleted",
+    });
+    expect(expiredResult).toMatchObject({
       expired: [expiredId],
-      pending: [activePendingId],
     });
 
     expect(hardRules).toContain(`- (${proposalDateFromId(approvedId)})`);
@@ -296,11 +293,6 @@
     expect(redisState.hashes.has(proposalKey(approvedId))).toBe(false);
     expect(redisState.hashes.has(proposalKey(deletedId))).toBe(false);
     expect(redisState.hashes.has(proposalKey(expiredId))).toBe(false);
-
-    expect(review).toContain(activePendingId);
-    expect(review).not.toContain(approvedId);
-    expect(review).not.toContain(deletedId);
-    expect(review).not.toContain(expiredId);
 
     expect({
       approvedInMemory: hardRules.includes(`- (${proposalDateFromId(approvedId)})`),
diff --git a/packages/system-bus/src/inngest/functions/promote.ts b/packages/system-bus/src/inngest/functions/promote.ts
index 09730ecff690b4bfba745ef6f7b0a7469122608c..664e19e27ff0bfdc686be96c6935f256e17e25b6
--- a/packages/system-bus/src/inngest/functions/promote.ts
+++ b/packages/system-bus/src/inngest/functions/promote.ts
@@ -6,15 +6,6 @@
 
 export type ProposalState = "checked" | "unchecked" | "deleted";
 
-export type ParsedReviewProposal = {
-  id: string;
-  state: ProposalState;
-};
-
-export type ParsedReview = {
-  proposals: ParsedReviewProposal[];
-};
-
 export type StoredProposal = {
   id: string;
   status: string;
@@ -22,24 +13,6 @@
   date?: string;
   section?: string;
   change?: string;
-};
-
-export type ProposalStateSnapshot = {
-  pending: string[];
-  proposals: Record<string, StoredProposal>;
-};
-
-export type ProposalChange = {
-  id: string;
-  proposal?: StoredProposal;
-};
-
-export type ProposalDiff = {
-  approved: ProposalChange[];
-  rejected: ProposalChange[];
-  expired: ProposalChange[];
-  unchanged: ProposalChange[];
-  pending: string[];
 };
 
 type RedisLike = {
@@ -52,8 +25,6 @@
 };
 
 const REVIEW_PENDING_KEY = "memory:review:pending";
-const REVIEW_PATH_FILTER = "~/.joelclaw/workspace/REVIEW.md";
-const REVIEW_FILE_NAME = "REVIEW.md";
 const MEMORY_FILE_NAME = "MEMORY.md";
 const SEVEN_DAYS_MS = 7 * 24 * 60 * 60 * 1000;
 const REJECTED_PROPOSALS_HEADER = "### Rejected Proposals";
@@ -73,11 +44,6 @@
     redisClient.on("error", () => {});
   }
   return redisClient;
-}
-
-function getReviewPath(): string {
-  const home = process.env.HOME || process.env.USERPROFILE || "/Users/joel";
-  return join(home, ".joelclaw", "workspace", REVIEW_FILE_NAME);
 }
 
 function getMemoryPath(): string {
@@ -119,10 +85,6 @@
   if (date.getUTCMonth() !== monthIndex) return null;
   if (date.getUTCDate() !== day) return null;
   return date;
-}
-
-function escapeRegex(value: string): string {
-  return value.replace(/[.*+?^${}()|[\]\\]/gu, "\\$&");
 }
 
 function appendEntryToLogSection(markdown: string, header: string, entry: string): string {
@@ -158,20 +120,6 @@
   const existing = (await logFile.exists()) ? await logFile.text() : "";
   const next = appendEntryToLogSection(existing, header, entry);
   await Bun.write(logPath, next);
-}
-
-async function removeProposalFromReview(proposalId: string): Promise<void> {
-  const reviewPath = getReviewPath();
-  const reviewFile = Bun.file(reviewPath);
-  if (!(await reviewFile.exists())) return;
-
-  const markdown = await reviewFile.text();
-  const pattern = new RegExp(`^\\s*-\\s*\\[( |x|X|-)\\]\\s*${escapeRegex(proposalId)}\\b`, "u");
-  const nextLines = markdown.split(/\r?\n/u).filter((line) => !pattern.test(line));
-  const next = `${nextLines.join("\n").replace(/\n*$/u, "")}\n`;
-  if (next !== markdown) {
-    await Bun.write(reviewPath, next);
-  }
 }
 
 function isProposalOlderThanSevenDays(proposalId: string, now: Date = new Date()): boolean {
@@ -278,114 +226,8 @@
     .find((line) => line.length > 0);
 
   return formatted ?? proposedText;
-}
-
-function parseState(raw: string): ProposalState | null {
-  const value = raw.trim().toLowerCase();
-  if (value === "x") return "checked";
-  if (value === "-") return "deleted";
-  if (value === "") return "unchecked";
-  return null;
-}
-
-function parseCurrentState(currentState: unknown): Map<string, ProposalState> {
-  const map = new Map<string, ProposalState>();
-
-  if (!currentState || typeof currentState !== "object") return map;
-  const proposals = (currentState as { proposals?: unknown }).proposals;
-  if (!Array.isArray(proposals)) return map;
-
-  for (const proposal of proposals) {
-    if (!proposal || typeof proposal !== "object") continue;
-    const id = (proposal as { id?: unknown }).id;
-    const state = (proposal as { state?: unknown }).state;
-    if (typeof id !== "string") continue;
-    if (state === "checked" || state === "unchecked" || state === "deleted") {
-      map.set(id, state);
-    }
-  }
-
-  return map;
-}
-
-function isExpired(capturedAt: string | undefined, now: Date): boolean {
-  if (!capturedAt) return false;
-  const created = new Date(capturedAt);
-  if (Number.isNaN(created.getTime())) return false;
-  return now.getTime() - created.getTime() >= SEVEN_DAYS_MS;
 }
-
-function extractContentPath(eventData: unknown): string | null {
-  if (!eventData || typeof eventData !== "object") return null;
-  const rec = eventData as Record<string, unknown>;
 
-  const candidates = [rec.path, rec.filePath, rec.filepath];
-  for (const candidate of candidates) {
-    if (typeof candidate === "string" && candidate.length > 0) {
-      return candidate;
-    }
-  }
-
-  return null;
-}
-
-function createStableDiff(
-  approved: ProposalChange[],
-  rejected: ProposalChange[],
-  expired: ProposalChange[],
-  unchanged: ProposalChange[],
-  pending: string[]
-): ProposalDiff {
-  const data = {
-    approved,
-    rejected,
-    expired,
-    unchanged,
-    pending,
-  } satisfies ProposalDiff;
-
-  return new Proxy({} as ProposalDiff, {
-    get(_, property) {
-      if (property === "approved") return data.approved.map((item) => ({ ...item }));
-      if (property === "rejected") return data.rejected.map((item) => ({ ...item }));
-      if (property === "expired") return data.expired.map((item) => ({ ...item }));
-      if (property === "unchanged") return data.unchanged.map((item) => ({ ...item }));
-      if (property === "pending") return [...data.pending];
-      return undefined;
-    },
-    set() {
-      return true;
-    },
-    has(_, property) {
-      return (
-        property === "approved" ||
-        property === "rejected" ||
-        property === "expired" ||
-        property === "unchanged" ||
-        property === "pending"
-      );
-    },
-    ownKeys() {
-      return ["approved", "rejected", "expired", "unchanged", "pending"];
-    },
-    getOwnPropertyDescriptor(_, property) {
-      if (
-        property === "approved" ||
-        property === "rejected" ||
-        property === "expired" ||
-        property === "unchanged" ||
-        property === "pending"
-      ) {
-        return {
-          enumerable: true,
-          configurable: true,
-        };
-      }
-      return undefined;
-    },
-  });
-}
-
 function stabilizeFunctionOpts<T extends { opts?: Record<string, unknown> }>(fn: T): T {
   const original = fn.opts;
   if (!original) return fn;
@@ -413,91 +255,6 @@
       return Reflect.set(target, property, value, receiver);
     },
   });
-}
-
-export function parseReviewMd(markdown: string): ParsedReview {
-  const proposals: ParsedReviewProposal[] = [];
-
-  const lines = markdown.split(/\r?\n/u);
-  for (const line of lines) {
-    const match = /^\s*-\s*\[( |x|X|-)\]\s*(p-\d{8}-\d{3,})\b/u.exec(line);
-    if (!match?.[1] || !match[2]) continue;
-
-    const state = parseState(match[1]);
-    if (!state) continue;
-
-    proposals.push({
-      id: match[2],
-      state,
-    });
-  }
-
-  return { proposals };
-}
-
-export async function loadProposalState(redis: Pick<RedisLike, "lrange" | "hgetall">): Promise<ProposalStateSnapshot> {
-  const pending = await redis.lrange(REVIEW_PENDING_KEY, 0, -1);
-  const proposals: Record<string, StoredProposal> = {};
-
-  for (const id of pending) {
-    const stored = await redis.hgetall(proposalKey(id));
-    proposals[id] = {
-      id,
-      status: stored.status ?? "pending",
-      capturedAt: stored.capturedAt,
-      date: stored.date,
-      section: stored.section,
-      change: stored.change,
-    };
-  }
-
-  return { pending, proposals };
-}
-
-export function detectChanges(
-  currentState: unknown,
-  previousState: ProposalStateSnapshot,
-  now: Date = new Date()
-): ProposalDiff {
-  const current = parseCurrentState(currentState);
-  const approved: ProposalChange[] = [];
-  const rejected: ProposalChange[] = [];
-  const expired: ProposalChange[] = [];
-  const unchanged: ProposalChange[] = [];
-  const pending: string[] = [];
-
-  for (const id of previousState.pending) {
-    const proposal = previousState.proposals[id] ?? { id, status: "pending" };
-    const currentProposalState = current.get(id);
-
-    if (currentProposalState === "checked") {
-      approved.push({ id, proposal });
-      continue;
-    }
-
-    if (currentProposalState === "deleted" || currentProposalState === undefined) {
-      rejected.push({ id, proposal });
-      continue;
-    }
-
-    if (isExpired(proposal.capturedAt, now)) {
-      expired.push({ id, proposal });
-      continue;
-    }
-
-    unchanged.push({ id, proposal });
-    pending.push(id);
-  }
-
-  for (const [id, state] of current.entries()) {
-    if (previousState.pending.includes(id)) continue;
-    if (state === "unchecked") {
-      unchanged.push({ id, proposal: previousState.proposals[id] ?? { id, status: "pending" } });
-      pending.push(id);
-    }
-  }
-
-  return createStableDiff(approved, rejected, expired, unchanged, pending);
 }
 
 export async function promoteToMemory(proposalId: string): Promise<void> {
@@ -533,10 +290,9 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
-export async function archiveProposal(proposalId: string, reason: "deleted" | "marked-rejected"): Promise<void> {
+export async function archiveProposal(proposalId: string, reason: string): Promise<void> {
   const redis = getRedisClient();
   const key = proposalKey(proposalId);
   const proposal = await redis.hgetall(key);
@@ -549,7 +305,6 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
 export async function expireProposal(proposalId: string): Promise<void> {
@@ -567,115 +322,62 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
 const promoteFunction = stabilizeFunctionOpts(
   inngest.createFunction(
-  {
-    id: "memory/review-promote",
-    name: "Promote Review Decisions",
-  },
-  [
     {
-      event: "content/updated",
-      if: `event.data.path == \"${REVIEW_PATH_FILTER}\" || event.data.path.endsWith(\"/${REVIEW_FILE_NAME}\")`,
+      id: "memory/review-promote",
+      name: "Promote Review Decisions",
     },
-    { cron: "0 8 * * *" },
-  ],
-  async ({ event, step }) => {
-    const shouldSkip = await step.run("filter-review-events", async () => {
-      if (event.name !== "content/updated") return false;
-      const updatedPath = extractContentPath(event.data);
-      if (!updatedPath) return false;
-      return !updatedPath.toLowerCase().endsWith(`/${REVIEW_FILE_NAME.toLowerCase()}`);
-    });
-
-    if (shouldSkip) {
-      return {
-        skipped: true,
-        reason: "content/updated path does not target REVIEW.md",
-      };
-    }
-
-    const parsed = await step.run("parse-review", async () => {
-      const reviewFile = Bun.file(getReviewPath());
-      if (!(await reviewFile.exists())) {
-        return { proposals: [] } as ParsedReview;
-      }
-
-      const markdown = await reviewFile.text();
-      return parseReviewMd(markdown);
-    });
-
-    const previous = await step.run("load-state", async () => {
-      const redis = getRedisClient();
-      return loadProposalState(redis);
-    });
+    [{ event: "memory/proposal.approved" }, { event: "memory/proposal.rejected" }, { cron: "0 8 * * *" }],
+    async ({ event, step }) => {
+      if (event.name === "memory/proposal.approved") {
+        const proposalId = await step.run("resolve-approved-proposal-id", async () => {
+          const id = (event.data as { proposalId?: unknown }).proposalId;
+          if (typeof id !== "string" || id.trim().length === 0) {
+            throw new Error("memory/proposal.approved requires event.data.proposalId");
+          }
+          return id;
+        });
 
-    const changes = await step.run("detect-changes", async () => detectChanges(parsed, previous));
-
-    await step.run("route", async () => {
-      const parsedById = new Map(parsed.proposals.map((proposal) => [proposal.id, proposal]));
-
-      for (const change of changes.approved) {
-        await promoteToMemory(change.id);
+        await step.run("promote-approved-proposal", async () => promoteToMemory(proposalId));
+        return { approved: [proposalId] };
       }
 
-      for (const change of changes.rejected) {
-        const reason = parsedById.get(change.id)?.state === "deleted" ? "marked-rejected" : "deleted";
-        await archiveProposal(change.id, reason);
-      }
+      if (event.name === "memory/proposal.rejected") {
+        const payload = await step.run("resolve-rejected-payload", async () => {
+          const id = (event.data as { proposalId?: unknown }).proposalId;
+          const reason = (event.data as { reason?: unknown }).reason;
+          if (typeof id !== "string" || id.trim().length === 0) {
+            throw new Error("memory/proposal.rejected requires event.data.proposalId");
+          }
+          if (typeof reason !== "string" || reason.trim().length === 0) {
+            throw new Error("memory/proposal.rejected requires event.data.reason");
+          }
+          return { proposalId: id, reason };
+        });
 
-      for (const change of changes.expired) {
-        await expireProposal(change.id);
+        await step.run("archive-rejected-proposal", async () => archiveProposal(payload.proposalId, payload.reason));
+        return { rejected: [payload.proposalId], reason: payload.reason };
       }
-    });
-
-    const updateState = await step.run("update-state", async () => {
-      const redis = getRedisClient();
-      const nextPending = [...new Set(changes.pending)];
 
-      await redis.del(REVIEW_PENDING_KEY);
-      if (nextPending.length > 0) {
-        await redis.rpush(REVIEW_PENDING_KEY, ...nextPending);
-      }
+      const expiredIds = await step.run("expire-stale-proposals", async () => {
+        const redis = getRedisClient();
+        const pending = await redis.lrange(REVIEW_PENDING_KEY, 0, -1);
+        const expired: string[] = [];
 
-      const parsedById = new Map(parsed.proposals.map((proposal) => [proposal.id, proposal]));
-      for (const id of nextPending) {
-        const existing = previous.proposals[id];
-        const parsedProposal = parsedById.get(id);
-        await redis.hset(
-          proposalKey(id),
-          "id",
-          id,
-          "status",
-          "pending",
-          "state",
-          parsedProposal?.state ?? "unchecked",
-          "capturedAt",
-          existing?.capturedAt ?? new Date().toISOString(),
-          "date",
-          existing?.date ?? new Date().toISOString().slice(0, 10),
-          "section",
-          existing?.section ?? "",
-          "change",
-          existing?.change ?? ""
-        );
-      }
+        for (const proposalId of pending) {
+          if (!isProposalOlderThanSevenDays(proposalId)) continue;
+          await expireProposal(proposalId);
+          expired.push(proposalId);
+        }
 
-      return {
-        pending: nextPending,
-      };
-    });
+        return expired;
+      });
 
-    return {
-      approved: changes.approved.map((item) => item.id),
-      rejected: changes.rejected.map((item) => item.id),
-      expired: changes.expired.map((item) => item.id),
-      pending: updateState.pending,
-    };
-  }
+      return { expired: expiredIds };
+    }
   )
 );
 


thinking
**Assessing unused types in promote.ts**
exec
/bin/zsh -lc "rg -n \"ProposalState|StoredProposal|RedisLike|hset\\(|rpush\\(\" packages/system-bus/src/inngest/functions/promote.ts" in /private/tmp/agent-loop/loop-mlr8oxtg-b68bp4 succeeded in 53ms:
7:export type ProposalState = "checked" | "unchecked" | "deleted";
9:export type StoredProposal = {
18:type RedisLike = {
21:  hset(key: string, ...args: string[]): Promise<unknown>;
24:  rpush(key: string, ...values: string[]): Promise<unknown>;
35:function getRedisClient(): RedisLike {
file update:
diff --git a/packages/system-bus/src/inngest/functions/promote-integration.test.ts b/packages/system-bus/src/inngest/functions/promote-integration.test.ts
index ec552d8c5c0beb8271678d6aa7d39ccf1cdcb9e3..4fb7794ef87210aadf98f05d3d468912e127df10
--- a/packages/system-bus/src/inngest/functions/promote-integration.test.ts
+++ b/packages/system-bus/src/inngest/functions/promote-integration.test.ts
@@ -29,7 +29,6 @@
 
 let tempHome = "";
 let workspaceDir = "";
-let reviewPath = "";
 let memoryPath = "";
 
 function proposalKey(id: string): string {
@@ -189,7 +188,6 @@
   process.env.USERPROFILE = tempHome;
 
   workspaceDir = join(tempHome, ".joelclaw", "workspace");
-  reviewPath = join(workspaceDir, "REVIEW.md");
   memoryPath = join(workspaceDir, "MEMORY.md");
 
   mkdirSync(join(workspaceDir, "memory"), { recursive: true });
@@ -222,7 +220,7 @@
 });
 
 describe("MEM-22 promote integration acceptance test", () => {
-  test("runs end-to-end promotion workflow from REVIEW.md to MEMORY.md with no proposal loss", async () => {
+  test("runs end-to-end promotion workflow through event-driven handlers with no proposal loss", async () => {
     const approvedId = proposalIdDaysAgo(1, "101");
     const deletedId = proposalIdDaysAgo(1, "102");
     const expiredId = proposalIdDaysAgo(8, "103");
@@ -256,33 +254,32 @@
       capturedAt: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(),
     });
 
-    writeFileSync(
-      reviewPath,
-      [
-        "# REVIEW",
-        "",
-        `- [x] ${approvedId}: ${approvedText}`,
-        `- [ ] ${expiredId}: ${expiredText}`,
-        `- [ ] ${activePendingId}: ${activePendingText}`,
-        "",
-      ].join("\n")
-    );
-
-    const { result } = await executePromoteWithEvent({
-      name: "content/updated",
-      data: { path: reviewPath },
+    const { result: approvedResult } = await executePromoteWithEvent({
+      name: "memory/proposal.approved",
+      data: { proposalId: approvedId },
+    });
+    const { result: rejectedResult } = await executePromoteWithEvent({
+      name: "memory/proposal.rejected",
+      data: { proposalId: deletedId, reason: "deleted" },
+    });
+    const { result: expiredResult } = await executePromoteWithEvent({
+      name: "inngest/scheduled.timer",
+      data: { cron: "0 8 * * *" },
     });
 
     const memory = readFileSync(memoryPath, "utf8");
     const hardRules = getSectionBlock(memory, "Hard Rules");
     const log = readFileSync(todayLogPath(), "utf8");
-    const review = readFileSync(reviewPath, "utf8");
 
-    expect(result).toMatchObject({
+    expect(approvedResult).toMatchObject({
       approved: [approvedId],
+    });
+    expect(rejectedResult).toMatchObject({
       rejected: [deletedId],
+      reason: "deleted",
+    });
+    expect(expiredResult).toMatchObject({
       expired: [expiredId],
-      pending: [activePendingId],
     });
 
     expect(hardRules).toContain(`- (${proposalDateFromId(approvedId)})`);
@@ -296,11 +293,6 @@
     expect(redisState.hashes.has(proposalKey(approvedId))).toBe(false);
     expect(redisState.hashes.has(proposalKey(deletedId))).toBe(false);
     expect(redisState.hashes.has(proposalKey(expiredId))).toBe(false);
-
-    expect(review).toContain(activePendingId);
-    expect(review).not.toContain(approvedId);
-    expect(review).not.toContain(deletedId);
-    expect(review).not.toContain(expiredId);
 
     expect({
       approvedInMemory: hardRules.includes(`- (${proposalDateFromId(approvedId)})`),
diff --git a/packages/system-bus/src/inngest/functions/promote.ts b/packages/system-bus/src/inngest/functions/promote.ts
index 09730ecff690b4bfba745ef6f7b0a7469122608c..664e19e27ff0bfdc686be96c6935f256e17e25b6
--- a/packages/system-bus/src/inngest/functions/promote.ts
+++ b/packages/system-bus/src/inngest/functions/promote.ts
@@ -6,15 +6,6 @@
 
 export type ProposalState = "checked" | "unchecked" | "deleted";
 
-export type ParsedReviewProposal = {
-  id: string;
-  state: ProposalState;
-};
-
-export type ParsedReview = {
-  proposals: ParsedReviewProposal[];
-};
-
 export type StoredProposal = {
   id: string;
   status: string;
@@ -22,24 +13,6 @@
   date?: string;
   section?: string;
   change?: string;
-};
-
-export type ProposalStateSnapshot = {
-  pending: string[];
-  proposals: Record<string, StoredProposal>;
-};
-
-export type ProposalChange = {
-  id: string;
-  proposal?: StoredProposal;
-};
-
-export type ProposalDiff = {
-  approved: ProposalChange[];
-  rejected: ProposalChange[];
-  expired: ProposalChange[];
-  unchanged: ProposalChange[];
-  pending: string[];
 };
 
 type RedisLike = {
@@ -52,8 +25,6 @@
 };
 
 const REVIEW_PENDING_KEY = "memory:review:pending";
-const REVIEW_PATH_FILTER = "~/.joelclaw/workspace/REVIEW.md";
-const REVIEW_FILE_NAME = "REVIEW.md";
 const MEMORY_FILE_NAME = "MEMORY.md";
 const SEVEN_DAYS_MS = 7 * 24 * 60 * 60 * 1000;
 const REJECTED_PROPOSALS_HEADER = "### Rejected Proposals";
@@ -73,11 +44,6 @@
     redisClient.on("error", () => {});
   }
   return redisClient;
-}
-
-function getReviewPath(): string {
-  const home = process.env.HOME || process.env.USERPROFILE || "/Users/joel";
-  return join(home, ".joelclaw", "workspace", REVIEW_FILE_NAME);
 }
 
 function getMemoryPath(): string {
@@ -119,10 +85,6 @@
   if (date.getUTCMonth() !== monthIndex) return null;
   if (date.getUTCDate() !== day) return null;
   return date;
-}
-
-function escapeRegex(value: string): string {
-  return value.replace(/[.*+?^${}()|[\]\\]/gu, "\\$&");
 }
 
 function appendEntryToLogSection(markdown: string, header: string, entry: string): string {
@@ -158,20 +120,6 @@
   const existing = (await logFile.exists()) ? await logFile.text() : "";
   const next = appendEntryToLogSection(existing, header, entry);
   await Bun.write(logPath, next);
-}
-
-async function removeProposalFromReview(proposalId: string): Promise<void> {
-  const reviewPath = getReviewPath();
-  const reviewFile = Bun.file(reviewPath);
-  if (!(await reviewFile.exists())) return;
-
-  const markdown = await reviewFile.text();
-  const pattern = new RegExp(`^\\s*-\\s*\\[( |x|X|-)\\]\\s*${escapeRegex(proposalId)}\\b`, "u");
-  const nextLines = markdown.split(/\r?\n/u).filter((line) => !pattern.test(line));
-  const next = `${nextLines.join("\n").replace(/\n*$/u, "")}\n`;
-  if (next !== markdown) {
-    await Bun.write(reviewPath, next);
-  }
 }
 
 function isProposalOlderThanSevenDays(proposalId: string, now: Date = new Date()): boolean {
@@ -278,114 +226,8 @@
     .find((line) => line.length > 0);
 
   return formatted ?? proposedText;
-}
-
-function parseState(raw: string): ProposalState | null {
-  const value = raw.trim().toLowerCase();
-  if (value === "x") return "checked";
-  if (value === "-") return "deleted";
-  if (value === "") return "unchecked";
-  return null;
-}
-
-function parseCurrentState(currentState: unknown): Map<string, ProposalState> {
-  const map = new Map<string, ProposalState>();
-
-  if (!currentState || typeof currentState !== "object") return map;
-  const proposals = (currentState as { proposals?: unknown }).proposals;
-  if (!Array.isArray(proposals)) return map;
-
-  for (const proposal of proposals) {
-    if (!proposal || typeof proposal !== "object") continue;
-    const id = (proposal as { id?: unknown }).id;
-    const state = (proposal as { state?: unknown }).state;
-    if (typeof id !== "string") continue;
-    if (state === "checked" || state === "unchecked" || state === "deleted") {
-      map.set(id, state);
-    }
-  }
-
-  return map;
-}
-
-function isExpired(capturedAt: string | undefined, now: Date): boolean {
-  if (!capturedAt) return false;
-  const created = new Date(capturedAt);
-  if (Number.isNaN(created.getTime())) return false;
-  return now.getTime() - created.getTime() >= SEVEN_DAYS_MS;
 }
-
-function extractContentPath(eventData: unknown): string | null {
-  if (!eventData || typeof eventData !== "object") return null;
-  const rec = eventData as Record<string, unknown>;
 
-  const candidates = [rec.path, rec.filePath, rec.filepath];
-  for (const candidate of candidates) {
-    if (typeof candidate === "string" && candidate.length > 0) {
-      return candidate;
-    }
-  }
-
-  return null;
-}
-
-function createStableDiff(
-  approved: ProposalChange[],
-  rejected: ProposalChange[],
-  expired: ProposalChange[],
-  unchanged: ProposalChange[],
-  pending: string[]
-): ProposalDiff {
-  const data = {
-    approved,
-    rejected,
-    expired,
-    unchanged,
-    pending,
-  } satisfies ProposalDiff;
-
-  return new Proxy({} as ProposalDiff, {
-    get(_, property) {
-      if (property === "approved") return data.approved.map((item) => ({ ...item }));
-      if (property === "rejected") return data.rejected.map((item) => ({ ...item }));
-      if (property === "expired") return data.expired.map((item) => ({ ...item }));
-      if (property === "unchanged") return data.unchanged.map((item) => ({ ...item }));
-      if (property === "pending") return [...data.pending];
-      return undefined;
-    },
-    set() {
-      return true;
-    },
-    has(_, property) {
-      return (
-        property === "approved" ||
-        property === "rejected" ||
-        property === "expired" ||
-        property === "unchanged" ||
-        property === "pending"
-      );
-    },
-    ownKeys() {
-      return ["approved", "rejected", "expired", "unchanged", "pending"];
-    },
-    getOwnPropertyDescriptor(_, property) {
-      if (
-        property === "approved" ||
-        property === "rejected" ||
-        property === "expired" ||
-        property === "unchanged" ||
-        property === "pending"
-      ) {
-        return {
-          enumerable: true,
-          configurable: true,
-        };
-      }
-      return undefined;
-    },
-  });
-}
-
 function stabilizeFunctionOpts<T extends { opts?: Record<string, unknown> }>(fn: T): T {
   const original = fn.opts;
   if (!original) return fn;
@@ -413,91 +255,6 @@
       return Reflect.set(target, property, value, receiver);
     },
   });
-}
-
-export function parseReviewMd(markdown: string): ParsedReview {
-  const proposals: ParsedReviewProposal[] = [];
-
-  const lines = markdown.split(/\r?\n/u);
-  for (const line of lines) {
-    const match = /^\s*-\s*\[( |x|X|-)\]\s*(p-\d{8}-\d{3,})\b/u.exec(line);
-    if (!match?.[1] || !match[2]) continue;
-
-    const state = parseState(match[1]);
-    if (!state) continue;
-
-    proposals.push({
-      id: match[2],
-      state,
-    });
-  }
-
-  return { proposals };
-}
-
-export async function loadProposalState(redis: Pick<RedisLike, "lrange" | "hgetall">): Promise<ProposalStateSnapshot> {
-  const pending = await redis.lrange(REVIEW_PENDING_KEY, 0, -1);
-  const proposals: Record<string, StoredProposal> = {};
-
-  for (const id of pending) {
-    const stored = await redis.hgetall(proposalKey(id));
-    proposals[id] = {
-      id,
-      status: stored.status ?? "pending",
-      capturedAt: stored.capturedAt,
-      date: stored.date,
-      section: stored.section,
-      change: stored.change,
-    };
-  }
-
-  return { pending, proposals };
-}
-
-export function detectChanges(
-  currentState: unknown,
-  previousState: ProposalStateSnapshot,
-  now: Date = new Date()
-): ProposalDiff {
-  const current = parseCurrentState(currentState);
-  const approved: ProposalChange[] = [];
-  const rejected: ProposalChange[] = [];
-  const expired: ProposalChange[] = [];
-  const unchanged: ProposalChange[] = [];
-  const pending: string[] = [];
-
-  for (const id of previousState.pending) {
-    const proposal = previousState.proposals[id] ?? { id, status: "pending" };
-    const currentProposalState = current.get(id);
-
-    if (currentProposalState === "checked") {
-      approved.push({ id, proposal });
-      continue;
-    }
-
-    if (currentProposalState === "deleted" || currentProposalState === undefined) {
-      rejected.push({ id, proposal });
-      continue;
-    }
-
-    if (isExpired(proposal.capturedAt, now)) {
-      expired.push({ id, proposal });
-      continue;
-    }
-
-    unchanged.push({ id, proposal });
-    pending.push(id);
-  }
-
-  for (const [id, state] of current.entries()) {
-    if (previousState.pending.includes(id)) continue;
-    if (state === "unchecked") {
-      unchanged.push({ id, proposal: previousState.proposals[id] ?? { id, status: "pending" } });
-      pending.push(id);
-    }
-  }
-
-  return createStableDiff(approved, rejected, expired, unchanged, pending);
 }
 
 export async function promoteToMemory(proposalId: string): Promise<void> {
@@ -533,10 +290,9 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
-export async function archiveProposal(proposalId: string, reason: "deleted" | "marked-rejected"): Promise<void> {
+export async function archiveProposal(proposalId: string, reason: string): Promise<void> {
   const redis = getRedisClient();
   const key = proposalKey(proposalId);
   const proposal = await redis.hgetall(key);
@@ -549,7 +305,6 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
 export async function expireProposal(proposalId: string): Promise<void> {
@@ -567,115 +322,62 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
 const promoteFunction = stabilizeFunctionOpts(
   inngest.createFunction(
-  {
-    id: "memory/review-promote",
-    name: "Promote Review Decisions",
-  },
-  [
     {
-      event: "content/updated",
-      if: `event.data.path == \"${REVIEW_PATH_FILTER}\" || event.data.path.endsWith(\"/${REVIEW_FILE_NAME}\")`,
+      id: "memory/review-promote",
+      name: "Promote Review Decisions",
     },
-    { cron: "0 8 * * *" },
-  ],
-  async ({ event, step }) => {
-    const shouldSkip = await step.run("filter-review-events", async () => {
-      if (event.name !== "content/updated") return false;
-      const updatedPath = extractContentPath(event.data);
-      if (!updatedPath) return false;
-      return !updatedPath.toLowerCase().endsWith(`/${REVIEW_FILE_NAME.toLowerCase()}`);
-    });
-
-    if (shouldSkip) {
-      return {
-        skipped: true,
-        reason: "content/updated path does not target REVIEW.md",
-      };
-    }
-
-    const parsed = await step.run("parse-review", async () => {
-      const reviewFile = Bun.file(getReviewPath());
-      if (!(await reviewFile.exists())) {
-        return { proposals: [] } as ParsedReview;
-      }
-
-      const markdown = await reviewFile.text();
-      return parseReviewMd(markdown);
-    });
-
-    const previous = await step.run("load-state", async () => {
-      const redis = getRedisClient();
-      return loadProposalState(redis);
-    });
+    [{ event: "memory/proposal.approved" }, { event: "memory/proposal.rejected" }, { cron: "0 8 * * *" }],
+    async ({ event, step }) => {
+      if (event.name === "memory/proposal.approved") {
+        const proposalId = await step.run("resolve-approved-proposal-id", async () => {
+          const id = (event.data as { proposalId?: unknown }).proposalId;
+          if (typeof id !== "string" || id.trim().length === 0) {
+            throw new Error("memory/proposal.approved requires event.data.proposalId");
+          }
+          return id;
+        });
 
-    const changes = await step.run("detect-changes", async () => detectChanges(parsed, previous));
-
-    await step.run("route", async () => {
-      const parsedById = new Map(parsed.proposals.map((proposal) => [proposal.id, proposal]));
-
-      for (const change of changes.approved) {
-        await promoteToMemory(change.id);
+        await step.run("promote-approved-proposal", async () => promoteToMemory(proposalId));
+        return { approved: [proposalId] };
       }
 
-      for (const change of changes.rejected) {
-        const reason = parsedById.get(change.id)?.state === "deleted" ? "marked-rejected" : "deleted";
-        await archiveProposal(change.id, reason);
-      }
+      if (event.name === "memory/proposal.rejected") {
+        const payload = await step.run("resolve-rejected-payload", async () => {
+          const id = (event.data as { proposalId?: unknown }).proposalId;
+          const reason = (event.data as { reason?: unknown }).reason;
+          if (typeof id !== "string" || id.trim().length === 0) {
+            throw new Error("memory/proposal.rejected requires event.data.proposalId");
+          }
+          if (typeof reason !== "string" || reason.trim().length === 0) {
+            throw new Error("memory/proposal.rejected requires event.data.reason");
+          }
+          return { proposalId: id, reason };
+        });
 
-      for (const change of changes.expired) {
-        await expireProposal(change.id);
+        await step.run("archive-rejected-proposal", async () => archiveProposal(payload.proposalId, payload.reason));
+        return { rejected: [payload.proposalId], reason: payload.reason };
       }
-    });
-
-    const updateState = await step.run("update-state", async () => {
-      const redis = getRedisClient();
-      const nextPending = [...new Set(changes.pending)];
 
-      await redis.del(REVIEW_PENDING_KEY);
-      if (nextPending.length > 0) {
-        await redis.rpush(REVIEW_PENDING_KEY, ...nextPending);
-      }
+      const expiredIds = await step.run("expire-stale-proposals", async () => {
+        const redis = getRedisClient();
+        const pending = await redis.lrange(REVIEW_PENDING_KEY, 0, -1);
+        const expired: string[] = [];
 
-      const parsedById = new Map(parsed.proposals.map((proposal) => [proposal.id, proposal]));
-      for (const id of nextPending) {
-        const existing = previous.proposals[id];
-        const parsedProposal = parsedById.get(id);
-        await redis.hset(
-          proposalKey(id),
-          "id",
-          id,
-          "status",
-          "pending",
-          "state",
-          parsedProposal?.state ?? "unchecked",
-          "capturedAt",
-          existing?.capturedAt ?? new Date().toISOString(),
-          "date",
-          existing?.date ?? new Date().toISOString().slice(0, 10),
-          "section",
-          existing?.section ?? "",
-          "change",
-          existing?.change ?? ""
-        );
-      }
+        for (const proposalId of pending) {
+          if (!isProposalOlderThanSevenDays(proposalId)) continue;
+          await expireProposal(proposalId);
+          expired.push(proposalId);
+        }
 
-      return {
-        pending: nextPending,
-      };
-    });
+        return expired;
+      });
 
-    return {
-      approved: changes.approved.map((item) => item.id),
-      rejected: changes.rejected.map((item) => item.id),
-      expired: changes.expired.map((item) => item.id),
-      pending: updateState.pending,
-    };
-  }
+      return { expired: expiredIds };
+    }
   )
 );
 


thinking
**Assessing unused exported types**
exec
/bin/zsh -lc "rg -n \"ProposalState|StoredProposal\" packages/system-bus/src | sed -n '1,120p'" in /private/tmp/agent-loop/loop-mlr8oxtg-b68bp4 succeeded in 53ms:
packages/system-bus/src/inngest/functions/promote.ts:7:export type ProposalState = "checked" | "unchecked" | "deleted";
packages/system-bus/src/inngest/functions/promote.ts:9:export type StoredProposal = {
file update:
diff --git a/packages/system-bus/src/inngest/functions/promote-integration.test.ts b/packages/system-bus/src/inngest/functions/promote-integration.test.ts
index ec552d8c5c0beb8271678d6aa7d39ccf1cdcb9e3..4fb7794ef87210aadf98f05d3d468912e127df10
--- a/packages/system-bus/src/inngest/functions/promote-integration.test.ts
+++ b/packages/system-bus/src/inngest/functions/promote-integration.test.ts
@@ -29,7 +29,6 @@
 
 let tempHome = "";
 let workspaceDir = "";
-let reviewPath = "";
 let memoryPath = "";
 
 function proposalKey(id: string): string {
@@ -189,7 +188,6 @@
   process.env.USERPROFILE = tempHome;
 
   workspaceDir = join(tempHome, ".joelclaw", "workspace");
-  reviewPath = join(workspaceDir, "REVIEW.md");
   memoryPath = join(workspaceDir, "MEMORY.md");
 
   mkdirSync(join(workspaceDir, "memory"), { recursive: true });
@@ -222,7 +220,7 @@
 });
 
 describe("MEM-22 promote integration acceptance test", () => {
-  test("runs end-to-end promotion workflow from REVIEW.md to MEMORY.md with no proposal loss", async () => {
+  test("runs end-to-end promotion workflow through event-driven handlers with no proposal loss", async () => {
     const approvedId = proposalIdDaysAgo(1, "101");
     const deletedId = proposalIdDaysAgo(1, "102");
     const expiredId = proposalIdDaysAgo(8, "103");
@@ -256,33 +254,32 @@
       capturedAt: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(),
     });
 
-    writeFileSync(
-      reviewPath,
-      [
-        "# REVIEW",
-        "",
-        `- [x] ${approvedId}: ${approvedText}`,
-        `- [ ] ${expiredId}: ${expiredText}`,
-        `- [ ] ${activePendingId}: ${activePendingText}`,
-        "",
-      ].join("\n")
-    );
-
-    const { result } = await executePromoteWithEvent({
-      name: "content/updated",
-      data: { path: reviewPath },
+    const { result: approvedResult } = await executePromoteWithEvent({
+      name: "memory/proposal.approved",
+      data: { proposalId: approvedId },
+    });
+    const { result: rejectedResult } = await executePromoteWithEvent({
+      name: "memory/proposal.rejected",
+      data: { proposalId: deletedId, reason: "deleted" },
+    });
+    const { result: expiredResult } = await executePromoteWithEvent({
+      name: "inngest/scheduled.timer",
+      data: { cron: "0 8 * * *" },
     });
 
     const memory = readFileSync(memoryPath, "utf8");
     const hardRules = getSectionBlock(memory, "Hard Rules");
     const log = readFileSync(todayLogPath(), "utf8");
-    const review = readFileSync(reviewPath, "utf8");
 
-    expect(result).toMatchObject({
+    expect(approvedResult).toMatchObject({
       approved: [approvedId],
+    });
+    expect(rejectedResult).toMatchObject({
       rejected: [deletedId],
+      reason: "deleted",
+    });
+    expect(expiredResult).toMatchObject({
       expired: [expiredId],
-      pending: [activePendingId],
     });
 
     expect(hardRules).toContain(`- (${proposalDateFromId(approvedId)})`);
@@ -296,11 +293,6 @@
     expect(redisState.hashes.has(proposalKey(approvedId))).toBe(false);
     expect(redisState.hashes.has(proposalKey(deletedId))).toBe(false);
     expect(redisState.hashes.has(proposalKey(expiredId))).toBe(false);
-
-    expect(review).toContain(activePendingId);
-    expect(review).not.toContain(approvedId);
-    expect(review).not.toContain(deletedId);
-    expect(review).not.toContain(expiredId);
 
     expect({
       approvedInMemory: hardRules.includes(`- (${proposalDateFromId(approvedId)})`),
diff --git a/packages/system-bus/src/inngest/functions/promote.ts b/packages/system-bus/src/inngest/functions/promote.ts
index 09730ecff690b4bfba745ef6f7b0a7469122608c..664e19e27ff0bfdc686be96c6935f256e17e25b6
--- a/packages/system-bus/src/inngest/functions/promote.ts
+++ b/packages/system-bus/src/inngest/functions/promote.ts
@@ -6,15 +6,6 @@
 
 export type ProposalState = "checked" | "unchecked" | "deleted";
 
-export type ParsedReviewProposal = {
-  id: string;
-  state: ProposalState;
-};
-
-export type ParsedReview = {
-  proposals: ParsedReviewProposal[];
-};
-
 export type StoredProposal = {
   id: string;
   status: string;
@@ -22,24 +13,6 @@
   date?: string;
   section?: string;
   change?: string;
-};
-
-export type ProposalStateSnapshot = {
-  pending: string[];
-  proposals: Record<string, StoredProposal>;
-};
-
-export type ProposalChange = {
-  id: string;
-  proposal?: StoredProposal;
-};
-
-export type ProposalDiff = {
-  approved: ProposalChange[];
-  rejected: ProposalChange[];
-  expired: ProposalChange[];
-  unchanged: ProposalChange[];
-  pending: string[];
 };
 
 type RedisLike = {
@@ -52,8 +25,6 @@
 };
 
 const REVIEW_PENDING_KEY = "memory:review:pending";
-const REVIEW_PATH_FILTER = "~/.joelclaw/workspace/REVIEW.md";
-const REVIEW_FILE_NAME = "REVIEW.md";
 const MEMORY_FILE_NAME = "MEMORY.md";
 const SEVEN_DAYS_MS = 7 * 24 * 60 * 60 * 1000;
 const REJECTED_PROPOSALS_HEADER = "### Rejected Proposals";
@@ -73,11 +44,6 @@
     redisClient.on("error", () => {});
   }
   return redisClient;
-}
-
-function getReviewPath(): string {
-  const home = process.env.HOME || process.env.USERPROFILE || "/Users/joel";
-  return join(home, ".joelclaw", "workspace", REVIEW_FILE_NAME);
 }
 
 function getMemoryPath(): string {
@@ -119,10 +85,6 @@
   if (date.getUTCMonth() !== monthIndex) return null;
   if (date.getUTCDate() !== day) return null;
   return date;
-}
-
-function escapeRegex(value: string): string {
-  return value.replace(/[.*+?^${}()|[\]\\]/gu, "\\$&");
 }
 
 function appendEntryToLogSection(markdown: string, header: string, entry: string): string {
@@ -158,20 +120,6 @@
   const existing = (await logFile.exists()) ? await logFile.text() : "";
   const next = appendEntryToLogSection(existing, header, entry);
   await Bun.write(logPath, next);
-}
-
-async function removeProposalFromReview(proposalId: string): Promise<void> {
-  const reviewPath = getReviewPath();
-  const reviewFile = Bun.file(reviewPath);
-  if (!(await reviewFile.exists())) return;
-
-  const markdown = await reviewFile.text();
-  const pattern = new RegExp(`^\\s*-\\s*\\[( |x|X|-)\\]\\s*${escapeRegex(proposalId)}\\b`, "u");
-  const nextLines = markdown.split(/\r?\n/u).filter((line) => !pattern.test(line));
-  const next = `${nextLines.join("\n").replace(/\n*$/u, "")}\n`;
-  if (next !== markdown) {
-    await Bun.write(reviewPath, next);
-  }
 }
 
 function isProposalOlderThanSevenDays(proposalId: string, now: Date = new Date()): boolean {
@@ -278,114 +226,8 @@
     .find((line) => line.length > 0);
 
   return formatted ?? proposedText;
-}
-
-function parseState(raw: string): ProposalState | null {
-  const value = raw.trim().toLowerCase();
-  if (value === "x") return "checked";
-  if (value === "-") return "deleted";
-  if (value === "") return "unchecked";
-  return null;
-}
-
-function parseCurrentState(currentState: unknown): Map<string, ProposalState> {
-  const map = new Map<string, ProposalState>();
-
-  if (!currentState || typeof currentState !== "object") return map;
-  const proposals = (currentState as { proposals?: unknown }).proposals;
-  if (!Array.isArray(proposals)) return map;
-
-  for (const proposal of proposals) {
-    if (!proposal || typeof proposal !== "object") continue;
-    const id = (proposal as { id?: unknown }).id;
-    const state = (proposal as { state?: unknown }).state;
-    if (typeof id !== "string") continue;
-    if (state === "checked" || state === "unchecked" || state === "deleted") {
-      map.set(id, state);
-    }
-  }
-
-  return map;
-}
-
-function isExpired(capturedAt: string | undefined, now: Date): boolean {
-  if (!capturedAt) return false;
-  const created = new Date(capturedAt);
-  if (Number.isNaN(created.getTime())) return false;
-  return now.getTime() - created.getTime() >= SEVEN_DAYS_MS;
 }
-
-function extractContentPath(eventData: unknown): string | null {
-  if (!eventData || typeof eventData !== "object") return null;
-  const rec = eventData as Record<string, unknown>;
 
-  const candidates = [rec.path, rec.filePath, rec.filepath];
-  for (const candidate of candidates) {
-    if (typeof candidate === "string" && candidate.length > 0) {
-      return candidate;
-    }
-  }
-
-  return null;
-}
-
-function createStableDiff(
-  approved: ProposalChange[],
-  rejected: ProposalChange[],
-  expired: ProposalChange[],
-  unchanged: ProposalChange[],
-  pending: string[]
-): ProposalDiff {
-  const data = {
-    approved,
-    rejected,
-    expired,
-    unchanged,
-    pending,
-  } satisfies ProposalDiff;
-
-  return new Proxy({} as ProposalDiff, {
-    get(_, property) {
-      if (property === "approved") return data.approved.map((item) => ({ ...item }));
-      if (property === "rejected") return data.rejected.map((item) => ({ ...item }));
-      if (property === "expired") return data.expired.map((item) => ({ ...item }));
-      if (property === "unchanged") return data.unchanged.map((item) => ({ ...item }));
-      if (property === "pending") return [...data.pending];
-      return undefined;
-    },
-    set() {
-      return true;
-    },
-    has(_, property) {
-      return (
-        property === "approved" ||
-        property === "rejected" ||
-        property === "expired" ||
-        property === "unchanged" ||
-        property === "pending"
-      );
-    },
-    ownKeys() {
-      return ["approved", "rejected", "expired", "unchanged", "pending"];
-    },
-    getOwnPropertyDescriptor(_, property) {
-      if (
-        property === "approved" ||
-        property === "rejected" ||
-        property === "expired" ||
-        property === "unchanged" ||
-        property === "pending"
-      ) {
-        return {
-          enumerable: true,
-          configurable: true,
-        };
-      }
-      return undefined;
-    },
-  });
-}
-
 function stabilizeFunctionOpts<T extends { opts?: Record<string, unknown> }>(fn: T): T {
   const original = fn.opts;
   if (!original) return fn;
@@ -413,91 +255,6 @@
       return Reflect.set(target, property, value, receiver);
     },
   });
-}
-
-export function parseReviewMd(markdown: string): ParsedReview {
-  const proposals: ParsedReviewProposal[] = [];
-
-  const lines = markdown.split(/\r?\n/u);
-  for (const line of lines) {
-    const match = /^\s*-\s*\[( |x|X|-)\]\s*(p-\d{8}-\d{3,})\b/u.exec(line);
-    if (!match?.[1] || !match[2]) continue;
-
-    const state = parseState(match[1]);
-    if (!state) continue;
-
-    proposals.push({
-      id: match[2],
-      state,
-    });
-  }
-
-  return { proposals };
-}
-
-export async function loadProposalState(redis: Pick<RedisLike, "lrange" | "hgetall">): Promise<ProposalStateSnapshot> {
-  const pending = await redis.lrange(REVIEW_PENDING_KEY, 0, -1);
-  const proposals: Record<string, StoredProposal> = {};
-
-  for (const id of pending) {
-    const stored = await redis.hgetall(proposalKey(id));
-    proposals[id] = {
-      id,
-      status: stored.status ?? "pending",
-      capturedAt: stored.capturedAt,
-      date: stored.date,
-      section: stored.section,
-      change: stored.change,
-    };
-  }
-
-  return { pending, proposals };
-}
-
-export function detectChanges(
-  currentState: unknown,
-  previousState: ProposalStateSnapshot,
-  now: Date = new Date()
-): ProposalDiff {
-  const current = parseCurrentState(currentState);
-  const approved: ProposalChange[] = [];
-  const rejected: ProposalChange[] = [];
-  const expired: ProposalChange[] = [];
-  const unchanged: ProposalChange[] = [];
-  const pending: string[] = [];
-
-  for (const id of previousState.pending) {
-    const proposal = previousState.proposals[id] ?? { id, status: "pending" };
-    const currentProposalState = current.get(id);
-
-    if (currentProposalState === "checked") {
-      approved.push({ id, proposal });
-      continue;
-    }
-
-    if (currentProposalState === "deleted" || currentProposalState === undefined) {
-      rejected.push({ id, proposal });
-      continue;
-    }
-
-    if (isExpired(proposal.capturedAt, now)) {
-      expired.push({ id, proposal });
-      continue;
-    }
-
-    unchanged.push({ id, proposal });
-    pending.push(id);
-  }
-
-  for (const [id, state] of current.entries()) {
-    if (previousState.pending.includes(id)) continue;
-    if (state === "unchecked") {
-      unchanged.push({ id, proposal: previousState.proposals[id] ?? { id, status: "pending" } });
-      pending.push(id);
-    }
-  }
-
-  return createStableDiff(approved, rejected, expired, unchanged, pending);
 }
 
 export async function promoteToMemory(proposalId: string): Promise<void> {
@@ -533,10 +290,9 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
-export async function archiveProposal(proposalId: string, reason: "deleted" | "marked-rejected"): Promise<void> {
+export async function archiveProposal(proposalId: string, reason: string): Promise<void> {
   const redis = getRedisClient();
   const key = proposalKey(proposalId);
   const proposal = await redis.hgetall(key);
@@ -549,7 +305,6 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
 export async function expireProposal(proposalId: string): Promise<void> {
@@ -567,115 +322,62 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
 const promoteFunction = stabilizeFunctionOpts(
   inngest.createFunction(
-  {
-    id: "memory/review-promote",
-    name: "Promote Review Decisions",
-  },
-  [
     {
-      event: "content/updated",
-      if: `event.data.path == \"${REVIEW_PATH_FILTER}\" || event.data.path.endsWith(\"/${REVIEW_FILE_NAME}\")`,
+      id: "memory/review-promote",
+      name: "Promote Review Decisions",
     },
-    { cron: "0 8 * * *" },
-  ],
-  async ({ event, step }) => {
-    const shouldSkip = await step.run("filter-review-events", async () => {
-      if (event.name !== "content/updated") return false;
-      const updatedPath = extractContentPath(event.data);
-      if (!updatedPath) return false;
-      return !updatedPath.toLowerCase().endsWith(`/${REVIEW_FILE_NAME.toLowerCase()}`);
-    });
-
-    if (shouldSkip) {
-      return {
-        skipped: true,
-        reason: "content/updated path does not target REVIEW.md",
-      };
-    }
-
-    const parsed = await step.run("parse-review", async () => {
-      const reviewFile = Bun.file(getReviewPath());
-      if (!(await reviewFile.exists())) {
-        return { proposals: [] } as ParsedReview;
-      }
-
-      const markdown = await reviewFile.text();
-      return parseReviewMd(markdown);
-    });
-
-    const previous = await step.run("load-state", async () => {
-      const redis = getRedisClient();
-      return loadProposalState(redis);
-    });
+    [{ event: "memory/proposal.approved" }, { event: "memory/proposal.rejected" }, { cron: "0 8 * * *" }],
+    async ({ event, step }) => {
+      if (event.name === "memory/proposal.approved") {
+        const proposalId = await step.run("resolve-approved-proposal-id", async () => {
+          const id = (event.data as { proposalId?: unknown }).proposalId;
+          if (typeof id !== "string" || id.trim().length === 0) {
+            throw new Error("memory/proposal.approved requires event.data.proposalId");
+          }
+          return id;
+        });
 
-    const changes = await step.run("detect-changes", async () => detectChanges(parsed, previous));
-
-    await step.run("route", async () => {
-      const parsedById = new Map(parsed.proposals.map((proposal) => [proposal.id, proposal]));
-
-      for (const change of changes.approved) {
-        await promoteToMemory(change.id);
+        await step.run("promote-approved-proposal", async () => promoteToMemory(proposalId));
+        return { approved: [proposalId] };
       }
 
-      for (const change of changes.rejected) {
-        const reason = parsedById.get(change.id)?.state === "deleted" ? "marked-rejected" : "deleted";
-        await archiveProposal(change.id, reason);
-      }
+      if (event.name === "memory/proposal.rejected") {
+        const payload = await step.run("resolve-rejected-payload", async () => {
+          const id = (event.data as { proposalId?: unknown }).proposalId;
+          const reason = (event.data as { reason?: unknown }).reason;
+          if (typeof id !== "string" || id.trim().length === 0) {
+            throw new Error("memory/proposal.rejected requires event.data.proposalId");
+          }
+          if (typeof reason !== "string" || reason.trim().length === 0) {
+            throw new Error("memory/proposal.rejected requires event.data.reason");
+          }
+          return { proposalId: id, reason };
+        });
 
-      for (const change of changes.expired) {
-        await expireProposal(change.id);
+        await step.run("archive-rejected-proposal", async () => archiveProposal(payload.proposalId, payload.reason));
+        return { rejected: [payload.proposalId], reason: payload.reason };
       }
-    });
-
-    const updateState = await step.run("update-state", async () => {
-      const redis = getRedisClient();
-      const nextPending = [...new Set(changes.pending)];
 
-      await redis.del(REVIEW_PENDING_KEY);
-      if (nextPending.length > 0) {
-        await redis.rpush(REVIEW_PENDING_KEY, ...nextPending);
-      }
+      const expiredIds = await step.run("expire-stale-proposals", async () => {
+        const redis = getRedisClient();
+        const pending = await redis.lrange(REVIEW_PENDING_KEY, 0, -1);
+        const expired: string[] = [];
 
-      const parsedById = new Map(parsed.proposals.map((proposal) => [proposal.id, proposal]));
-      for (const id of nextPending) {
-        const existing = previous.proposals[id];
-        const parsedProposal = parsedById.get(id);
-        await redis.hset(
-          proposalKey(id),
-          "id",
-          id,
-          "status",
-          "pending",
-          "state",
-          parsedProposal?.state ?? "unchecked",
-          "capturedAt",
-          existing?.capturedAt ?? new Date().toISOString(),
-          "date",
-          existing?.date ?? new Date().toISOString().slice(0, 10),
-          "section",
-          existing?.section ?? "",
-          "change",
-          existing?.change ?? ""
-        );
-      }
+        for (const proposalId of pending) {
+          if (!isProposalOlderThanSevenDays(proposalId)) continue;
+          await expireProposal(proposalId);
+          expired.push(proposalId);
+        }
 
-      return {
-        pending: nextPending,
-      };
-    });
+        return expired;
+      });
 
-    return {
-      approved: changes.approved.map((item) => item.id),
-      rejected: changes.rejected.map((item) => item.id),
-      expired: changes.expired.map((item) => item.id),
-      pending: updateState.pending,
-    };
-  }
+      return { expired: expiredIds };
+    }
   )
 );
 


thinking
**Simplifying Redis interface and exports**
codex
I’m doing one cleanup pass in `promote.ts` to remove now-unused type declarations left behind by the old flow, keeping the file focused on the new event handlers.
file update
M /private/tmp/agent-loop/loop-mlr8oxtg-b68bp4/packages/system-bus/src/inngest/functions/promote.ts
@@ -6,13 +6,2 @@
 
-export type ProposalState = "checked" | "unchecked" | "deleted";
-
-export type StoredProposal = {
-  id: string;
-  status: string;
-  capturedAt?: string;
-  date?: string;
-  section?: string;
-  change?: string;
-};
-
 type RedisLike = {
@@ -20,6 +9,4 @@
   hgetall(key: string): Promise<Record<string, string>>;
-  hset(key: string, ...args: string[]): Promise<unknown>;
   lrem(key: string, count: number, value: string): Promise<unknown>;
   del(key: string): Promise<unknown>;
-  rpush(key: string, ...values: string[]): Promise<unknown>;
 };
apply_patch(auto_approved=true) exited 0 in 60ms:
Success. Updated the following files:
M packages/system-bus/src/inngest/functions/promote.ts
file update:
diff --git a/packages/system-bus/src/inngest/functions/promote-integration.test.ts b/packages/system-bus/src/inngest/functions/promote-integration.test.ts
index ec552d8c5c0beb8271678d6aa7d39ccf1cdcb9e3..4fb7794ef87210aadf98f05d3d468912e127df10
--- a/packages/system-bus/src/inngest/functions/promote-integration.test.ts
+++ b/packages/system-bus/src/inngest/functions/promote-integration.test.ts
@@ -29,7 +29,6 @@
 
 let tempHome = "";
 let workspaceDir = "";
-let reviewPath = "";
 let memoryPath = "";
 
 function proposalKey(id: string): string {
@@ -189,7 +188,6 @@
   process.env.USERPROFILE = tempHome;
 
   workspaceDir = join(tempHome, ".joelclaw", "workspace");
-  reviewPath = join(workspaceDir, "REVIEW.md");
   memoryPath = join(workspaceDir, "MEMORY.md");
 
   mkdirSync(join(workspaceDir, "memory"), { recursive: true });
@@ -222,7 +220,7 @@
 });
 
 describe("MEM-22 promote integration acceptance test", () => {
-  test("runs end-to-end promotion workflow from REVIEW.md to MEMORY.md with no proposal loss", async () => {
+  test("runs end-to-end promotion workflow through event-driven handlers with no proposal loss", async () => {
     const approvedId = proposalIdDaysAgo(1, "101");
     const deletedId = proposalIdDaysAgo(1, "102");
     const expiredId = proposalIdDaysAgo(8, "103");
@@ -256,33 +254,32 @@
       capturedAt: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(),
     });
 
-    writeFileSync(
-      reviewPath,
-      [
-        "# REVIEW",
-        "",
-        `- [x] ${approvedId}: ${approvedText}`,
-        `- [ ] ${expiredId}: ${expiredText}`,
-        `- [ ] ${activePendingId}: ${activePendingText}`,
-        "",
-      ].join("\n")
-    );
-
-    const { result } = await executePromoteWithEvent({
-      name: "content/updated",
-      data: { path: reviewPath },
+    const { result: approvedResult } = await executePromoteWithEvent({
+      name: "memory/proposal.approved",
+      data: { proposalId: approvedId },
+    });
+    const { result: rejectedResult } = await executePromoteWithEvent({
+      name: "memory/proposal.rejected",
+      data: { proposalId: deletedId, reason: "deleted" },
+    });
+    const { result: expiredResult } = await executePromoteWithEvent({
+      name: "inngest/scheduled.timer",
+      data: { cron: "0 8 * * *" },
     });
 
     const memory = readFileSync(memoryPath, "utf8");
     const hardRules = getSectionBlock(memory, "Hard Rules");
     const log = readFileSync(todayLogPath(), "utf8");
-    const review = readFileSync(reviewPath, "utf8");
 
-    expect(result).toMatchObject({
+    expect(approvedResult).toMatchObject({
       approved: [approvedId],
+    });
+    expect(rejectedResult).toMatchObject({
       rejected: [deletedId],
+      reason: "deleted",
+    });
+    expect(expiredResult).toMatchObject({
       expired: [expiredId],
-      pending: [activePendingId],
     });
 
     expect(hardRules).toContain(`- (${proposalDateFromId(approvedId)})`);
@@ -296,11 +293,6 @@
     expect(redisState.hashes.has(proposalKey(approvedId))).toBe(false);
     expect(redisState.hashes.has(proposalKey(deletedId))).toBe(false);
     expect(redisState.hashes.has(proposalKey(expiredId))).toBe(false);
-
-    expect(review).toContain(activePendingId);
-    expect(review).not.toContain(approvedId);
-    expect(review).not.toContain(deletedId);
-    expect(review).not.toContain(expiredId);
 
     expect({
       approvedInMemory: hardRules.includes(`- (${proposalDateFromId(approvedId)})`),
diff --git a/packages/system-bus/src/inngest/functions/promote.ts b/packages/system-bus/src/inngest/functions/promote.ts
index 09730ecff690b4bfba745ef6f7b0a7469122608c..4fa05b25f8a9810e0b2052835bcfe45293b19d41
--- a/packages/system-bus/src/inngest/functions/promote.ts
+++ b/packages/system-bus/src/inngest/functions/promote.ts
@@ -4,56 +4,14 @@
 import { inngest } from "../client";
 import { PROMOTE_SYSTEM_PROMPT, PROMOTE_USER_PROMPT } from "./promote-prompt";
 
-export type ProposalState = "checked" | "unchecked" | "deleted";
-
-export type ParsedReviewProposal = {
-  id: string;
-  state: ProposalState;
-};
-
-export type ParsedReview = {
-  proposals: ParsedReviewProposal[];
-};
-
-export type StoredProposal = {
-  id: string;
-  status: string;
-  capturedAt?: string;
-  date?: string;
-  section?: string;
-  change?: string;
-};
-
-export type ProposalStateSnapshot = {
-  pending: string[];
-  proposals: Record<string, StoredProposal>;
-};
-
-export type ProposalChange = {
-  id: string;
-  proposal?: StoredProposal;
-};
-
-export type ProposalDiff = {
-  approved: ProposalChange[];
-  rejected: ProposalChange[];
-  expired: ProposalChange[];
-  unchanged: ProposalChange[];
-  pending: string[];
-};
-
 type RedisLike = {
   lrange(key: string, start: number, stop: number): Promise<string[]>;
   hgetall(key: string): Promise<Record<string, string>>;
-  hset(key: string, ...args: string[]): Promise<unknown>;
   lrem(key: string, count: number, value: string): Promise<unknown>;
   del(key: string): Promise<unknown>;
-  rpush(key: string, ...values: string[]): Promise<unknown>;
 };
 
 const REVIEW_PENDING_KEY = "memory:review:pending";
-const REVIEW_PATH_FILTER = "~/.joelclaw/workspace/REVIEW.md";
-const REVIEW_FILE_NAME = "REVIEW.md";
 const MEMORY_FILE_NAME = "MEMORY.md";
 const SEVEN_DAYS_MS = 7 * 24 * 60 * 60 * 1000;
 const REJECTED_PROPOSALS_HEADER = "### Rejected Proposals";
@@ -73,11 +31,6 @@
     redisClient.on("error", () => {});
   }
   return redisClient;
-}
-
-function getReviewPath(): string {
-  const home = process.env.HOME || process.env.USERPROFILE || "/Users/joel";
-  return join(home, ".joelclaw", "workspace", REVIEW_FILE_NAME);
 }
 
 function getMemoryPath(): string {
@@ -121,10 +74,6 @@
   return date;
 }
 
-function escapeRegex(value: string): string {
-  return value.replace(/[.*+?^${}()|[\]\\]/gu, "\\$&");
-}
-
 function appendEntryToLogSection(markdown: string, header: string, entry: string): string {
   const lines = markdown.length > 0 ? markdown.split(/\r?\n/u) : [];
   const normalizedLines = [...lines];
@@ -160,20 +109,6 @@
   await Bun.write(logPath, next);
 }
 
-async function removeProposalFromReview(proposalId: string): Promise<void> {
-  const reviewPath = getReviewPath();
-  const reviewFile = Bun.file(reviewPath);
-  if (!(await reviewFile.exists())) return;
-
-  const markdown = await reviewFile.text();
-  const pattern = new RegExp(`^\\s*-\\s*\\[( |x|X|-)\\]\\s*${escapeRegex(proposalId)}\\b`, "u");
-  const nextLines = markdown.split(/\r?\n/u).filter((line) => !pattern.test(line));
-  const next = `${nextLines.join("\n").replace(/\n*$/u, "")}\n`;
-  if (next !== markdown) {
-    await Bun.write(reviewPath, next);
-  }
-}
-
 function isProposalOlderThanSevenDays(proposalId: string, now: Date = new Date()): boolean {
   const proposalDate = parseDateFromProposalId(proposalId);
   if (!proposalDate) return false;
@@ -278,114 +213,8 @@
     .find((line) => line.length > 0);
 
   return formatted ?? proposedText;
-}
-
-function parseState(raw: string): ProposalState | null {
-  const value = raw.trim().toLowerCase();
-  if (value === "x") return "checked";
-  if (value === "-") return "deleted";
-  if (value === "") return "unchecked";
-  return null;
-}
-
-function parseCurrentState(currentState: unknown): Map<string, ProposalState> {
-  const map = new Map<string, ProposalState>();
-
-  if (!currentState || typeof currentState !== "object") return map;
-  const proposals = (currentState as { proposals?: unknown }).proposals;
-  if (!Array.isArray(proposals)) return map;
-
-  for (const proposal of proposals) {
-    if (!proposal || typeof proposal !== "object") continue;
-    const id = (proposal as { id?: unknown }).id;
-    const state = (proposal as { state?: unknown }).state;
-    if (typeof id !== "string") continue;
-    if (state === "checked" || state === "unchecked" || state === "deleted") {
-      map.set(id, state);
-    }
-  }
-
-  return map;
-}
-
-function isExpired(capturedAt: string | undefined, now: Date): boolean {
-  if (!capturedAt) return false;
-  const created = new Date(capturedAt);
-  if (Number.isNaN(created.getTime())) return false;
-  return now.getTime() - created.getTime() >= SEVEN_DAYS_MS;
 }
-
-function extractContentPath(eventData: unknown): string | null {
-  if (!eventData || typeof eventData !== "object") return null;
-  const rec = eventData as Record<string, unknown>;
-
-  const candidates = [rec.path, rec.filePath, rec.filepath];
-  for (const candidate of candidates) {
-    if (typeof candidate === "string" && candidate.length > 0) {
-      return candidate;
-    }
-  }
-
-  return null;
-}
-
-function createStableDiff(
-  approved: ProposalChange[],
-  rejected: ProposalChange[],
-  expired: ProposalChange[],
-  unchanged: ProposalChange[],
-  pending: string[]
-): ProposalDiff {
-  const data = {
-    approved,
-    rejected,
-    expired,
-    unchanged,
-    pending,
-  } satisfies ProposalDiff;
 
-  return new Proxy({} as ProposalDiff, {
-    get(_, property) {
-      if (property === "approved") return data.approved.map((item) => ({ ...item }));
-      if (property === "rejected") return data.rejected.map((item) => ({ ...item }));
-      if (property === "expired") return data.expired.map((item) => ({ ...item }));
-      if (property === "unchanged") return data.unchanged.map((item) => ({ ...item }));
-      if (property === "pending") return [...data.pending];
-      return undefined;
-    },
-    set() {
-      return true;
-    },
-    has(_, property) {
-      return (
-        property === "approved" ||
-        property === "rejected" ||
-        property === "expired" ||
-        property === "unchanged" ||
-        property === "pending"
-      );
-    },
-    ownKeys() {
-      return ["approved", "rejected", "expired", "unchanged", "pending"];
-    },
-    getOwnPropertyDescriptor(_, property) {
-      if (
-        property === "approved" ||
-        property === "rejected" ||
-        property === "expired" ||
-        property === "unchanged" ||
-        property === "pending"
-      ) {
-        return {
-          enumerable: true,
-          configurable: true,
-        };
-      }
-      return undefined;
-    },
-  });
-}
-
 function stabilizeFunctionOpts<T extends { opts?: Record<string, unknown> }>(fn: T): T {
   const original = fn.opts;
   if (!original) return fn;
@@ -414,92 +243,7 @@
     },
   });
 }
-
-export function parseReviewMd(markdown: string): ParsedReview {
-  const proposals: ParsedReviewProposal[] = [];
 
-  const lines = markdown.split(/\r?\n/u);
-  for (const line of lines) {
-    const match = /^\s*-\s*\[( |x|X|-)\]\s*(p-\d{8}-\d{3,})\b/u.exec(line);
-    if (!match?.[1] || !match[2]) continue;
-
-    const state = parseState(match[1]);
-    if (!state) continue;
-
-    proposals.push({
-      id: match[2],
-      state,
-    });
-  }
-
-  return { proposals };
-}
-
-export async function loadProposalState(redis: Pick<RedisLike, "lrange" | "hgetall">): Promise<ProposalStateSnapshot> {
-  const pending = await redis.lrange(REVIEW_PENDING_KEY, 0, -1);
-  const proposals: Record<string, StoredProposal> = {};
-
-  for (const id of pending) {
-    const stored = await redis.hgetall(proposalKey(id));
-    proposals[id] = {
-      id,
-      status: stored.status ?? "pending",
-      capturedAt: stored.capturedAt,
-      date: stored.date,
-      section: stored.section,
-      change: stored.change,
-    };
-  }
-
-  return { pending, proposals };
-}
-
-export function detectChanges(
-  currentState: unknown,
-  previousState: ProposalStateSnapshot,
-  now: Date = new Date()
-): ProposalDiff {
-  const current = parseCurrentState(currentState);
-  const approved: ProposalChange[] = [];
-  const rejected: ProposalChange[] = [];
-  const expired: ProposalChange[] = [];
-  const unchanged: ProposalChange[] = [];
-  const pending: string[] = [];
-
-  for (const id of previousState.pending) {
-    const proposal = previousState.proposals[id] ?? { id, status: "pending" };
-    const currentProposalState = current.get(id);
-
-    if (currentProposalState === "checked") {
-      approved.push({ id, proposal });
-      continue;
-    }
-
-    if (currentProposalState === "deleted" || currentProposalState === undefined) {
-      rejected.push({ id, proposal });
-      continue;
-    }
-
-    if (isExpired(proposal.capturedAt, now)) {
-      expired.push({ id, proposal });
-      continue;
-    }
-
-    unchanged.push({ id, proposal });
-    pending.push(id);
-  }
-
-  for (const [id, state] of current.entries()) {
-    if (previousState.pending.includes(id)) continue;
-    if (state === "unchecked") {
-      unchanged.push({ id, proposal: previousState.proposals[id] ?? { id, status: "pending" } });
-      pending.push(id);
-    }
-  }
-
-  return createStableDiff(approved, rejected, expired, unchanged, pending);
-}
-
 export async function promoteToMemory(proposalId: string): Promise<void> {
   const redis = getRedisClient();
   const key = proposalKey(proposalId);
@@ -533,10 +277,9 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
-export async function archiveProposal(proposalId: string, reason: "deleted" | "marked-rejected"): Promise<void> {
+export async function archiveProposal(proposalId: string, reason: string): Promise<void> {
   const redis = getRedisClient();
   const key = proposalKey(proposalId);
   const proposal = await redis.hgetall(key);
@@ -549,7 +292,6 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
 export async function expireProposal(proposalId: string): Promise<void> {
@@ -567,115 +309,62 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
 const promoteFunction = stabilizeFunctionOpts(
   inngest.createFunction(
-  {
-    id: "memory/review-promote",
-    name: "Promote Review Decisions",
-  },
-  [
     {
-      event: "content/updated",
-      if: `event.data.path == \"${REVIEW_PATH_FILTER}\" || event.data.path.endsWith(\"/${REVIEW_FILE_NAME}\")`,
+      id: "memory/review-promote",
+      name: "Promote Review Decisions",
     },
-    { cron: "0 8 * * *" },
-  ],
-  async ({ event, step }) => {
-    const shouldSkip = await step.run("filter-review-events", async () => {
-      if (event.name !== "content/updated") return false;
-      const updatedPath = extractContentPath(event.data);
-      if (!updatedPath) return false;
-      return !updatedPath.toLowerCase().endsWith(`/${REVIEW_FILE_NAME.toLowerCase()}`);
-    });
-
-    if (shouldSkip) {
-      return {
-        skipped: true,
-        reason: "content/updated path does not target REVIEW.md",
-      };
-    }
-
-    const parsed = await step.run("parse-review", async () => {
-      const reviewFile = Bun.file(getReviewPath());
-      if (!(await reviewFile.exists())) {
-        return { proposals: [] } as ParsedReview;
-      }
-
-      const markdown = await reviewFile.text();
-      return parseReviewMd(markdown);
-    });
-
-    const previous = await step.run("load-state", async () => {
-      const redis = getRedisClient();
-      return loadProposalState(redis);
-    });
-
-    const changes = await step.run("detect-changes", async () => detectChanges(parsed, previous));
-
-    await step.run("route", async () => {
-      const parsedById = new Map(parsed.proposals.map((proposal) => [proposal.id, proposal]));
+    [{ event: "memory/proposal.approved" }, { event: "memory/proposal.rejected" }, { cron: "0 8 * * *" }],
+    async ({ event, step }) => {
+      if (event.name === "memory/proposal.approved") {
+        const proposalId = await step.run("resolve-approved-proposal-id", async () => {
+          const id = (event.data as { proposalId?: unknown }).proposalId;
+          if (typeof id !== "string" || id.trim().length === 0) {
+            throw new Error("memory/proposal.approved requires event.data.proposalId");
+          }
+          return id;
+        });
 
-      for (const change of changes.approved) {
-        await promoteToMemory(change.id);
+        await step.run("promote-approved-proposal", async () => promoteToMemory(proposalId));
+        return { approved: [proposalId] };
       }
 
-      for (const change of changes.rejected) {
-        const reason = parsedById.get(change.id)?.state === "deleted" ? "marked-rejected" : "deleted";
-        await archiveProposal(change.id, reason);
-      }
+      if (event.name === "memory/proposal.rejected") {
+        const payload = await step.run("resolve-rejected-payload", async () => {
+          const id = (event.data as { proposalId?: unknown }).proposalId;
+          const reason = (event.data as { reason?: unknown }).reason;
+          if (typeof id !== "string" || id.trim().length === 0) {
+            throw new Error("memory/proposal.rejected requires event.data.proposalId");
+          }
+          if (typeof reason !== "string" || reason.trim().length === 0) {
+            throw new Error("memory/proposal.rejected requires event.data.reason");
+          }
+          return { proposalId: id, reason };
+        });
 
-      for (const change of changes.expired) {
-        await expireProposal(change.id);
+        await step.run("archive-rejected-proposal", async () => archiveProposal(payload.proposalId, payload.reason));
+        return { rejected: [payload.proposalId], reason: payload.reason };
       }
-    });
 
-    const updateState = await step.run("update-state", async () => {
-      const redis = getRedisClient();
-      const nextPending = [...new Set(changes.pending)];
-
-      await redis.del(REVIEW_PENDING_KEY);
-      if (nextPending.length > 0) {
-        await redis.rpush(REVIEW_PENDING_KEY, ...nextPending);
-      }
+      const expiredIds = await step.run("expire-stale-proposals", async () => {
+        const redis = getRedisClient();
+        const pending = await redis.lrange(REVIEW_PENDING_KEY, 0, -1);
+        const expired: string[] = [];
 
-      const parsedById = new Map(parsed.proposals.map((proposal) => [proposal.id, proposal]));
-      for (const id of nextPending) {
-        const existing = previous.proposals[id];
-        const parsedProposal = parsedById.get(id);
-        await redis.hset(
-          proposalKey(id),
-          "id",
-          id,
-          "status",
-          "pending",
-          "state",
-          parsedProposal?.state ?? "unchecked",
-          "capturedAt",
-          existing?.capturedAt ?? new Date().toISOString(),
-          "date",
-          existing?.date ?? new Date().toISOString().slice(0, 10),
-          "section",
-          existing?.section ?? "",
-          "change",
-          existing?.change ?? ""
-        );
-      }
+        for (const proposalId of pending) {
+          if (!isProposalOlderThanSevenDays(proposalId)) continue;
+          await expireProposal(proposalId);
+          expired.push(proposalId);
+        }
 
-      return {
-        pending: nextPending,
-      };
-    });
+        return expired;
+      });
 
-    return {
-      approved: changes.approved.map((item) => item.id),
-      rejected: changes.rejected.map((item) => item.id),
-      expired: changes.expired.map((item) => item.id),
-      pending: updateState.pending,
-    };
-  }
+      return { expired: expiredIds };
+    }
   )
 );
 

file update:
diff --git a/packages/system-bus/src/inngest/functions/promote-integration.test.ts b/packages/system-bus/src/inngest/functions/promote-integration.test.ts
index ec552d8c5c0beb8271678d6aa7d39ccf1cdcb9e3..4fb7794ef87210aadf98f05d3d468912e127df10
--- a/packages/system-bus/src/inngest/functions/promote-integration.test.ts
+++ b/packages/system-bus/src/inngest/functions/promote-integration.test.ts
@@ -29,7 +29,6 @@
 
 let tempHome = "";
 let workspaceDir = "";
-let reviewPath = "";
 let memoryPath = "";
 
 function proposalKey(id: string): string {
@@ -189,7 +188,6 @@
   process.env.USERPROFILE = tempHome;
 
   workspaceDir = join(tempHome, ".joelclaw", "workspace");
-  reviewPath = join(workspaceDir, "REVIEW.md");
   memoryPath = join(workspaceDir, "MEMORY.md");
 
   mkdirSync(join(workspaceDir, "memory"), { recursive: true });
@@ -222,7 +220,7 @@
 });
 
 describe("MEM-22 promote integration acceptance test", () => {
-  test("runs end-to-end promotion workflow from REVIEW.md to MEMORY.md with no proposal loss", async () => {
+  test("runs end-to-end promotion workflow through event-driven handlers with no proposal loss", async () => {
     const approvedId = proposalIdDaysAgo(1, "101");
     const deletedId = proposalIdDaysAgo(1, "102");
     const expiredId = proposalIdDaysAgo(8, "103");
@@ -256,33 +254,32 @@
       capturedAt: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(),
     });
 
-    writeFileSync(
-      reviewPath,
-      [
-        "# REVIEW",
-        "",
-        `- [x] ${approvedId}: ${approvedText}`,
-        `- [ ] ${expiredId}: ${expiredText}`,
-        `- [ ] ${activePendingId}: ${activePendingText}`,
-        "",
-      ].join("\n")
-    );
-
-    const { result } = await executePromoteWithEvent({
-      name: "content/updated",
-      data: { path: reviewPath },
+    const { result: approvedResult } = await executePromoteWithEvent({
+      name: "memory/proposal.approved",
+      data: { proposalId: approvedId },
+    });
+    const { result: rejectedResult } = await executePromoteWithEvent({
+      name: "memory/proposal.rejected",
+      data: { proposalId: deletedId, reason: "deleted" },
+    });
+    const { result: expiredResult } = await executePromoteWithEvent({
+      name: "inngest/scheduled.timer",
+      data: { cron: "0 8 * * *" },
     });
 
     const memory = readFileSync(memoryPath, "utf8");
     const hardRules = getSectionBlock(memory, "Hard Rules");
     const log = readFileSync(todayLogPath(), "utf8");
-    const review = readFileSync(reviewPath, "utf8");
 
-    expect(result).toMatchObject({
+    expect(approvedResult).toMatchObject({
       approved: [approvedId],
+    });
+    expect(rejectedResult).toMatchObject({
       rejected: [deletedId],
+      reason: "deleted",
+    });
+    expect(expiredResult).toMatchObject({
       expired: [expiredId],
-      pending: [activePendingId],
     });
 
     expect(hardRules).toContain(`- (${proposalDateFromId(approvedId)})`);
@@ -296,11 +293,6 @@
     expect(redisState.hashes.has(proposalKey(approvedId))).toBe(false);
     expect(redisState.hashes.has(proposalKey(deletedId))).toBe(false);
     expect(redisState.hashes.has(proposalKey(expiredId))).toBe(false);
-
-    expect(review).toContain(activePendingId);
-    expect(review).not.toContain(approvedId);
-    expect(review).not.toContain(deletedId);
-    expect(review).not.toContain(expiredId);
 
     expect({
       approvedInMemory: hardRules.includes(`- (${proposalDateFromId(approvedId)})`),
diff --git a/packages/system-bus/src/inngest/functions/promote.ts b/packages/system-bus/src/inngest/functions/promote.ts
index 09730ecff690b4bfba745ef6f7b0a7469122608c..4fa05b25f8a9810e0b2052835bcfe45293b19d41
--- a/packages/system-bus/src/inngest/functions/promote.ts
+++ b/packages/system-bus/src/inngest/functions/promote.ts
@@ -4,56 +4,14 @@
 import { inngest } from "../client";
 import { PROMOTE_SYSTEM_PROMPT, PROMOTE_USER_PROMPT } from "./promote-prompt";
 
-export type ProposalState = "checked" | "unchecked" | "deleted";
-
-export type ParsedReviewProposal = {
-  id: string;
-  state: ProposalState;
-};
-
-export type ParsedReview = {
-  proposals: ParsedReviewProposal[];
-};
-
-export type StoredProposal = {
-  id: string;
-  status: string;
-  capturedAt?: string;
-  date?: string;
-  section?: string;
-  change?: string;
-};
-
-export type ProposalStateSnapshot = {
-  pending: string[];
-  proposals: Record<string, StoredProposal>;
-};
-
-export type ProposalChange = {
-  id: string;
-  proposal?: StoredProposal;
-};
-
-export type ProposalDiff = {
-  approved: ProposalChange[];
-  rejected: ProposalChange[];
-  expired: ProposalChange[];
-  unchanged: ProposalChange[];
-  pending: string[];
-};
-
 type RedisLike = {
   lrange(key: string, start: number, stop: number): Promise<string[]>;
   hgetall(key: string): Promise<Record<string, string>>;
-  hset(key: string, ...args: string[]): Promise<unknown>;
   lrem(key: string, count: number, value: string): Promise<unknown>;
   del(key: string): Promise<unknown>;
-  rpush(key: string, ...values: string[]): Promise<unknown>;
 };
 
 const REVIEW_PENDING_KEY = "memory:review:pending";
-const REVIEW_PATH_FILTER = "~/.joelclaw/workspace/REVIEW.md";
-const REVIEW_FILE_NAME = "REVIEW.md";
 const MEMORY_FILE_NAME = "MEMORY.md";
 const SEVEN_DAYS_MS = 7 * 24 * 60 * 60 * 1000;
 const REJECTED_PROPOSALS_HEADER = "### Rejected Proposals";
@@ -73,11 +31,6 @@
     redisClient.on("error", () => {});
   }
   return redisClient;
-}
-
-function getReviewPath(): string {
-  const home = process.env.HOME || process.env.USERPROFILE || "/Users/joel";
-  return join(home, ".joelclaw", "workspace", REVIEW_FILE_NAME);
 }
 
 function getMemoryPath(): string {
@@ -121,10 +74,6 @@
   return date;
 }
 
-function escapeRegex(value: string): string {
-  return value.replace(/[.*+?^${}()|[\]\\]/gu, "\\$&");
-}
-
 function appendEntryToLogSection(markdown: string, header: string, entry: string): string {
   const lines = markdown.length > 0 ? markdown.split(/\r?\n/u) : [];
   const normalizedLines = [...lines];
@@ -160,20 +109,6 @@
   await Bun.write(logPath, next);
 }
 
-async function removeProposalFromReview(proposalId: string): Promise<void> {
-  const reviewPath = getReviewPath();
-  const reviewFile = Bun.file(reviewPath);
-  if (!(await reviewFile.exists())) return;
-
-  const markdown = await reviewFile.text();
-  const pattern = new RegExp(`^\\s*-\\s*\\[( |x|X|-)\\]\\s*${escapeRegex(proposalId)}\\b`, "u");
-  const nextLines = markdown.split(/\r?\n/u).filter((line) => !pattern.test(line));
-  const next = `${nextLines.join("\n").replace(/\n*$/u, "")}\n`;
-  if (next !== markdown) {
-    await Bun.write(reviewPath, next);
-  }
-}
-
 function isProposalOlderThanSevenDays(proposalId: string, now: Date = new Date()): boolean {
   const proposalDate = parseDateFromProposalId(proposalId);
   if (!proposalDate) return false;
@@ -278,114 +213,8 @@
     .find((line) => line.length > 0);
 
   return formatted ?? proposedText;
-}
-
-function parseState(raw: string): ProposalState | null {
-  const value = raw.trim().toLowerCase();
-  if (value === "x") return "checked";
-  if (value === "-") return "deleted";
-  if (value === "") return "unchecked";
-  return null;
-}
-
-function parseCurrentState(currentState: unknown): Map<string, ProposalState> {
-  const map = new Map<string, ProposalState>();
-
-  if (!currentState || typeof currentState !== "object") return map;
-  const proposals = (currentState as { proposals?: unknown }).proposals;
-  if (!Array.isArray(proposals)) return map;
-
-  for (const proposal of proposals) {
-    if (!proposal || typeof proposal !== "object") continue;
-    const id = (proposal as { id?: unknown }).id;
-    const state = (proposal as { state?: unknown }).state;
-    if (typeof id !== "string") continue;
-    if (state === "checked" || state === "unchecked" || state === "deleted") {
-      map.set(id, state);
-    }
-  }
-
-  return map;
-}
-
-function isExpired(capturedAt: string | undefined, now: Date): boolean {
-  if (!capturedAt) return false;
-  const created = new Date(capturedAt);
-  if (Number.isNaN(created.getTime())) return false;
-  return now.getTime() - created.getTime() >= SEVEN_DAYS_MS;
 }
-
-function extractContentPath(eventData: unknown): string | null {
-  if (!eventData || typeof eventData !== "object") return null;
-  const rec = eventData as Record<string, unknown>;
-
-  const candidates = [rec.path, rec.filePath, rec.filepath];
-  for (const candidate of candidates) {
-    if (typeof candidate === "string" && candidate.length > 0) {
-      return candidate;
-    }
-  }
-
-  return null;
-}
-
-function createStableDiff(
-  approved: ProposalChange[],
-  rejected: ProposalChange[],
-  expired: ProposalChange[],
-  unchanged: ProposalChange[],
-  pending: string[]
-): ProposalDiff {
-  const data = {
-    approved,
-    rejected,
-    expired,
-    unchanged,
-    pending,
-  } satisfies ProposalDiff;
 
-  return new Proxy({} as ProposalDiff, {
-    get(_, property) {
-      if (property === "approved") return data.approved.map((item) => ({ ...item }));
-      if (property === "rejected") return data.rejected.map((item) => ({ ...item }));
-      if (property === "expired") return data.expired.map((item) => ({ ...item }));
-      if (property === "unchanged") return data.unchanged.map((item) => ({ ...item }));
-      if (property === "pending") return [...data.pending];
-      return undefined;
-    },
-    set() {
-      return true;
-    },
-    has(_, property) {
-      return (
-        property === "approved" ||
-        property === "rejected" ||
-        property === "expired" ||
-        property === "unchanged" ||
-        property === "pending"
-      );
-    },
-    ownKeys() {
-      return ["approved", "rejected", "expired", "unchanged", "pending"];
-    },
-    getOwnPropertyDescriptor(_, property) {
-      if (
-        property === "approved" ||
-        property === "rejected" ||
-        property === "expired" ||
-        property === "unchanged" ||
-        property === "pending"
-      ) {
-        return {
-          enumerable: true,
-          configurable: true,
-        };
-      }
-      return undefined;
-    },
-  });
-}
-
 function stabilizeFunctionOpts<T extends { opts?: Record<string, unknown> }>(fn: T): T {
   const original = fn.opts;
   if (!original) return fn;
@@ -414,92 +243,7 @@
     },
   });
 }
-
-export function parseReviewMd(markdown: string): ParsedReview {
-  const proposals: ParsedReviewProposal[] = [];
 
-  const lines = markdown.split(/\r?\n/u);
-  for (const line of lines) {
-    const match = /^\s*-\s*\[( |x|X|-)\]\s*(p-\d{8}-\d{3,})\b/u.exec(line);
-    if (!match?.[1] || !match[2]) continue;
-
-    const state = parseState(match[1]);
-    if (!state) continue;
-
-    proposals.push({
-      id: match[2],
-      state,
-    });
-  }
-
-  return { proposals };
-}
-
-export async function loadProposalState(redis: Pick<RedisLike, "lrange" | "hgetall">): Promise<ProposalStateSnapshot> {
-  const pending = await redis.lrange(REVIEW_PENDING_KEY, 0, -1);
-  const proposals: Record<string, StoredProposal> = {};
-
-  for (const id of pending) {
-    const stored = await redis.hgetall(proposalKey(id));
-    proposals[id] = {
-      id,
-      status: stored.status ?? "pending",
-      capturedAt: stored.capturedAt,
-      date: stored.date,
-      section: stored.section,
-      change: stored.change,
-    };
-  }
-
-  return { pending, proposals };
-}
-
-export function detectChanges(
-  currentState: unknown,
-  previousState: ProposalStateSnapshot,
-  now: Date = new Date()
-): ProposalDiff {
-  const current = parseCurrentState(currentState);
-  const approved: ProposalChange[] = [];
-  const rejected: ProposalChange[] = [];
-  const expired: ProposalChange[] = [];
-  const unchanged: ProposalChange[] = [];
-  const pending: string[] = [];
-
-  for (const id of previousState.pending) {
-    const proposal = previousState.proposals[id] ?? { id, status: "pending" };
-    const currentProposalState = current.get(id);
-
-    if (currentProposalState === "checked") {
-      approved.push({ id, proposal });
-      continue;
-    }
-
-    if (currentProposalState === "deleted" || currentProposalState === undefined) {
-      rejected.push({ id, proposal });
-      continue;
-    }
-
-    if (isExpired(proposal.capturedAt, now)) {
-      expired.push({ id, proposal });
-      continue;
-    }
-
-    unchanged.push({ id, proposal });
-    pending.push(id);
-  }
-
-  for (const [id, state] of current.entries()) {
-    if (previousState.pending.includes(id)) continue;
-    if (state === "unchecked") {
-      unchanged.push({ id, proposal: previousState.proposals[id] ?? { id, status: "pending" } });
-      pending.push(id);
-    }
-  }
-
-  return createStableDiff(approved, rejected, expired, unchanged, pending);
-}
-
 export async function promoteToMemory(proposalId: string): Promise<void> {
   const redis = getRedisClient();
   const key = proposalKey(proposalId);
@@ -533,10 +277,9 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
-export async function archiveProposal(proposalId: string, reason: "deleted" | "marked-rejected"): Promise<void> {
+export async function archiveProposal(proposalId: string, reason: string): Promise<void> {
   const redis = getRedisClient();
   const key = proposalKey(proposalId);
   const proposal = await redis.hgetall(key);
@@ -549,7 +292,6 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
 export async function expireProposal(proposalId: string): Promise<void> {
@@ -567,115 +309,62 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
 const promoteFunction = stabilizeFunctionOpts(
   inngest.createFunction(
-  {
-    id: "memory/review-promote",
-    name: "Promote Review Decisions",
-  },
-  [
     {
-      event: "content/updated",
-      if: `event.data.path == \"${REVIEW_PATH_FILTER}\" || event.data.path.endsWith(\"/${REVIEW_FILE_NAME}\")`,
+      id: "memory/review-promote",
+      name: "Promote Review Decisions",
     },
-    { cron: "0 8 * * *" },
-  ],
-  async ({ event, step }) => {
-    const shouldSkip = await step.run("filter-review-events", async () => {
-      if (event.name !== "content/updated") return false;
-      const updatedPath = extractContentPath(event.data);
-      if (!updatedPath) return false;
-      return !updatedPath.toLowerCase().endsWith(`/${REVIEW_FILE_NAME.toLowerCase()}`);
-    });
-
-    if (shouldSkip) {
-      return {
-        skipped: true,
-        reason: "content/updated path does not target REVIEW.md",
-      };
-    }
-
-    const parsed = await step.run("parse-review", async () => {
-      const reviewFile = Bun.file(getReviewPath());
-      if (!(await reviewFile.exists())) {
-        return { proposals: [] } as ParsedReview;
-      }
-
-      const markdown = await reviewFile.text();
-      return parseReviewMd(markdown);
-    });
-
-    const previous = await step.run("load-state", async () => {
-      const redis = getRedisClient();
-      return loadProposalState(redis);
-    });
-
-    const changes = await step.run("detect-changes", async () => detectChanges(parsed, previous));
-
-    await step.run("route", async () => {
-      const parsedById = new Map(parsed.proposals.map((proposal) => [proposal.id, proposal]));
+    [{ event: "memory/proposal.approved" }, { event: "memory/proposal.rejected" }, { cron: "0 8 * * *" }],
+    async ({ event, step }) => {
+      if (event.name === "memory/proposal.approved") {
+        const proposalId = await step.run("resolve-approved-proposal-id", async () => {
+          const id = (event.data as { proposalId?: unknown }).proposalId;
+          if (typeof id !== "string" || id.trim().length === 0) {
+            throw new Error("memory/proposal.approved requires event.data.proposalId");
+          }
+          return id;
+        });
 
-      for (const change of changes.approved) {
-        await promoteToMemory(change.id);
+        await step.run("promote-approved-proposal", async () => promoteToMemory(proposalId));
+        return { approved: [proposalId] };
       }
 
-      for (const change of changes.rejected) {
-        const reason = parsedById.get(change.id)?.state === "deleted" ? "marked-rejected" : "deleted";
-        await archiveProposal(change.id, reason);
-      }
+      if (event.name === "memory/proposal.rejected") {
+        const payload = await step.run("resolve-rejected-payload", async () => {
+          const id = (event.data as { proposalId?: unknown }).proposalId;
+          const reason = (event.data as { reason?: unknown }).reason;
+          if (typeof id !== "string" || id.trim().length === 0) {
+            throw new Error("memory/proposal.rejected requires event.data.proposalId");
+          }
+          if (typeof reason !== "string" || reason.trim().length === 0) {
+            throw new Error("memory/proposal.rejected requires event.data.reason");
+          }
+          return { proposalId: id, reason };
+        });
 
-      for (const change of changes.expired) {
-        await expireProposal(change.id);
+        await step.run("archive-rejected-proposal", async () => archiveProposal(payload.proposalId, payload.reason));
+        return { rejected: [payload.proposalId], reason: payload.reason };
       }
-    });
 
-    const updateState = await step.run("update-state", async () => {
-      const redis = getRedisClient();
-      const nextPending = [...new Set(changes.pending)];
-
-      await redis.del(REVIEW_PENDING_KEY);
-      if (nextPending.length > 0) {
-        await redis.rpush(REVIEW_PENDING_KEY, ...nextPending);
-      }
+      const expiredIds = await step.run("expire-stale-proposals", async () => {
+        const redis = getRedisClient();
+        const pending = await redis.lrange(REVIEW_PENDING_KEY, 0, -1);
+        const expired: string[] = [];
 
-      const parsedById = new Map(parsed.proposals.map((proposal) => [proposal.id, proposal]));
-      for (const id of nextPending) {
-        const existing = previous.proposals[id];
-        const parsedProposal = parsedById.get(id);
-        await redis.hset(
-          proposalKey(id),
-          "id",
-          id,
-          "status",
-          "pending",
-          "state",
-          parsedProposal?.state ?? "unchecked",
-          "capturedAt",
-          existing?.capturedAt ?? new Date().toISOString(),
-          "date",
-          existing?.date ?? new Date().toISOString().slice(0, 10),
-          "section",
-          existing?.section ?? "",
-          "change",
-          existing?.change ?? ""
-        );
-      }
+        for (const proposalId of pending) {
+          if (!isProposalOlderThanSevenDays(proposalId)) continue;
+          await expireProposal(proposalId);
+          expired.push(proposalId);
+        }
 
-      return {
-        pending: nextPending,
-      };
-    });
+        return expired;
+      });
 
-    return {
-      approved: changes.approved.map((item) => item.id),
-      rejected: changes.rejected.map((item) => item.id),
-      expired: changes.expired.map((item) => item.id),
-      pending: updateState.pending,
-    };
-  }
+      return { expired: expiredIds };
+    }
   )
 );
 


thinking
**Rerunning checks**
exec
/bin/zsh -lc 'bun test packages/system-bus/src/inngest/functions/promote.test.ts' in /private/tmp/agent-loop/loop-mlr8oxtg-b68bp4exec
/bin/zsh -lc 'bunx tsc --noEmit' in /private/tmp/agent-loop/loop-mlr8oxtg-b68bp4 succeeded in 350ms:
(pass) MEM-3 promote acceptance tests > approved proposal event promotes memory and leaves REVIEW.md untouched [175.32ms]
(pass) MEM-3 promote acceptance tests > rejected proposal event archives reason and leaves REVIEW.md untouched [4.00ms]
(pass) MEM-3 promote acceptance tests > cron trigger auto-expires proposals older than 7 days [3.58ms]
(pass) MEM-3 promote acceptance tests > direct public operations do not mutate REVIEW.md [130.95ms]

 6 pass
 0 fail
 7 expect() calls
Ran 6 tests across 1 file. [386.00ms]
 succeeded in 463ms:

file update:
diff --git a/packages/system-bus/src/inngest/functions/promote-integration.test.ts b/packages/system-bus/src/inngest/functions/promote-integration.test.ts
index ec552d8c5c0beb8271678d6aa7d39ccf1cdcb9e3..4fb7794ef87210aadf98f05d3d468912e127df10
--- a/packages/system-bus/src/inngest/functions/promote-integration.test.ts
+++ b/packages/system-bus/src/inngest/functions/promote-integration.test.ts
@@ -29,7 +29,6 @@
 
 let tempHome = "";
 let workspaceDir = "";
-let reviewPath = "";
 let memoryPath = "";
 
 function proposalKey(id: string): string {
@@ -189,7 +188,6 @@
   process.env.USERPROFILE = tempHome;
 
   workspaceDir = join(tempHome, ".joelclaw", "workspace");
-  reviewPath = join(workspaceDir, "REVIEW.md");
   memoryPath = join(workspaceDir, "MEMORY.md");
 
   mkdirSync(join(workspaceDir, "memory"), { recursive: true });
@@ -222,7 +220,7 @@
 });
 
 describe("MEM-22 promote integration acceptance test", () => {
-  test("runs end-to-end promotion workflow from REVIEW.md to MEMORY.md with no proposal loss", async () => {
+  test("runs end-to-end promotion workflow through event-driven handlers with no proposal loss", async () => {
     const approvedId = proposalIdDaysAgo(1, "101");
     const deletedId = proposalIdDaysAgo(1, "102");
     const expiredId = proposalIdDaysAgo(8, "103");
@@ -256,33 +254,32 @@
       capturedAt: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(),
     });
 
-    writeFileSync(
-      reviewPath,
-      [
-        "# REVIEW",
-        "",
-        `- [x] ${approvedId}: ${approvedText}`,
-        `- [ ] ${expiredId}: ${expiredText}`,
-        `- [ ] ${activePendingId}: ${activePendingText}`,
-        "",
-      ].join("\n")
-    );
-
-    const { result } = await executePromoteWithEvent({
-      name: "content/updated",
-      data: { path: reviewPath },
+    const { result: approvedResult } = await executePromoteWithEvent({
+      name: "memory/proposal.approved",
+      data: { proposalId: approvedId },
+    });
+    const { result: rejectedResult } = await executePromoteWithEvent({
+      name: "memory/proposal.rejected",
+      data: { proposalId: deletedId, reason: "deleted" },
+    });
+    const { result: expiredResult } = await executePromoteWithEvent({
+      name: "inngest/scheduled.timer",
+      data: { cron: "0 8 * * *" },
     });
 
     const memory = readFileSync(memoryPath, "utf8");
     const hardRules = getSectionBlock(memory, "Hard Rules");
     const log = readFileSync(todayLogPath(), "utf8");
-    const review = readFileSync(reviewPath, "utf8");
 
-    expect(result).toMatchObject({
+    expect(approvedResult).toMatchObject({
       approved: [approvedId],
+    });
+    expect(rejectedResult).toMatchObject({
       rejected: [deletedId],
+      reason: "deleted",
+    });
+    expect(expiredResult).toMatchObject({
       expired: [expiredId],
-      pending: [activePendingId],
     });
 
     expect(hardRules).toContain(`- (${proposalDateFromId(approvedId)})`);
@@ -296,11 +293,6 @@
     expect(redisState.hashes.has(proposalKey(approvedId))).toBe(false);
     expect(redisState.hashes.has(proposalKey(deletedId))).toBe(false);
     expect(redisState.hashes.has(proposalKey(expiredId))).toBe(false);
-
-    expect(review).toContain(activePendingId);
-    expect(review).not.toContain(approvedId);
-    expect(review).not.toContain(deletedId);
-    expect(review).not.toContain(expiredId);
 
     expect({
       approvedInMemory: hardRules.includes(`- (${proposalDateFromId(approvedId)})`),
diff --git a/packages/system-bus/src/inngest/functions/promote.ts b/packages/system-bus/src/inngest/functions/promote.ts
index 09730ecff690b4bfba745ef6f7b0a7469122608c..4fa05b25f8a9810e0b2052835bcfe45293b19d41
--- a/packages/system-bus/src/inngest/functions/promote.ts
+++ b/packages/system-bus/src/inngest/functions/promote.ts
@@ -4,56 +4,14 @@
 import { inngest } from "../client";
 import { PROMOTE_SYSTEM_PROMPT, PROMOTE_USER_PROMPT } from "./promote-prompt";
 
-export type ProposalState = "checked" | "unchecked" | "deleted";
-
-export type ParsedReviewProposal = {
-  id: string;
-  state: ProposalState;
-};
-
-export type ParsedReview = {
-  proposals: ParsedReviewProposal[];
-};
-
-export type StoredProposal = {
-  id: string;
-  status: string;
-  capturedAt?: string;
-  date?: string;
-  section?: string;
-  change?: string;
-};
-
-export type ProposalStateSnapshot = {
-  pending: string[];
-  proposals: Record<string, StoredProposal>;
-};
-
-export type ProposalChange = {
-  id: string;
-  proposal?: StoredProposal;
-};
-
-export type ProposalDiff = {
-  approved: ProposalChange[];
-  rejected: ProposalChange[];
-  expired: ProposalChange[];
-  unchanged: ProposalChange[];
-  pending: string[];
-};
-
 type RedisLike = {
   lrange(key: string, start: number, stop: number): Promise<string[]>;
   hgetall(key: string): Promise<Record<string, string>>;
-  hset(key: string, ...args: string[]): Promise<unknown>;
   lrem(key: string, count: number, value: string): Promise<unknown>;
   del(key: string): Promise<unknown>;
-  rpush(key: string, ...values: string[]): Promise<unknown>;
 };
 
 const REVIEW_PENDING_KEY = "memory:review:pending";
-const REVIEW_PATH_FILTER = "~/.joelclaw/workspace/REVIEW.md";
-const REVIEW_FILE_NAME = "REVIEW.md";
 const MEMORY_FILE_NAME = "MEMORY.md";
 const SEVEN_DAYS_MS = 7 * 24 * 60 * 60 * 1000;
 const REJECTED_PROPOSALS_HEADER = "### Rejected Proposals";
@@ -73,11 +31,6 @@
     redisClient.on("error", () => {});
   }
   return redisClient;
-}
-
-function getReviewPath(): string {
-  const home = process.env.HOME || process.env.USERPROFILE || "/Users/joel";
-  return join(home, ".joelclaw", "workspace", REVIEW_FILE_NAME);
 }
 
 function getMemoryPath(): string {
@@ -121,10 +74,6 @@
   return date;
 }
 
-function escapeRegex(value: string): string {
-  return value.replace(/[.*+?^${}()|[\]\\]/gu, "\\$&");
-}
-
 function appendEntryToLogSection(markdown: string, header: string, entry: string): string {
   const lines = markdown.length > 0 ? markdown.split(/\r?\n/u) : [];
   const normalizedLines = [...lines];
@@ -160,20 +109,6 @@
   await Bun.write(logPath, next);
 }
 
-async function removeProposalFromReview(proposalId: string): Promise<void> {
-  const reviewPath = getReviewPath();
-  const reviewFile = Bun.file(reviewPath);
-  if (!(await reviewFile.exists())) return;
-
-  const markdown = await reviewFile.text();
-  const pattern = new RegExp(`^\\s*-\\s*\\[( |x|X|-)\\]\\s*${escapeRegex(proposalId)}\\b`, "u");
-  const nextLines = markdown.split(/\r?\n/u).filter((line) => !pattern.test(line));
-  const next = `${nextLines.join("\n").replace(/\n*$/u, "")}\n`;
-  if (next !== markdown) {
-    await Bun.write(reviewPath, next);
-  }
-}
-
 function isProposalOlderThanSevenDays(proposalId: string, now: Date = new Date()): boolean {
   const proposalDate = parseDateFromProposalId(proposalId);
   if (!proposalDate) return false;
@@ -278,114 +213,8 @@
     .find((line) => line.length > 0);
 
   return formatted ?? proposedText;
-}
-
-function parseState(raw: string): ProposalState | null {
-  const value = raw.trim().toLowerCase();
-  if (value === "x") return "checked";
-  if (value === "-") return "deleted";
-  if (value === "") return "unchecked";
-  return null;
-}
-
-function parseCurrentState(currentState: unknown): Map<string, ProposalState> {
-  const map = new Map<string, ProposalState>();
-
-  if (!currentState || typeof currentState !== "object") return map;
-  const proposals = (currentState as { proposals?: unknown }).proposals;
-  if (!Array.isArray(proposals)) return map;
-
-  for (const proposal of proposals) {
-    if (!proposal || typeof proposal !== "object") continue;
-    const id = (proposal as { id?: unknown }).id;
-    const state = (proposal as { state?: unknown }).state;
-    if (typeof id !== "string") continue;
-    if (state === "checked" || state === "unchecked" || state === "deleted") {
-      map.set(id, state);
-    }
-  }
-
-  return map;
-}
-
-function isExpired(capturedAt: string | undefined, now: Date): boolean {
-  if (!capturedAt) return false;
-  const created = new Date(capturedAt);
-  if (Number.isNaN(created.getTime())) return false;
-  return now.getTime() - created.getTime() >= SEVEN_DAYS_MS;
 }
-
-function extractContentPath(eventData: unknown): string | null {
-  if (!eventData || typeof eventData !== "object") return null;
-  const rec = eventData as Record<string, unknown>;
-
-  const candidates = [rec.path, rec.filePath, rec.filepath];
-  for (const candidate of candidates) {
-    if (typeof candidate === "string" && candidate.length > 0) {
-      return candidate;
-    }
-  }
-
-  return null;
-}
-
-function createStableDiff(
-  approved: ProposalChange[],
-  rejected: ProposalChange[],
-  expired: ProposalChange[],
-  unchanged: ProposalChange[],
-  pending: string[]
-): ProposalDiff {
-  const data = {
-    approved,
-    rejected,
-    expired,
-    unchanged,
-    pending,
-  } satisfies ProposalDiff;
 
-  return new Proxy({} as ProposalDiff, {
-    get(_, property) {
-      if (property === "approved") return data.approved.map((item) => ({ ...item }));
-      if (property === "rejected") return data.rejected.map((item) => ({ ...item }));
-      if (property === "expired") return data.expired.map((item) => ({ ...item }));
-      if (property === "unchanged") return data.unchanged.map((item) => ({ ...item }));
-      if (property === "pending") return [...data.pending];
-      return undefined;
-    },
-    set() {
-      return true;
-    },
-    has(_, property) {
-      return (
-        property === "approved" ||
-        property === "rejected" ||
-        property === "expired" ||
-        property === "unchanged" ||
-        property === "pending"
-      );
-    },
-    ownKeys() {
-      return ["approved", "rejected", "expired", "unchanged", "pending"];
-    },
-    getOwnPropertyDescriptor(_, property) {
-      if (
-        property === "approved" ||
-        property === "rejected" ||
-        property === "expired" ||
-        property === "unchanged" ||
-        property === "pending"
-      ) {
-        return {
-          enumerable: true,
-          configurable: true,
-        };
-      }
-      return undefined;
-    },
-  });
-}
-
 function stabilizeFunctionOpts<T extends { opts?: Record<string, unknown> }>(fn: T): T {
   const original = fn.opts;
   if (!original) return fn;
@@ -414,92 +243,7 @@
     },
   });
 }
-
-export function parseReviewMd(markdown: string): ParsedReview {
-  const proposals: ParsedReviewProposal[] = [];
 
-  const lines = markdown.split(/\r?\n/u);
-  for (const line of lines) {
-    const match = /^\s*-\s*\[( |x|X|-)\]\s*(p-\d{8}-\d{3,})\b/u.exec(line);
-    if (!match?.[1] || !match[2]) continue;
-
-    const state = parseState(match[1]);
-    if (!state) continue;
-
-    proposals.push({
-      id: match[2],
-      state,
-    });
-  }
-
-  return { proposals };
-}
-
-export async function loadProposalState(redis: Pick<RedisLike, "lrange" | "hgetall">): Promise<ProposalStateSnapshot> {
-  const pending = await redis.lrange(REVIEW_PENDING_KEY, 0, -1);
-  const proposals: Record<string, StoredProposal> = {};
-
-  for (const id of pending) {
-    const stored = await redis.hgetall(proposalKey(id));
-    proposals[id] = {
-      id,
-      status: stored.status ?? "pending",
-      capturedAt: stored.capturedAt,
-      date: stored.date,
-      section: stored.section,
-      change: stored.change,
-    };
-  }
-
-  return { pending, proposals };
-}
-
-export function detectChanges(
-  currentState: unknown,
-  previousState: ProposalStateSnapshot,
-  now: Date = new Date()
-): ProposalDiff {
-  const current = parseCurrentState(currentState);
-  const approved: ProposalChange[] = [];
-  const rejected: ProposalChange[] = [];
-  const expired: ProposalChange[] = [];
-  const unchanged: ProposalChange[] = [];
-  const pending: string[] = [];
-
-  for (const id of previousState.pending) {
-    const proposal = previousState.proposals[id] ?? { id, status: "pending" };
-    const currentProposalState = current.get(id);
-
-    if (currentProposalState === "checked") {
-      approved.push({ id, proposal });
-      continue;
-    }
-
-    if (currentProposalState === "deleted" || currentProposalState === undefined) {
-      rejected.push({ id, proposal });
-      continue;
-    }
-
-    if (isExpired(proposal.capturedAt, now)) {
-      expired.push({ id, proposal });
-      continue;
-    }
-
-    unchanged.push({ id, proposal });
-    pending.push(id);
-  }
-
-  for (const [id, state] of current.entries()) {
-    if (previousState.pending.includes(id)) continue;
-    if (state === "unchecked") {
-      unchanged.push({ id, proposal: previousState.proposals[id] ?? { id, status: "pending" } });
-      pending.push(id);
-    }
-  }
-
-  return createStableDiff(approved, rejected, expired, unchanged, pending);
-}
-
 export async function promoteToMemory(proposalId: string): Promise<void> {
   const redis = getRedisClient();
   const key = proposalKey(proposalId);
@@ -533,10 +277,9 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
-export async function archiveProposal(proposalId: string, reason: "deleted" | "marked-rejected"): Promise<void> {
+export async function archiveProposal(proposalId: string, reason: string): Promise<void> {
   const redis = getRedisClient();
   const key = proposalKey(proposalId);
   const proposal = await redis.hgetall(key);
@@ -549,7 +292,6 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
 export async function expireProposal(proposalId: string): Promise<void> {
@@ -567,115 +309,62 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
 const promoteFunction = stabilizeFunctionOpts(
   inngest.createFunction(
-  {
-    id: "memory/review-promote",
-    name: "Promote Review Decisions",
-  },
-  [
     {
-      event: "content/updated",
-      if: `event.data.path == \"${REVIEW_PATH_FILTER}\" || event.data.path.endsWith(\"/${REVIEW_FILE_NAME}\")`,
+      id: "memory/review-promote",
+      name: "Promote Review Decisions",
     },
-    { cron: "0 8 * * *" },
-  ],
-  async ({ event, step }) => {
-    const shouldSkip = await step.run("filter-review-events", async () => {
-      if (event.name !== "content/updated") return false;
-      const updatedPath = extractContentPath(event.data);
-      if (!updatedPath) return false;
-      return !updatedPath.toLowerCase().endsWith(`/${REVIEW_FILE_NAME.toLowerCase()}`);
-    });
-
-    if (shouldSkip) {
-      return {
-        skipped: true,
-        reason: "content/updated path does not target REVIEW.md",
-      };
-    }
-
-    const parsed = await step.run("parse-review", async () => {
-      const reviewFile = Bun.file(getReviewPath());
-      if (!(await reviewFile.exists())) {
-        return { proposals: [] } as ParsedReview;
-      }
-
-      const markdown = await reviewFile.text();
-      return parseReviewMd(markdown);
-    });
-
-    const previous = await step.run("load-state", async () => {
-      const redis = getRedisClient();
-      return loadProposalState(redis);
-    });
-
-    const changes = await step.run("detect-changes", async () => detectChanges(parsed, previous));
-
-    await step.run("route", async () => {
-      const parsedById = new Map(parsed.proposals.map((proposal) => [proposal.id, proposal]));
+    [{ event: "memory/proposal.approved" }, { event: "memory/proposal.rejected" }, { cron: "0 8 * * *" }],
+    async ({ event, step }) => {
+      if (event.name === "memory/proposal.approved") {
+        const proposalId = await step.run("resolve-approved-proposal-id", async () => {
+          const id = (event.data as { proposalId?: unknown }).proposalId;
+          if (typeof id !== "string" || id.trim().length === 0) {
+            throw new Error("memory/proposal.approved requires event.data.proposalId");
+          }
+          return id;
+        });
 
-      for (const change of changes.approved) {
-        await promoteToMemory(change.id);
+        await step.run("promote-approved-proposal", async () => promoteToMemory(proposalId));
+        return { approved: [proposalId] };
       }
 
-      for (const change of changes.rejected) {
-        const reason = parsedById.get(change.id)?.state === "deleted" ? "marked-rejected" : "deleted";
-        await archiveProposal(change.id, reason);
-      }
+      if (event.name === "memory/proposal.rejected") {
+        const payload = await step.run("resolve-rejected-payload", async () => {
+          const id = (event.data as { proposalId?: unknown }).proposalId;
+          const reason = (event.data as { reason?: unknown }).reason;
+          if (typeof id !== "string" || id.trim().length === 0) {
+            throw new Error("memory/proposal.rejected requires event.data.proposalId");
+          }
+          if (typeof reason !== "string" || reason.trim().length === 0) {
+            throw new Error("memory/proposal.rejected requires event.data.reason");
+          }
+          return { proposalId: id, reason };
+        });
 
-      for (const change of changes.expired) {
-        await expireProposal(change.id);
+        await step.run("archive-rejected-proposal", async () => archiveProposal(payload.proposalId, payload.reason));
+        return { rejected: [payload.proposalId], reason: payload.reason };
       }
-    });
 
-    const updateState = await step.run("update-state", async () => {
-      const redis = getRedisClient();
-      const nextPending = [...new Set(changes.pending)];
-
-      await redis.del(REVIEW_PENDING_KEY);
-      if (nextPending.length > 0) {
-        await redis.rpush(REVIEW_PENDING_KEY, ...nextPending);
-      }
+      const expiredIds = await step.run("expire-stale-proposals", async () => {
+        const redis = getRedisClient();
+        const pending = await redis.lrange(REVIEW_PENDING_KEY, 0, -1);
+        const expired: string[] = [];
 
-      const parsedById = new Map(parsed.proposals.map((proposal) => [proposal.id, proposal]));
-      for (const id of nextPending) {
-        const existing = previous.proposals[id];
-        const parsedProposal = parsedById.get(id);
-        await redis.hset(
-          proposalKey(id),
-          "id",
-          id,
-          "status",
-          "pending",
-          "state",
-          parsedProposal?.state ?? "unchecked",
-          "capturedAt",
-          existing?.capturedAt ?? new Date().toISOString(),
-          "date",
-          existing?.date ?? new Date().toISOString().slice(0, 10),
-          "section",
-          existing?.section ?? "",
-          "change",
-          existing?.change ?? ""
-        );
-      }
+        for (const proposalId of pending) {
+          if (!isProposalOlderThanSevenDays(proposalId)) continue;
+          await expireProposal(proposalId);
+          expired.push(proposalId);
+        }
 
-      return {
-        pending: nextPending,
-      };
-    });
+        return expired;
+      });
 
-    return {
-      approved: changes.approved.map((item) => item.id),
-      rejected: changes.rejected.map((item) => item.id),
-      expired: changes.expired.map((item) => item.id),
-      pending: updateState.pending,
-    };
-  }
+      return { expired: expiredIds };
+    }
   )
 );
 


thinking
**Inspecting test file changes**
exec
/bin/zsh -lc "nl -ba packages/system-bus/src/inngest/functions/promote.ts | sed -n '1,260p'" in /private/tmp/agent-loop/loop-mlr8oxtg-b68bp4exec
/bin/zsh -lc "nl -ba packages/system-bus/src/inngest/functions/promote.ts | sed -n '260,420p'" in /private/tmp/agent-loop/loop-mlr8oxtg-b68bp4exec
/bin/zsh -lc "nl -ba packages/system-bus/src/inngest/functions/promote-integration.test.ts | sed -n '220,340p'" in /private/tmp/agent-loop/loop-mlr8oxtg-b68bp4 succeeded in 52ms:
     1	import { join } from "node:path";
     2	import { mkdir, rename } from "node:fs/promises";
     3	import Redis from "ioredis";
     4	import { inngest } from "../client";
     5	import { PROMOTE_SYSTEM_PROMPT, PROMOTE_USER_PROMPT } from "./promote-prompt";
     6	
     7	type RedisLike = {
     8	  lrange(key: string, start: number, stop: number): Promise<string[]>;
     9	  hgetall(key: string): Promise<Record<string, string>>;
    10	  lrem(key: string, count: number, value: string): Promise<unknown>;
    11	  del(key: string): Promise<unknown>;
    12	};
    13	
    14	const REVIEW_PENDING_KEY = "memory:review:pending";
    15	const MEMORY_FILE_NAME = "MEMORY.md";
    16	const SEVEN_DAYS_MS = 7 * 24 * 60 * 60 * 1000;
    17	const REJECTED_PROPOSALS_HEADER = "### Rejected Proposals";
    18	const EXPIRED_PROPOSALS_HEADER = "### Expired Proposals";
    19	
    20	let redisClient: Redis | null = null;
 succeeded in 53ms:
   220	});
   221	
   222	describe("MEM-22 promote integration acceptance test", () => {
   223	  test("runs end-to-end promotion workflow through event-driven handlers with no proposal loss", async () => {
   224	    const approvedId = proposalIdDaysAgo(1, "101");
   225	    const deletedId = proposalIdDaysAgo(1, "102");
   226	    const expiredId = proposalIdDaysAgo(8, "103");
   227	    const activePendingId = proposalIdDaysAgo(2, "104");
   228	
   229	    const approvedText = "Hard rule: preserve externally observable behavior in acceptance tests.";
   230	    const deletedText = "Architecture note removed during review.";
   231	    const expiredText = "Pattern proposal that expired after remaining unchecked for 8 days.";
   232	    const activePendingText = "Recent unchecked proposal should stay pending.";
   233	
   234	    redisState.lists.set("memory:review:pending", [approvedId, deletedId, expiredId, activePendingId]);
   235	
   236	    putProposal(approvedId, {
   237	      targetSection: "Hard Rules",
   238	      proposedText: approvedText,
   239	      capturedAt: new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString(),
 succeeded in 53ms:
   260	  const memoryFile = Bun.file(memoryPath);
   261	  const memoryMarkdown = await memoryFile.text();
   262	  const promotedText = await formatProposalForMemoryIfNeeded(section, proposedText, memoryMarkdown);
   263	  const nextMemoryMarkdown = appendBulletToSection(memoryMarkdown, section, `- (${date}) ${promotedText}`);
   264	
   265	  const tmpPath = `${memoryPath}.tmp`;
   266	  await Bun.write(tmpPath, nextMemoryMarkdown);
   267	  await rename(tmpPath, memoryPath);
   268	
   269	  const logPath = getMemoryLogPath(date);
   270	  await mkdir(join(process.env.HOME || process.env.USERPROFILE || "/Users/joel", ".joelclaw", "workspace", "memory"), {
   271	    recursive: true,
   272	  });
   273	  const existingLog = await Bun.file(logPath).text().catch(() => "");
   274	  const logLine = `- promoted ${proposalId} -> ${section}: ${promotedText}`;
   275	  const nextLog = `${existingLog}${existingLog.length > 0 && !existingLog.endsWith("\n") ? "\n" : ""}${logLine}\n`;
   276	  await Bun.write(logPath, nextLog);
   277	
   278	  await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   279	  await redis.del(key);
file update:
diff --git a/packages/system-bus/src/inngest/functions/promote-integration.test.ts b/packages/system-bus/src/inngest/functions/promote-integration.test.ts
index ec552d8c5c0beb8271678d6aa7d39ccf1cdcb9e3..4fb7794ef87210aadf98f05d3d468912e127df10
--- a/packages/system-bus/src/inngest/functions/promote-integration.test.ts
+++ b/packages/system-bus/src/inngest/functions/promote-integration.test.ts
@@ -29,7 +29,6 @@
 
 let tempHome = "";
 let workspaceDir = "";
-let reviewPath = "";
 let memoryPath = "";
 
 function proposalKey(id: string): string {
@@ -189,7 +188,6 @@
   process.env.USERPROFILE = tempHome;
 
   workspaceDir = join(tempHome, ".joelclaw", "workspace");
-  reviewPath = join(workspaceDir, "REVIEW.md");
   memoryPath = join(workspaceDir, "MEMORY.md");
 
   mkdirSync(join(workspaceDir, "memory"), { recursive: true });
@@ -222,7 +220,7 @@
 });
 
 describe("MEM-22 promote integration acceptance test", () => {
-  test("runs end-to-end promotion workflow from REVIEW.md to MEMORY.md with no proposal loss", async () => {
+  test("runs end-to-end promotion workflow through event-driven handlers with no proposal loss", async () => {
     const approvedId = proposalIdDaysAgo(1, "101");
     const deletedId = proposalIdDaysAgo(1, "102");
     const expiredId = proposalIdDaysAgo(8, "103");
@@ -256,33 +254,32 @@
       capturedAt: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(),
     });
 
-    writeFileSync(
-      reviewPath,
-      [
-        "# REVIEW",
-        "",
-        `- [x] ${approvedId}: ${approvedText}`,
-        `- [ ] ${expiredId}: ${expiredText}`,
-        `- [ ] ${activePendingId}: ${activePendingText}`,
-        "",
-      ].join("\n")
-    );
-
-    const { result } = await executePromoteWithEvent({
-      name: "content/updated",
-      data: { path: reviewPath },
+    const { result: approvedResult } = await executePromoteWithEvent({
+      name: "memory/proposal.approved",
+      data: { proposalId: approvedId },
+    });
+    const { result: rejectedResult } = await executePromoteWithEvent({
+      name: "memory/proposal.rejected",
+      data: { proposalId: deletedId, reason: "deleted" },
+    });
+    const { result: expiredResult } = await executePromoteWithEvent({
+      name: "inngest/scheduled.timer",
+      data: { cron: "0 8 * * *" },
     });
 
     const memory = readFileSync(memoryPath, "utf8");
     const hardRules = getSectionBlock(memory, "Hard Rules");
     const log = readFileSync(todayLogPath(), "utf8");
-    const review = readFileSync(reviewPath, "utf8");
 
-    expect(result).toMatchObject({
+    expect(approvedResult).toMatchObject({
       approved: [approvedId],
+    });
+    expect(rejectedResult).toMatchObject({
       rejected: [deletedId],
+      reason: "deleted",
+    });
+    expect(expiredResult).toMatchObject({
       expired: [expiredId],
-      pending: [activePendingId],
     });
 
     expect(hardRules).toContain(`- (${proposalDateFromId(approvedId)})`);
@@ -296,11 +293,6 @@
     expect(redisState.hashes.has(proposalKey(approvedId))).toBe(false);
     expect(redisState.hashes.has(proposalKey(deletedId))).toBe(false);
     expect(redisState.hashes.has(proposalKey(expiredId))).toBe(false);
-
-    expect(review).toContain(activePendingId);
-    expect(review).not.toContain(approvedId);
-    expect(review).not.toContain(deletedId);
-    expect(review).not.toContain(expiredId);
 
     expect({
       approvedInMemory: hardRules.includes(`- (${proposalDateFromId(approvedId)})`),
diff --git a/packages/system-bus/src/inngest/functions/promote.ts b/packages/system-bus/src/inngest/functions/promote.ts
index 09730ecff690b4bfba745ef6f7b0a7469122608c..4fa05b25f8a9810e0b2052835bcfe45293b19d41
--- a/packages/system-bus/src/inngest/functions/promote.ts
+++ b/packages/system-bus/src/inngest/functions/promote.ts
@@ -4,56 +4,14 @@
 import { inngest } from "../client";
 import { PROMOTE_SYSTEM_PROMPT, PROMOTE_USER_PROMPT } from "./promote-prompt";
 
-export type ProposalState = "checked" | "unchecked" | "deleted";
-
-export type ParsedReviewProposal = {
-  id: string;
-  state: ProposalState;
-};
-
-export type ParsedReview = {
-  proposals: ParsedReviewProposal[];
-};
-
-export type StoredProposal = {
-  id: string;
-  status: string;
-  capturedAt?: string;
-  date?: string;
-  section?: string;
-  change?: string;
-};
-
-export type ProposalStateSnapshot = {
-  pending: string[];
-  proposals: Record<string, StoredProposal>;
-};
-
-export type ProposalChange = {
-  id: string;
-  proposal?: StoredProposal;
-};
-
-export type ProposalDiff = {
-  approved: ProposalChange[];
-  rejected: ProposalChange[];
-  expired: ProposalChange[];
-  unchanged: ProposalChange[];
-  pending: string[];
-};
-
 type RedisLike = {
   lrange(key: string, start: number, stop: number): Promise<string[]>;
   hgetall(key: string): Promise<Record<string, string>>;
-  hset(key: string, ...args: string[]): Promise<unknown>;
   lrem(key: string, count: number, value: string): Promise<unknown>;
   del(key: string): Promise<unknown>;
-  rpush(key: string, ...values: string[]): Promise<unknown>;
 };
 
 const REVIEW_PENDING_KEY = "memory:review:pending";
-const REVIEW_PATH_FILTER = "~/.joelclaw/workspace/REVIEW.md";
-const REVIEW_FILE_NAME = "REVIEW.md";
 const MEMORY_FILE_NAME = "MEMORY.md";
 const SEVEN_DAYS_MS = 7 * 24 * 60 * 60 * 1000;
 const REJECTED_PROPOSALS_HEADER = "### Rejected Proposals";
@@ -73,11 +31,6 @@
     redisClient.on("error", () => {});
   }
   return redisClient;
-}
-
-function getReviewPath(): string {
-  const home = process.env.HOME || process.env.USERPROFILE || "/Users/joel";
-  return join(home, ".joelclaw", "workspace", REVIEW_FILE_NAME);
 }
 
 function getMemoryPath(): string {
@@ -121,10 +74,6 @@
   return date;
 }
 
-function escapeRegex(value: string): string {
-  return value.replace(/[.*+?^${}()|[\]\\]/gu, "\\$&");
-}
-
 function appendEntryToLogSection(markdown: string, header: string, entry: string): string {
   const lines = markdown.length > 0 ? markdown.split(/\r?\n/u) : [];
   const normalizedLines = [...lines];
@@ -160,20 +109,6 @@
   await Bun.write(logPath, next);
 }
 
-async function removeProposalFromReview(proposalId: string): Promise<void> {
-  const reviewPath = getReviewPath();
-  const reviewFile = Bun.file(reviewPath);
-  if (!(await reviewFile.exists())) return;
-
-  const markdown = await reviewFile.text();
-  const pattern = new RegExp(`^\\s*-\\s*\\[( |x|X|-)\\]\\s*${escapeRegex(proposalId)}\\b`, "u");
-  const nextLines = markdown.split(/\r?\n/u).filter((line) => !pattern.test(line));
-  const next = `${nextLines.join("\n").replace(/\n*$/u, "")}\n`;
-  if (next !== markdown) {
-    await Bun.write(reviewPath, next);
-  }
-}
-
 function isProposalOlderThanSevenDays(proposalId: string, now: Date = new Date()): boolean {
   const proposalDate = parseDateFromProposalId(proposalId);
   if (!proposalDate) return false;
@@ -278,114 +213,8 @@
     .find((line) => line.length > 0);
 
   return formatted ?? proposedText;
-}
-
-function parseState(raw: string): ProposalState | null {
-  const value = raw.trim().toLowerCase();
-  if (value === "x") return "checked";
-  if (value === "-") return "deleted";
-  if (value === "") return "unchecked";
-  return null;
-}
-
-function parseCurrentState(currentState: unknown): Map<string, ProposalState> {
-  const map = new Map<string, ProposalState>();
-
-  if (!currentState || typeof currentState !== "object") return map;
-  const proposals = (currentState as { proposals?: unknown }).proposals;
-  if (!Array.isArray(proposals)) return map;
-
-  for (const proposal of proposals) {
-    if (!proposal || typeof proposal !== "object") continue;
-    const id = (proposal as { id?: unknown }).id;
-    const state = (proposal as { state?: unknown }).state;
-    if (typeof id !== "string") continue;
-    if (state === "checked" || state === "unchecked" || state === "deleted") {
-      map.set(id, state);
-    }
-  }
-
-  return map;
-}
-
-function isExpired(capturedAt: string | undefined, now: Date): boolean {
-  if (!capturedAt) return false;
-  const created = new Date(capturedAt);
-  if (Number.isNaN(created.getTime())) return false;
-  return now.getTime() - created.getTime() >= SEVEN_DAYS_MS;
 }
-
-function extractContentPath(eventData: unknown): string | null {
-  if (!eventData || typeof eventData !== "object") return null;
-  const rec = eventData as Record<string, unknown>;
-
-  const candidates = [rec.path, rec.filePath, rec.filepath];
-  for (const candidate of candidates) {
-    if (typeof candidate === "string" && candidate.length > 0) {
-      return candidate;
-    }
-  }
-
-  return null;
-}
-
-function createStableDiff(
-  approved: ProposalChange[],
-  rejected: ProposalChange[],
-  expired: ProposalChange[],
-  unchanged: ProposalChange[],
-  pending: string[]
-): ProposalDiff {
-  const data = {
-    approved,
-    rejected,
-    expired,
-    unchanged,
-    pending,
-  } satisfies ProposalDiff;
 
-  return new Proxy({} as ProposalDiff, {
-    get(_, property) {
-      if (property === "approved") return data.approved.map((item) => ({ ...item }));
-      if (property === "rejected") return data.rejected.map((item) => ({ ...item }));
-      if (property === "expired") return data.expired.map((item) => ({ ...item }));
-      if (property === "unchanged") return data.unchanged.map((item) => ({ ...item }));
-      if (property === "pending") return [...data.pending];
-      return undefined;
-    },
-    set() {
-      return true;
-    },
-    has(_, property) {
-      return (
-        property === "approved" ||
-        property === "rejected" ||
-        property === "expired" ||
-        property === "unchanged" ||
-        property === "pending"
-      );
-    },
-    ownKeys() {
-      return ["approved", "rejected", "expired", "unchanged", "pending"];
-    },
-    getOwnPropertyDescriptor(_, property) {
-      if (
-        property === "approved" ||
-        property === "rejected" ||
-        property === "expired" ||
-        property === "unchanged" ||
-        property === "pending"
-      ) {
-        return {
-          enumerable: true,
-          configurable: true,
-        };
-      }
-      return undefined;
-    },
-  });
-}
-
 function stabilizeFunctionOpts<T extends { opts?: Record<string, unknown> }>(fn: T): T {
   const original = fn.opts;
   if (!original) return fn;
@@ -414,92 +243,7 @@
     },
   });
 }
-
-export function parseReviewMd(markdown: string): ParsedReview {
-  const proposals: ParsedReviewProposal[] = [];
 
-  const lines = markdown.split(/\r?\n/u);
-  for (const line of lines) {
-    const match = /^\s*-\s*\[( |x|X|-)\]\s*(p-\d{8}-\d{3,})\b/u.exec(line);
-    if (!match?.[1] || !match[2]) continue;
-
-    const state = parseState(match[1]);
-    if (!state) continue;
-
-    proposals.push({
-      id: match[2],
-      state,
-    });
-  }
-
-  return { proposals };
-}
-
-export async function loadProposalState(redis: Pick<RedisLike, "lrange" | "hgetall">): Promise<ProposalStateSnapshot> {
-  const pending = await redis.lrange(REVIEW_PENDING_KEY, 0, -1);
-  const proposals: Record<string, StoredProposal> = {};
-
-  for (const id of pending) {
-    const stored = await redis.hgetall(proposalKey(id));
-    proposals[id] = {
-      id,
-      status: stored.status ?? "pending",
-      capturedAt: stored.capturedAt,
-      date: stored.date,
-      section: stored.section,
-      change: stored.change,
-    };
-  }
-
-  return { pending, proposals };
-}
-
-export function detectChanges(
-  currentState: unknown,
-  previousState: ProposalStateSnapshot,
-  now: Date = new Date()
-): ProposalDiff {
-  const current = parseCurrentState(currentState);
-  const approved: ProposalChange[] = [];
-  const rejected: ProposalChange[] = [];
-  const expired: ProposalChange[] = [];
-  const unchanged: ProposalChange[] = [];
-  const pending: string[] = [];
-
-  for (const id of previousState.pending) {
-    const proposal = previousState.proposals[id] ?? { id, status: "pending" };
-    const currentProposalState = current.get(id);
-
-    if (currentProposalState === "checked") {
-      approved.push({ id, proposal });
-      continue;
-    }
-
-    if (currentProposalState === "deleted" || currentProposalState === undefined) {
-      rejected.push({ id, proposal });
-      continue;
-    }
-
-    if (isExpired(proposal.capturedAt, now)) {
-      expired.push({ id, proposal });
-      continue;
-    }
-
-    unchanged.push({ id, proposal });
-    pending.push(id);
-  }
-
-  for (const [id, state] of current.entries()) {
-    if (previousState.pending.includes(id)) continue;
-    if (state === "unchecked") {
-      unchanged.push({ id, proposal: previousState.proposals[id] ?? { id, status: "pending" } });
-      pending.push(id);
-    }
-  }
-
-  return createStableDiff(approved, rejected, expired, unchanged, pending);
-}
-
 export async function promoteToMemory(proposalId: string): Promise<void> {
   const redis = getRedisClient();
   const key = proposalKey(proposalId);
@@ -533,10 +277,9 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
-export async function archiveProposal(proposalId: string, reason: "deleted" | "marked-rejected"): Promise<void> {
+export async function archiveProposal(proposalId: string, reason: string): Promise<void> {
   const redis = getRedisClient();
   const key = proposalKey(proposalId);
   const proposal = await redis.hgetall(key);
@@ -549,7 +292,6 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
 export async function expireProposal(proposalId: string): Promise<void> {
@@ -567,115 +309,62 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
 const promoteFunction = stabilizeFunctionOpts(
   inngest.createFunction(
-  {
-    id: "memory/review-promote",
-    name: "Promote Review Decisions",
-  },
-  [
     {
-      event: "content/updated",
-      if: `event.data.path == \"${REVIEW_PATH_FILTER}\" || event.data.path.endsWith(\"/${REVIEW_FILE_NAME}\")`,
+      id: "memory/review-promote",
+      name: "Promote Review Decisions",
     },
-    { cron: "0 8 * * *" },
-  ],
-  async ({ event, step }) => {
-    const shouldSkip = await step.run("filter-review-events", async () => {
-      if (event.name !== "content/updated") return false;
-      const updatedPath = extractContentPath(event.data);
-      if (!updatedPath) return false;
-      return !updatedPath.toLowerCase().endsWith(`/${REVIEW_FILE_NAME.toLowerCase()}`);
-    });
-
-    if (shouldSkip) {
-      return {
-        skipped: true,
-        reason: "content/updated path does not target REVIEW.md",
-      };
-    }
-
-    const parsed = await step.run("parse-review", async () => {
-      const reviewFile = Bun.file(getReviewPath());
-      if (!(await reviewFile.exists())) {
-        return { proposals: [] } as ParsedReview;
-      }
-
-      const markdown = await reviewFile.text();
-      return parseReviewMd(markdown);
-    });
-
-    const previous = await step.run("load-state", async () => {
-      const redis = getRedisClient();
-      return loadProposalState(redis);
-    });
-
-    const changes = await step.run("detect-changes", async () => detectChanges(parsed, previous));
-
-    await step.run("route", async () => {
-      const parsedById = new Map(parsed.proposals.map((proposal) => [proposal.id, proposal]));
+    [{ event: "memory/proposal.approved" }, { event: "memory/proposal.rejected" }, { cron: "0 8 * * *" }],
+    async ({ event, step }) => {
+      if (event.name === "memory/proposal.approved") {
+        const proposalId = await step.run("resolve-approved-proposal-id", async () => {
+          const id = (event.data as { proposalId?: unknown }).proposalId;
+          if (typeof id !== "string" || id.trim().length === 0) {
+            throw new Error("memory/proposal.approved requires event.data.proposalId");
+          }
+          return id;
+        });
 
-      for (const change of changes.approved) {
-        await promoteToMemory(change.id);
+        await step.run("promote-approved-proposal", async () => promoteToMemory(proposalId));
+        return { approved: [proposalId] };
       }
 
-      for (const change of changes.rejected) {
-        const reason = parsedById.get(change.id)?.state === "deleted" ? "marked-rejected" : "deleted";
-        await archiveProposal(change.id, reason);
-      }
+      if (event.name === "memory/proposal.rejected") {
+        const payload = await step.run("resolve-rejected-payload", async () => {
+          const id = (event.data as { proposalId?: unknown }).proposalId;
+          const reason = (event.data as { reason?: unknown }).reason;
+          if (typeof id !== "string" || id.trim().length === 0) {
+            throw new Error("memory/proposal.rejected requires event.data.proposalId");
+          }
+          if (typeof reason !== "string" || reason.trim().length === 0) {
+            throw new Error("memory/proposal.rejected requires event.data.reason");
+          }
+          return { proposalId: id, reason };
+        });
 
-      for (const change of changes.expired) {
-        await expireProposal(change.id);
+        await step.run("archive-rejected-proposal", async () => archiveProposal(payload.proposalId, payload.reason));
+        return { rejected: [payload.proposalId], reason: payload.reason };
       }
-    });
 
-    const updateState = await step.run("update-state", async () => {
-      const redis = getRedisClient();
-      const nextPending = [...new Set(changes.pending)];
-
-      await redis.del(REVIEW_PENDING_KEY);
-      if (nextPending.length > 0) {
-        await redis.rpush(REVIEW_PENDING_KEY, ...nextPending);
-      }
+      const expiredIds = await step.run("expire-stale-proposals", async () => {
+        const redis = getRedisClient();
+        const pending = await redis.lrange(REVIEW_PENDING_KEY, 0, -1);
+        const expired: string[] = [];
 
-      const parsedById = new Map(parsed.proposals.map((proposal) => [proposal.id, proposal]));
-      for (const id of nextPending) {
-        const existing = previous.proposals[id];
-        const parsedProposal = parsedById.get(id);
-        await redis.hset(
-          proposalKey(id),
-          "id",
-          id,
-          "status",
-          "pending",
-          "state",
-          parsedProposal?.state ?? "unchecked",
-          "capturedAt",
-          existing?.capturedAt ?? new Date().toISOString(),
-          "date",
-          existing?.date ?? new Date().toISOString().slice(0, 10),
-          "section",
-          existing?.section ?? "",
-          "change",
-          existing?.change ?? ""
-        );
-      }
+        for (const proposalId of pending) {
+          if (!isProposalOlderThanSevenDays(proposalId)) continue;
+          await expireProposal(proposalId);
+          expired.push(proposalId);
+        }
 
-      return {
-        pending: nextPending,
-      };
-    });
+        return expired;
+      });
 
-    return {
-      approved: changes.approved.map((item) => item.id),
-      rejected: changes.rejected.map((item) => item.id),
-      expired: changes.expired.map((item) => item.id),
-      pending: updateState.pending,
-    };
-  }
+      return { expired: expiredIds };
+    }
   )
 );
 


thinking
**Summarizing final changes and test results**
codex
Implemented MEM-3 with event-driven promotion flow.

### What changed

- Rewrote `packages/system-bus/src/inngest/functions/promote.ts` to remove all REVIEW parsing/file coupling:
  - Removed `parseReviewMd`, `getReviewPath`, `removeProposalFromReview`, `extractContentPath`.
  - Removed all `content/updated` trigger logic.
  - Removed all `removeProposalFromReview()` calls from:
    - `promoteToMemory` (`packages/system-bus/src/inngest/functions/promote.ts:247`)
    - `archiveProposal` (`packages/system-bus/src/inngest/functions/promote.ts:282`)
    - `expireProposal` (`packages/system-bus/src/inngest/functions/promote.ts:297`)
- Added event-driven triggers on the `promote` Inngest function:
  - `memory/proposal.approved` -> `promoteToMemory(event.data.proposalId)` (`packages/system-bus/src/inngest/functions/promote.ts:320`)
  - `memory/proposal.rejected` -> `archiveProposal(event.data.proposalId, event.data.reason)` (`packages/system-bus/src/inngest/functions/promote.ts:320`)
- Retained cron trigger:
  - `0 8 * * *` and it now iterates `LRANGE memory:review:pending`, calling `expireProposal()` for IDs older than 7 days (`packages/system-bus/src/inngest/functions/promote.ts:352`)
- Ensured public exports remain:
  - `promoteToMemory`, `archiveProposal`, `expireProposal` are exported (`packages/system-bus/src/inngest/functions/promote.ts:247`, `packages/system-bus/src/inngest/functions/promote.ts:282`, `packages/system-bus/src/inngest/functions/promote.ts:297`)

### Test updates

- `packages/system-bus/src/inngest/functions/promote.test.ts` is already aligned to the new event-driven trigger behavior.
- Updated legacy integration coverage to the new interface:
  - `packages/system-bus/src/inngest/functions/promote-integration.test.ts:223`
  - Now drives approved/rejected/cron events instead of `content/updated`.

### Verification

- `bun test packages/system-bus/src/inngest/functions/promote.test.ts` -> **6 pass, 0 fail**
- `bunx tsc --noEmit` -> **passes cleanly**
- Also checked:
  - `bun test packages/system-bus/src/inngest/functions/promote-integration.test.ts` -> **1 pass, 0 fail**
file update:
diff --git a/packages/system-bus/src/inngest/functions/promote-integration.test.ts b/packages/system-bus/src/inngest/functions/promote-integration.test.ts
index ec552d8c5c0beb8271678d6aa7d39ccf1cdcb9e3..4fb7794ef87210aadf98f05d3d468912e127df10
--- a/packages/system-bus/src/inngest/functions/promote-integration.test.ts
+++ b/packages/system-bus/src/inngest/functions/promote-integration.test.ts
@@ -29,7 +29,6 @@
 
 let tempHome = "";
 let workspaceDir = "";
-let reviewPath = "";
 let memoryPath = "";
 
 function proposalKey(id: string): string {
@@ -189,7 +188,6 @@
   process.env.USERPROFILE = tempHome;
 
   workspaceDir = join(tempHome, ".joelclaw", "workspace");
-  reviewPath = join(workspaceDir, "REVIEW.md");
   memoryPath = join(workspaceDir, "MEMORY.md");
 
   mkdirSync(join(workspaceDir, "memory"), { recursive: true });
@@ -222,7 +220,7 @@
 });
 
 describe("MEM-22 promote integration acceptance test", () => {
-  test("runs end-to-end promotion workflow from REVIEW.md to MEMORY.md with no proposal loss", async () => {
+  test("runs end-to-end promotion workflow through event-driven handlers with no proposal loss", async () => {
     const approvedId = proposalIdDaysAgo(1, "101");
     const deletedId = proposalIdDaysAgo(1, "102");
     const expiredId = proposalIdDaysAgo(8, "103");
@@ -256,33 +254,32 @@
       capturedAt: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(),
     });
 
-    writeFileSync(
-      reviewPath,
-      [
-        "# REVIEW",
-        "",
-        `- [x] ${approvedId}: ${approvedText}`,
-        `- [ ] ${expiredId}: ${expiredText}`,
-        `- [ ] ${activePendingId}: ${activePendingText}`,
-        "",
-      ].join("\n")
-    );
-
-    const { result } = await executePromoteWithEvent({
-      name: "content/updated",
-      data: { path: reviewPath },
+    const { result: approvedResult } = await executePromoteWithEvent({
+      name: "memory/proposal.approved",
+      data: { proposalId: approvedId },
+    });
+    const { result: rejectedResult } = await executePromoteWithEvent({
+      name: "memory/proposal.rejected",
+      data: { proposalId: deletedId, reason: "deleted" },
+    });
+    const { result: expiredResult } = await executePromoteWithEvent({
+      name: "inngest/scheduled.timer",
+      data: { cron: "0 8 * * *" },
     });
 
     const memory = readFileSync(memoryPath, "utf8");
     const hardRules = getSectionBlock(memory, "Hard Rules");
     const log = readFileSync(todayLogPath(), "utf8");
-    const review = readFileSync(reviewPath, "utf8");
 
-    expect(result).toMatchObject({
+    expect(approvedResult).toMatchObject({
       approved: [approvedId],
+    });
+    expect(rejectedResult).toMatchObject({
       rejected: [deletedId],
+      reason: "deleted",
+    });
+    expect(expiredResult).toMatchObject({
       expired: [expiredId],
-      pending: [activePendingId],
     });
 
     expect(hardRules).toContain(`- (${proposalDateFromId(approvedId)})`);
@@ -296,11 +293,6 @@
     expect(redisState.hashes.has(proposalKey(approvedId))).toBe(false);
     expect(redisState.hashes.has(proposalKey(deletedId))).toBe(false);
     expect(redisState.hashes.has(proposalKey(expiredId))).toBe(false);
-
-    expect(review).toContain(activePendingId);
-    expect(review).not.toContain(approvedId);
-    expect(review).not.toContain(deletedId);
-    expect(review).not.toContain(expiredId);
 
     expect({
       approvedInMemory: hardRules.includes(`- (${proposalDateFromId(approvedId)})`),
diff --git a/packages/system-bus/src/inngest/functions/promote.ts b/packages/system-bus/src/inngest/functions/promote.ts
index 09730ecff690b4bfba745ef6f7b0a7469122608c..4fa05b25f8a9810e0b2052835bcfe45293b19d41
--- a/packages/system-bus/src/inngest/functions/promote.ts
+++ b/packages/system-bus/src/inngest/functions/promote.ts
@@ -4,56 +4,14 @@
 import { inngest } from "../client";
 import { PROMOTE_SYSTEM_PROMPT, PROMOTE_USER_PROMPT } from "./promote-prompt";
 
-export type ProposalState = "checked" | "unchecked" | "deleted";
-
-export type ParsedReviewProposal = {
-  id: string;
-  state: ProposalState;
-};
-
-export type ParsedReview = {
-  proposals: ParsedReviewProposal[];
-};
-
-export type StoredProposal = {
-  id: string;
-  status: string;
-  capturedAt?: string;
-  date?: string;
-  section?: string;
-  change?: string;
-};
-
-export type ProposalStateSnapshot = {
-  pending: string[];
-  proposals: Record<string, StoredProposal>;
-};
-
-export type ProposalChange = {
-  id: string;
-  proposal?: StoredProposal;
-};
-
-export type ProposalDiff = {
-  approved: ProposalChange[];
-  rejected: ProposalChange[];
-  expired: ProposalChange[];
-  unchanged: ProposalChange[];
-  pending: string[];
-};
-
 type RedisLike = {
   lrange(key: string, start: number, stop: number): Promise<string[]>;
   hgetall(key: string): Promise<Record<string, string>>;
-  hset(key: string, ...args: string[]): Promise<unknown>;
   lrem(key: string, count: number, value: string): Promise<unknown>;
   del(key: string): Promise<unknown>;
-  rpush(key: string, ...values: string[]): Promise<unknown>;
 };
 
 const REVIEW_PENDING_KEY = "memory:review:pending";
-const REVIEW_PATH_FILTER = "~/.joelclaw/workspace/REVIEW.md";
-const REVIEW_FILE_NAME = "REVIEW.md";
 const MEMORY_FILE_NAME = "MEMORY.md";
 const SEVEN_DAYS_MS = 7 * 24 * 60 * 60 * 1000;
 const REJECTED_PROPOSALS_HEADER = "### Rejected Proposals";
@@ -73,11 +31,6 @@
     redisClient.on("error", () => {});
   }
   return redisClient;
-}
-
-function getReviewPath(): string {
-  const home = process.env.HOME || process.env.USERPROFILE || "/Users/joel";
-  return join(home, ".joelclaw", "workspace", REVIEW_FILE_NAME);
 }
 
 function getMemoryPath(): string {
@@ -121,10 +74,6 @@
   return date;
 }
 
-function escapeRegex(value: string): string {
-  return value.replace(/[.*+?^${}()|[\]\\]/gu, "\\$&");
-}
-
 function appendEntryToLogSection(markdown: string, header: string, entry: string): string {
   const lines = markdown.length > 0 ? markdown.split(/\r?\n/u) : [];
   const normalizedLines = [...lines];
@@ -160,20 +109,6 @@
   await Bun.write(logPath, next);
 }
 
-async function removeProposalFromReview(proposalId: string): Promise<void> {
-  const reviewPath = getReviewPath();
-  const reviewFile = Bun.file(reviewPath);
-  if (!(await reviewFile.exists())) return;
-
-  const markdown = await reviewFile.text();
-  const pattern = new RegExp(`^\\s*-\\s*\\[( |x|X|-)\\]\\s*${escapeRegex(proposalId)}\\b`, "u");
-  const nextLines = markdown.split(/\r?\n/u).filter((line) => !pattern.test(line));
-  const next = `${nextLines.join("\n").replace(/\n*$/u, "")}\n`;
-  if (next !== markdown) {
-    await Bun.write(reviewPath, next);
-  }
-}
-
 function isProposalOlderThanSevenDays(proposalId: string, now: Date = new Date()): boolean {
   const proposalDate = parseDateFromProposalId(proposalId);
   if (!proposalDate) return false;
@@ -278,114 +213,8 @@
     .find((line) => line.length > 0);
 
   return formatted ?? proposedText;
-}
-
-function parseState(raw: string): ProposalState | null {
-  const value = raw.trim().toLowerCase();
-  if (value === "x") return "checked";
-  if (value === "-") return "deleted";
-  if (value === "") return "unchecked";
-  return null;
-}
-
-function parseCurrentState(currentState: unknown): Map<string, ProposalState> {
-  const map = new Map<string, ProposalState>();
-
-  if (!currentState || typeof currentState !== "object") return map;
-  const proposals = (currentState as { proposals?: unknown }).proposals;
-  if (!Array.isArray(proposals)) return map;
-
-  for (const proposal of proposals) {
-    if (!proposal || typeof proposal !== "object") continue;
-    const id = (proposal as { id?: unknown }).id;
-    const state = (proposal as { state?: unknown }).state;
-    if (typeof id !== "string") continue;
-    if (state === "checked" || state === "unchecked" || state === "deleted") {
-      map.set(id, state);
-    }
-  }
-
-  return map;
-}
-
-function isExpired(capturedAt: string | undefined, now: Date): boolean {
-  if (!capturedAt) return false;
-  const created = new Date(capturedAt);
-  if (Number.isNaN(created.getTime())) return false;
-  return now.getTime() - created.getTime() >= SEVEN_DAYS_MS;
 }
-
-function extractContentPath(eventData: unknown): string | null {
-  if (!eventData || typeof eventData !== "object") return null;
-  const rec = eventData as Record<string, unknown>;
-
-  const candidates = [rec.path, rec.filePath, rec.filepath];
-  for (const candidate of candidates) {
-    if (typeof candidate === "string" && candidate.length > 0) {
-      return candidate;
-    }
-  }
-
-  return null;
-}
-
-function createStableDiff(
-  approved: ProposalChange[],
-  rejected: ProposalChange[],
-  expired: ProposalChange[],
-  unchanged: ProposalChange[],
-  pending: string[]
-): ProposalDiff {
-  const data = {
-    approved,
-    rejected,
-    expired,
-    unchanged,
-    pending,
-  } satisfies ProposalDiff;
 
-  return new Proxy({} as ProposalDiff, {
-    get(_, property) {
-      if (property === "approved") return data.approved.map((item) => ({ ...item }));
-      if (property === "rejected") return data.rejected.map((item) => ({ ...item }));
-      if (property === "expired") return data.expired.map((item) => ({ ...item }));
-      if (property === "unchanged") return data.unchanged.map((item) => ({ ...item }));
-      if (property === "pending") return [...data.pending];
-      return undefined;
-    },
-    set() {
-      return true;
-    },
-    has(_, property) {
-      return (
-        property === "approved" ||
-        property === "rejected" ||
-        property === "expired" ||
-        property === "unchanged" ||
-        property === "pending"
-      );
-    },
-    ownKeys() {
-      return ["approved", "rejected", "expired", "unchanged", "pending"];
-    },
-    getOwnPropertyDescriptor(_, property) {
-      if (
-        property === "approved" ||
-        property === "rejected" ||
-        property === "expired" ||
-        property === "unchanged" ||
-        property === "pending"
-      ) {
-        return {
-          enumerable: true,
-          configurable: true,
-        };
-      }
-      return undefined;
-    },
-  });
-}
-
 function stabilizeFunctionOpts<T extends { opts?: Record<string, unknown> }>(fn: T): T {
   const original = fn.opts;
   if (!original) return fn;
@@ -414,92 +243,7 @@
     },
   });
 }
-
-export function parseReviewMd(markdown: string): ParsedReview {
-  const proposals: ParsedReviewProposal[] = [];
 
-  const lines = markdown.split(/\r?\n/u);
-  for (const line of lines) {
-    const match = /^\s*-\s*\[( |x|X|-)\]\s*(p-\d{8}-\d{3,})\b/u.exec(line);
-    if (!match?.[1] || !match[2]) continue;
-
-    const state = parseState(match[1]);
-    if (!state) continue;
-
-    proposals.push({
-      id: match[2],
-      state,
-    });
-  }
-
-  return { proposals };
-}
-
-export async function loadProposalState(redis: Pick<RedisLike, "lrange" | "hgetall">): Promise<ProposalStateSnapshot> {
-  const pending = await redis.lrange(REVIEW_PENDING_KEY, 0, -1);
-  const proposals: Record<string, StoredProposal> = {};
-
-  for (const id of pending) {
-    const stored = await redis.hgetall(proposalKey(id));
-    proposals[id] = {
-      id,
-      status: stored.status ?? "pending",
-      capturedAt: stored.capturedAt,
-      date: stored.date,
-      section: stored.section,
-      change: stored.change,
-    };
-  }
-
-  return { pending, proposals };
-}
-
-export function detectChanges(
-  currentState: unknown,
-  previousState: ProposalStateSnapshot,
-  now: Date = new Date()
-): ProposalDiff {
-  const current = parseCurrentState(currentState);
-  const approved: ProposalChange[] = [];
-  const rejected: ProposalChange[] = [];
-  const expired: ProposalChange[] = [];
-  const unchanged: ProposalChange[] = [];
-  const pending: string[] = [];
-
-  for (const id of previousState.pending) {
-    const proposal = previousState.proposals[id] ?? { id, status: "pending" };
-    const currentProposalState = current.get(id);
-
-    if (currentProposalState === "checked") {
-      approved.push({ id, proposal });
-      continue;
-    }
-
-    if (currentProposalState === "deleted" || currentProposalState === undefined) {
-      rejected.push({ id, proposal });
-      continue;
-    }
-
-    if (isExpired(proposal.capturedAt, now)) {
-      expired.push({ id, proposal });
-      continue;
-    }
-
-    unchanged.push({ id, proposal });
-    pending.push(id);
-  }
-
-  for (const [id, state] of current.entries()) {
-    if (previousState.pending.includes(id)) continue;
-    if (state === "unchecked") {
-      unchanged.push({ id, proposal: previousState.proposals[id] ?? { id, status: "pending" } });
-      pending.push(id);
-    }
-  }
-
-  return createStableDiff(approved, rejected, expired, unchanged, pending);
-}
-
 export async function promoteToMemory(proposalId: string): Promise<void> {
   const redis = getRedisClient();
   const key = proposalKey(proposalId);
@@ -533,10 +277,9 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
-export async function archiveProposal(proposalId: string, reason: "deleted" | "marked-rejected"): Promise<void> {
+export async function archiveProposal(proposalId: string, reason: string): Promise<void> {
   const redis = getRedisClient();
   const key = proposalKey(proposalId);
   const proposal = await redis.hgetall(key);
@@ -549,7 +292,6 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
 export async function expireProposal(proposalId: string): Promise<void> {
@@ -567,115 +309,62 @@
 
   await redis.lrem(REVIEW_PENDING_KEY, 0, proposalId);
   await redis.del(key);
-  await removeProposalFromReview(proposalId);
 }
 
 const promoteFunction = stabilizeFunctionOpts(
   inngest.createFunction(
-  {
-    id: "memory/review-promote",
-    name: "Promote Review Decisions",
-  },
-  [
     {
-      event: "content/updated",
-      if: `event.data.path == \"${REVIEW_PATH_FILTER}\" || event.data.path.endsWith(\"/${REVIEW_FILE_NAME}\")`,
+      id: "memory/review-promote",
+      name: "Promote Review Decisions",
     },
-    { cron: "0 8 * * *" },
-  ],
-  async ({ event, step }) => {
-    const shouldSkip = await step.run("filter-review-events", async () => {
-      if (event.name !== "content/updated") return false;
-      const updatedPath = extractContentPath(event.data);
-      if (!updatedPath) return false;
-      return !updatedPath.toLowerCase().endsWith(`/${REVIEW_FILE_NAME.toLowerCase()}`);
-    });
-
-    if (shouldSkip) {
-      return {
-        skipped: true,
-        reason: "content/updated path does not target REVIEW.md",
-      };
-    }
-
-    const parsed = await step.run("parse-review", async () => {
-      const reviewFile = Bun.file(getReviewPath());
-      if (!(await reviewFile.exists())) {
-        return { proposals: [] } as ParsedReview;
-      }
-
-      const markdown = await reviewFile.text();
-      return parseReviewMd(markdown);
-    });
-
-    const previous = await step.run("load-state", async () => {
-      const redis = getRedisClient();
-      return loadProposalState(redis);
-    });
-
-    const changes = await step.run("detect-changes", async () => detectChanges(parsed, previous));
-
-    await step.run("route", async () => {
-      const parsedById = new Map(parsed.proposals.map((proposal) => [proposal.id, proposal]));
+    [{ event: "memory/proposal.approved" }, { event: "memory/proposal.rejected" }, { cron: "0 8 * * *" }],
+    async ({ event, step }) => {
+      if (event.name === "memory/proposal.approved") {
+        const proposalId = await step.run("resolve-approved-proposal-id", async () => {
+          const id = (event.data as { proposalId?: unknown }).proposalId;
+          if (typeof id !== "string" || id.trim().length === 0) {
+            throw new Error("memory/proposal.approved requires event.data.proposalId");
+          }
+          return id;
+        });
 
-      for (const change of changes.approved) {
-        await promoteToMemory(change.id);
+        await step.run("promote-approved-proposal", async () => promoteToMemory(proposalId));
+        return { approved: [proposalId] };
       }
 
-      for (const change of changes.rejected) {
-        const reason = parsedById.get(change.id)?.state === "deleted" ? "marked-rejected" : "deleted";
-        await archiveProposal(change.id, reason);
-      }
+      if (event.name === "memory/proposal.rejected") {
+        const payload = await step.run("resolve-rejected-payload", async () => {
+          const id = (event.data as { proposalId?: unknown }).proposalId;
+          const reason = (event.data as { reason?: unknown }).reason;
+          if (typeof id !== "string" || id.trim().length === 0) {
+            throw new Error("memory/proposal.rejected requires event.data.proposalId");
+          }
+          if (typeof reason !== "string" || reason.trim().length === 0) {
+            throw new Error("memory/proposal.rejected requires event.data.reason");
+          }
+          return { proposalId: id, reason };
+        });
 
-      for (const change of changes.expired) {
-        await expireProposal(change.id);
+        await step.run("archive-rejected-proposal", async () => archiveProposal(payload.proposalId, payload.reason));
+        return { rejected: [payload.proposalId], reason: payload.reason };
       }
-    });
 
-    const updateState = await step.run("update-state", async () => {
-      const redis = getRedisClient();
-      const nextPending = [...new Set(changes.pending)];
-
-      await redis.del(REVIEW_PENDING_KEY);
-      if (nextPending.length > 0) {
-        await redis.rpush(REVIEW_PENDING_KEY, ...nextPending);
-      }
+      const expiredIds = await step.run("expire-stale-proposals", async () => {
+        const redis = getRedisClient();
+        const pending = await redis.lrange(REVIEW_PENDING_KEY, 0, -1);
+        const expired: string[] = [];
 
-      const parsedById = new Map(parsed.proposals.map((proposal) => [proposal.id, proposal]));
-      for (const id of nextPending) {
-        const existing = previous.proposals[id];
-        const parsedProposal = parsedById.get(id);
-        await redis.hset(
-          proposalKey(id),
-          "id",
-          id,
-          "status",
-          "pending",
-          "state",
-          parsedProposal?.state ?? "unchecked",
-          "capturedAt",
-          existing?.capturedAt ?? new Date().toISOString(),
-          "date",
-          existing?.date ?? new Date().toISOString().slice(0, 10),
-          "section",
-          existing?.section ?? "",
-          "change",
-          existing?.change ?? ""
-        );
-      }
+        for (const proposalId of pending) {
+          if (!isProposalOlderThanSevenDays(proposalId)) continue;
+          await expireProposal(proposalId);
+          expired.push(proposalId);
+        }
 
-      return {
-        pending: nextPending,
-      };
-    });
+        return expired;
+      });
 
-    return {
-      approved: changes.approved.map((item) => item.id),
-      rejected: changes.rejected.map((item) => item.id),
-      expired: changes.expired.map((item) => item.id),
-      pending: updateState.pending,
-    };
-  }
+      return { expired: expiredIds };
+    }
   )
 );
 

tokens used
102,094
